diff -u -P -r dr70107/command/batch.c d110721/command/batch.c
--- dr70107/command/batch.c	2005-02-18 02:52:48.000000000 +0000
+++ d110721/command/batch.c	2007-06-06 15:44:30.000000000 +0000
@@ -178,7 +178,7 @@
 
 EXTERN jmp_buf break_env;
 
-#define	MAX_LINE	128	/* Maximum No of Chars in input line	*/
+/*#define	MAX_LINE	128*/	/* Maximum No of Chars in input line	*/
 
 #if defined(CPM)
 EXTERN UWORD user;		/* USER Number variable for CPM.EXE	*/
@@ -549,6 +549,7 @@
 BYTE *s2;
 BYTE	dirbuf[MAX_PATHLEN];
 WORD	i;
+BYTE	quoteflag;
 
 	if(batchflg)			/* If a batch file is currently */
 	    batch_close();		/* close it. So minimum number	*/
@@ -594,13 +595,19 @@
 	strcpy(heap(), argv0);		/* Copy the invoking command	*/
 	heap_get(strlen(heap())+1);	/* and protect the buffer	*/
 
+	quoteflag=0;
 	while(*tail) {			/* While there are command line */
 	    s2 = (BYTE *)heap();	/* parameters copy them 	*/
-	    while(*tail && strchr(batch_sep, *tail))
+	    if (*tail=='"') quoteflag=!quoteflag;
+	    while(*tail && !quoteflag && strchr(batch_sep, *tail)) {
 		tail = skip_char(tail);
+		if (*tail=='"') quoteflag=!quoteflag;
+	    }
 
-	    while(*tail && !strchr(batch_sep, *tail))
+	    while(*tail && (quoteflag || !strchr(batch_sep, *tail))) {
 		copy_char(&s2, &tail);
+		if (*tail=='"') quoteflag=!quoteflag;
+	    }
 
 	    *s2++ = '\0';
 	    heap_get(strlen(heap()) + 1);
diff -u -P -r dr70107/command/cmdlist.c d110721/command/cmdlist.c
--- dr70107/command/cmdlist.c	2005-01-24 16:49:08.000000000 +0000
+++ d110721/command/cmdlist.c	2008-07-18 11:08:18.000000000 +0000
@@ -105,7 +105,8 @@
 EXTERN VOID CDECL cmd_rem(BYTE *, BYTE *);  
 EXTERN VOID CDECL cmd_set(BYTE *, BYTE *);  
 EXTERN VOID CDECL cmd_shift(BYTE *, BYTE *);
-EXTERN VOID CDECL cmd_or(BYTE *, BYTE *); 
+EXTERN VOID CDECL cmd_or(BYTE *, BYTE *);
+EXTERN VOID CDECL cmd_colour(BYTE *, BYTE *);
 
 GLOBAL S_CMD cmd_list[] =
 {
@@ -165,6 +166,7 @@
 	{ "ver",	cmd_ver,	PARAM_NONE,	DLS_help_ver	},
 	{ "verify",	cmd_verify,	PARAM_NONE,	DLS_help_verify	},
 	{ "vol",	cmd_vol,	PARAM_NONE,	DLS_help_vol	},
+	{ "colour",	cmd_colour,	PARAM_NONE,	DLS_help_colour	},
 
 	{ NULL, 	NULL,		PARAM_NONE }
 };
diff -u -P -r dr70107/command/com.c d110721/command/com.c
--- dr70107/command/com.c	2005-01-10 23:12:02.000000000 +0000
+++ d110721/command/com.c	2008-11-18 16:11:02.000000000 +0000
@@ -260,7 +260,7 @@
 #endif
 
 #if !defined(CDOSTMP)
-BYTE	autoexec_name[13] = "autoexec.bat";
+BYTE	autoexec_name[13] = "AUTOEXEC.BAT";
 #endif
 
 #if defined(DOSPLUS)
@@ -276,7 +276,8 @@
 VOID FAR CDECL _main(cmd)
 BYTE	*cmd;
 {
-	BYTE    cmd_buf[128];
+/*	BYTE    cmd_buf[128];*/
+	BYTE    cmd_buf[MAX_LINE];
 
 #if defined(CDOSTMP)				/* Insure the NETWORK_INIT   */
 	network_init();				/* function is called before */
@@ -446,8 +447,11 @@
 	UWORD	FAR *p_batch_seg;
 #endif
 	BYTE	lferror = 0;
+	BYTE	*h;
 	strcpy(kbdptr, "");			/* start with no commands */
 
+	if (!(get_cmdname(heap())))
+	    set_reload_file();
 #if 0
 #if defined(DLS)
 	dls_msg_ver(MSG_VER);			/* check message file version*/
@@ -550,6 +554,7 @@
 
 	s = (BYTE *) heap_get(128); /* allocate some heap memory */
 
+
 	FOREVER {
 	    cmd = deblank(cmd);			/* Deblank the command line  */
 	    if((*cmd == '\0') || (*cmd == *switchar))
@@ -790,7 +795,14 @@
 	    strcpy(heap(), "!");
 	    strcat(heap(), autoexec_name);
 	    if((ret = file_exist(heap()+1)) != 0) {
-		if (boot_key_scan_code != 0x3f00 /*F5*/)
+		if (boot_key_scan_code==0x4200) { /*F8*/
+		  h=heap()+strlen(heap())+1;
+		  strcpy(h,"Execute ");
+		  strcat(h,autoexec_name);
+		  optional_line(h);
+		  if (*h==0) boot_key_scan_code=0x3f00;
+		}
+		if (boot_key_scan_code != 0x3f00) /*F5*/
 		    strcat(kbdptr,heap());
 		break;
 	    } else {
diff -u -P -r dr70107/command/comcpy.c d110721/command/comcpy.c
--- dr70107/command/comcpy.c	1997-04-16 21:53:30.000000000 +0000
+++ d110721/command/comcpy.c	2008-03-04 10:28:00.000000000 +0000
@@ -181,7 +181,7 @@
 MLOCAL VOID e_check2(WORD);
 MLOCAL BOOLEAN touch(BYTE *);
 MLOCAL BYTE * get_pswd(BYTE *);
-
+MLOCAL WORD ret;
 
 /* define external variables used */
 
@@ -234,8 +234,10 @@
 	WORD	rmode = 0x0000; 	/* read mode - normal files only */
 	BYTE	delim;
 	BYTE	npara;
-	BYTE	src[MAX_FILELEN];	/* buffer in which to expand wild source filespec */
-	BYTE	dest[MAX_FILELEN];	/* buffer in which to expand wild destination filespec */
+/*	BYTE	src[MAX_FILELEN];*/	/* buffer in which to expand wild source filespec */
+/*	BYTE	dest[MAX_FILELEN];*/	/* buffer in which to expand wild destination filespec */
+	BYTE	src[MAX_LFNLEN];	/* buffer in which to expand wild source filespec */
+	BYTE	dest[MAX_LFNLEN];	/* buffer in which to expand wild destination filespec */
 #if defined(PASSWORD)
 	BYTE	password[10];		/* keep note of src password    */
 #endif
@@ -250,11 +252,16 @@
 	UWORD	dosvf;			/* used to save current dos verify state */
 	UWORD	sflag;			/* Source File Options		*/
 					/* scheme2 extra bits */
-	BYTE	wdfn[13];		/* used by scheme2 to save wild destination filename */
+/*	BYTE	wdfn[13];*/		/* used by scheme2 to save wild destination filename */
+	BYTE	wdfn[MAX_LFNLEN];	/* used by scheme2 to save wild destination filename */
 	BYTE	*dfptr;
 	BYTE	*ocmd;	 
-	BYTE	src2[MAX_FILELEN];	/* 2nd src buffer for scheme2 */
+/*	BYTE	src2[MAX_FILELEN];*/	/* 2nd src buffer for scheme2 */
+	BYTE	src2[MAX_LFNLEN];	/* 2nd src buffer for scheme2 */
 	DTA	search; 		/* DOS Search Buffer		*/
+	FINDD	finddata;
+	BOOLEAN	lfnsearch;
+	UWORD	shandle;
 
 	sascii = NO;		/* indicates if current source is ascii or not */
 	sbin   = NO;		/* sbin indicates if an explicit /b found */
@@ -376,7 +383,9 @@
 	{
 	    get_filename(dest,lp,YES);		/* this turns lpt1: into lpt1 */
 	    
-	    ret = ms_x_open(dest, OPEN_READ);	/* Check if destination	is */
+	    ret = ms_l_open(dest, OPEN_READ);	/* Check if destination	is */
+	    if (ret==ED_FUNCTION)
+	      ret=ms_x_open(dest,OPEN_READ);
 	    if (ret >= 0)			/* a device. If so, if /b  */
 	    {					/* on src OR dst, copy is  */
 	    	if (isdev(ret))			/* binary		   */
@@ -432,7 +441,7 @@
 #if TRUE
 /* ##jc##
  *	This Code is a Special for IBM Display Write 4 which attempts
- *	to copy "A:DEFAULT.P*TÌ". Treat this a a secial case and convert
+ *	to copy "A:DEFAULT.P*TÌ". Treat this as a special case and convert
  *	it to "A:DEFAULT.P*".
  */
 	tp = strchr(fptr(src), '.');		/* Search for . in the 	*/
@@ -467,12 +476,23 @@
 
 	tp=fptr(src);			/* get ptr to filename part of src  */
 
-	ret=ms_x_first(src,rmode,&search); /* get first explicit source (if src wild) */
+	ret=ms_l_first(src,rmode,&finddata); /* get first explicit source (if src wild) */
 					/* if(ret < 0) check moved till after prtsrc */
+	if (ret!=ED_FUNCTION) {
+	  shandle=finddata.handle;
+	  lfnsearch=1;
+	}
+	else {
+	  ret = ms_x_first(src,rmode,&search);
+	  if (!ret) {
+	    strcpy(finddata.lname,search.fname);
+	  }
+	  lfnsearch=0;
+	}
 
 loop12: 
 	if(ret >= 0) {			/* copy explicit filename to src */
-	    strcpy(tp,search.fname);	/* only do this if a file was found */
+	    strcpy(tp,finddata.lname);	/* only do this if a file was found */
 #if defined(PASSWORD)
 	    strcat(tp,password);	/* add the src password             */
 #endif
@@ -534,7 +554,17 @@
 	   else {
 	     if (srcopen) ms_x_close(sfh);
 	   }
-	   ret = ms_x_next(&search);
+/*	   ret = ms_x_next(&search);*/
+	   if (lfnsearch) {
+	     ret = ms_l_next(shandle,&finddata);	/* get the next file and    */
+	   }
+	   else {
+	     ret = ms_x_next(&search);	/* get the next file and    */
+	     if (!ret) {
+	       strcpy(finddata.lname,search.fname);
+	     }
+	   }
+
 	   if(!ret)  goto loop12;	    /* loop round and do it again */
 					    /* if more files match wild src */
 	 
@@ -641,7 +671,16 @@
 						     
 	    skip2:
 
-	    ret = ms_x_next(&search);
+/*	    ret = ms_x_next(&search);*/
+	    if (lfnsearch) {
+	      ret = ms_l_next(shandle,&finddata);	/* get the next file and    */
+	    }
+	    else {
+	      ret = ms_x_next(&search);	/* get the next file and    */
+	      if (!ret) {
+	        strcpy(finddata.lname,search.fname);
+	      }
+	    }
 	    if(!ret) 			/* loop round and do it again */
 		goto loop12;		/* if wild src */
 
@@ -666,6 +705,8 @@
 	if(COPY_VERIFY)
 	    ms_f_verify(dosvf);			/* retore verify state */
 
+	if (lfnsearch) ms_l_findclose(shandle);
+
 }	/* end of cmd_copy */
 
 
@@ -783,7 +824,9 @@
 	if(iswild(s))			/* If an ambiguous reference    */
 	    return (NO);		/* then no a specific file ref. */
 		
-	ret = ms_x_chmod (s, ATTR_ALL, 0);	/* get attributes of filespec */
+	ret = ms_l_chmod (s, ATTR_ALL, 0);	/* get attributes of filespec */
+	if (ret==ED_FUNCTION)
+	  ret=ms_x_chmod(s,ATTR_ALL,0);
 	
 	if(ret == ED_FILE)		/* file not found (file yet to be created) */
 	    return (YES);		/* it will be a file */
@@ -837,7 +880,11 @@
 	    return (FAILURE);	/* invalid dest drive */
 	}
 		
-	if((dfh=ms_x_creat(dest,0)) < 0) {  /* create destination file or truncate to empty */
+	dfh=ms_l_creat(dest,0);
+	if (dfh==ED_FUNCTION)
+	  dfh=ms_x_creat(dest,0);
+/*	if((dfh=ms_x_creat(dest,0)) < 0) {*/  /* create destination file or truncate to empty */
+	if(dfh<0) { 		 /* create destination file or truncate to empty */
 	    e_check2(dfh);		/* if error */
 	    return (FAILURE);
 	}
@@ -902,8 +949,11 @@
 	    ms_x_close(dfh);	/* close destination */
 	    dstopen = NO;
 
-	    if(failed) 		/* if failed, delete incomplete destination */
-		ms_x_unlink(dest);
+	    if(failed) {	/* if failed, delete incomplete destination */
+		ret=ms_l_unlink(dest,0);
+		if (ret==ED_FUNCTION)
+		  ms_x_unlink(dest);
+	    }
 	    
 	    else {			/* (didnt fail) */
 #if 0
@@ -912,7 +962,9 @@
 		    if (!COPY_SYS) {
 		        dattrib &= ~ATTR_HID;	/* if not /S , then dont let hidden attribute be set */
 		    }
-		    ms_x_chmod(dest,dattrib,1);	/* change destination attributes  */
+		    ret=ms_l_chmod(dest,dattrib,1);	/* change destination attributes  */
+		    if (ret==ED_FUNCTION)
+		      ms_x_chmod(dest,dattrib,1);
 	        }				/* under same conditions as tstamp */
 #endif
 	    }					/* nb must be done after dest closed */
@@ -949,9 +1001,14 @@
 	    return (FAILURE);	/* invalid src drive */
 	}
 
-	sfh = ms_x_open(src, OPEN_READ);	/* Open the File/Device using*/
-	if(sfh == ED_ACCESS)			/* a sharing mode if Access  */
-	    sfh = ms_x_open(src, OPEN_RO);	/* denied try compatibility  */
+	sfh = ms_l_open(src, OPEN_READ);	/* Open the File/Device using*/
+	if (sfh==ED_FUNCTION)
+	  sfh=ms_x_open(src,OPEN_READ);
+	if(sfh == ED_ACCESS) {			/* a sharing mode if Access  */
+	    sfh = ms_l_open(src, OPEN_RO);	/* denied try compatibility  */
+	    if (sfh==ED_FUNCTION)
+	      sfh=ms_x_open(src,OPEN_RO);
+	}
 						/* mode. FrameWork Setup     */
 	if(sfh < 0) {				/* leaves a control file Open*/
 	    e_check2(sfh);			/* during the copy.	     */
@@ -976,7 +1033,9 @@
 	ms_x_lseek(sfh,0,0);
 
 	srcopen=YES;
-	attrib=ms_x_chmod(src,attrib,0);	/* read src file attributes */
+	attrib=ms_l_chmod(src,attrib,0);	/* read src file attributes */
+	if (attrib==ED_FUNCTION)
+	  attrib=ms_x_chmod(src,attrib,0);
 
 	/* Don't copy 0 length files */
 	if (src_len == 0L && !srcdev) return(FAILURE);
@@ -1147,7 +1206,9 @@
 	    if(!dstopen) {		/* if destination not open, open it */
 		if(ABloop1) {		/* special case if 2nd time round the loop */
 					/* and single drive copy */
-		    dfh=ms_x_open(dest,OPEN_RDWR);	/* open dest for rw	*/
+		    dfh=ms_l_open(dest,OPEN_RDWR);	/* open dest for rw	*/
+		    if (dfh==ED_FUNCTION)
+		      dfh=ms_x_open(dest,OPEN_RDWR);
 		    dstopen=YES;
 		    ms_x_lseek(dfh, (LONG) 0,2);	/* lseek to end of dest */
 		}
@@ -1242,7 +1303,9 @@
 	
 	touch(dest);			/* set timestamp */
 		
-	dfh=ms_x_open(dest,OPEN_RDWR);		/* open file for read and write */
+	dfh=ms_l_open(dest,OPEN_RDWR);		/* open file for read and write */
+	if (dfh==ED_FUNCTION)
+	  dfh=ms_x_open(dest,OPEN_RDWR);
 
 /*	if(dfh==ED_FILE)		  */ /* if file doesnt exist, create it */
 /*		return(dopen(dest)); */ /* not necessary as src/dest must exist as found by ms_x_first */
@@ -1307,11 +1370,17 @@
 BOOLEAN  mess;
 {
 #if 1
-BYTE	sp[MAX_PATHLEN+MAX_FILELEN+3];
-BYTE	dp[MAX_PATHLEN+MAX_FILELEN+3];
-	
- 	ms_x_expand(sp, src);
- 	ms_x_expand(dp, dest);
+/*BYTE	sp[MAX_PATHLEN+MAX_FILELEN+3];
+BYTE	dp[MAX_PATHLEN+MAX_FILELEN+3];*/
+BYTE	sp[MAX_PATHLEN+MAX_LFNLEN+3];
+BYTE	dp[MAX_PATHLEN+MAX_LFNLEN+3];
+
+ 	ret=ms_l_expand(sp, src);
+	if (ret==ED_FUNCTION)
+	  ms_x_expand(sp,src);
+ 	ret=ms_l_expand(dp, dest);
+	if (ret==ED_FUNCTION)
+	  ms_x_expand(dp,dest);
  
  	if(strcmp(sp,dp)!=0)
  	    return (NO);
@@ -1464,7 +1533,11 @@
 	date=((tdate.year-1980)<<9) + (tdate.month<<5) + tdate.day;
 	time=(ttime.hour<<11) + (ttime.min<<5) + (ttime.sec>>1);
 	
-	if((fh=ms_x_open(s,OPEN_RDWR)) >=0) {	/* open file for r/w if no error */
+	fh=ms_l_open(s,OPEN_RDWR);
+	if (fh==ED_FUNCTION)
+	  fh=ms_x_open(s,OPEN_RDWR);
+/*	if((fh=ms_x_open(s,OPEN_RDWR)) >=0) {*/	/* open file for r/w if no error */
+	if(fh >=0) {			/* open file for r/w if no error */
 	    ms_x_datetime(1,fh,&time,&date); /* change files timestamp */
 	    ms_x_close(fh);
 	    return (SUCCESS);
diff -u -P -r dr70107/command/comint.c d110721/command/comint.c
--- dr70107/command/comint.c	2004-11-24 17:31:18.000000000 +0000
+++ d110721/command/comint.c	2011-07-12 21:40:54.000000000 +0000
@@ -58,7 +58,6 @@
 #include	"toupper.h"
 #include	"support.h"		/* Support routines		 */
 #include	"global.h"
-#include	"dos7.h"
 #include	<limits.h>
 
 /*RG-00-*/
@@ -415,14 +414,17 @@
 UWORD	flags;			/* Command Flags		*/
 #endif
 {
-BYTE	dispbuf[MAX_PATHLEN];
+/*BYTE	dispbuf[MAX_PATHLEN];*/
+BYTE	dispbuf[MAX_LFNLEN];
 WORD	ret;
 
 	dispbuf[0] = (BYTE) (drv + 'A');	/* Display the path of the */
 	dispbuf[1] = ':';			/* requested drive	   */
 	dispbuf[2] = *pathchar;
 
-	ret = ms_x_curdir(drv+1, dispbuf+3);
+	ret = ms_l_curdir(drv+1, dispbuf+3);
+	if (ret==ED_FUNCTION)
+	  ret=ms_x_curdir(drv+1,dispbuf+3);
 	if (ret < 0) return;
 	
 #if !defined(NOXBATCH) && (defined(CDOS) || defined(CDOSTMP))
@@ -521,7 +523,15 @@
 	}	
 	/* Make the drive Assignment	  */
 	if (!d_check(cp)) ddrive = -1;
-	e_check(ddrive != -1 ? ms_x_chdir(cp) : ED_DRIVE);
+/*	e_check(ddrive != -1 ? ms_x_chdir(cp) : ED_DRIVE);*/
+	if (ddrive!=-1) {
+	  ret=ms_l_chdir(cp);
+	  if (ret==ED_FUNCTION)
+	    ret=ms_x_chdir(cp);
+	}
+	else
+	  ret=ED_DRIVE;
+	e_check(ret);
 }
 
 
@@ -620,11 +630,22 @@
  *	Display or Set the current date making full use of the DOS
  *	international system call.
  */
+#define	DATE_SHOW	(flags & 1)
 
 GLOBAL VOID CDECL cmd_date(s)
 BYTE	*s;
 {
 	BYTE	buffer[18];			/* Local Input Buffer */
+	UWORD	flags;
+
+	if(f_check (s, "t", &flags, NO))	/* Check for valid Flags    */
+	    return;
+
+	if(DATE_SHOW) {
+	  printf(CUR_DATE);
+	  disp_sysdate ();
+	  return;
+	}
 
 	if (*s) {
 	    if(check_date(s))
@@ -771,6 +792,7 @@
 #define DIR_CHANGE	(0x0080)	/* Change the Default Opts */
 #define	DIR_NOPAGE	(0x0100)	/* No Paging of Output	   */
 #define DIR_2COLS	(0x0200)	/* double column listing   */
+#define	DIR_BARE	(0x0400)	/* List Filenames only     */
 #define	OPT(x)		(flags & x)	/* Return Flag Conditions  */
 
 MLOCAL UWORD dir_default = DIR_DIR | DIR_LONG;
@@ -784,13 +806,18 @@
 	if(OPT(DIR_LONG)) {		/* Force DIR_WIDE to be cleared	*/
 	    flags &= ~DIR_WIDE;		/* if the LONG format has been	*/
 	    flags &= ~DIR_2COLS;	/* selected.			*/
+	    flags &= ~DIR_BARE;
 	}
 
 	if(OPT(DIR_2COLS)) {
 	    flags &= ~DIR_LONG;
 	    flags &= ~DIR_WIDE;
+	    flags &= ~DIR_BARE;
 	}
 
+	if(OPT(DIR_WIDE))
+	  flags&=~DIR_BARE;
+
 	if(page_wid < 76)		/* Check the screen is wide	*/
 	    flags &= ~DIR_WIDE;		/* enough to display directory	*/
 	    
@@ -815,16 +842,21 @@
 	WORD	 nfiles, system, others, i;
 	ULONG	 nfree = 0UL;
 	DTA	 search;
-	BYTE	 path[MAX_FILELEN];
-	BYTE	 s[MAX_PATHLEN], temp[3];
+/*	BYTE	 path[MAX_FILELEN];
+	BYTE	 s[MAX_PATHLEN], temp[3];*/
+	BYTE	 path[MAX_LFNLEN];
+	BYTE	 s[MAX_LFNLEN], temp[3];
 	BYTE	 *ext, *memory;
 	UWORD	 free, secsiz, nclust;
 	UWORD	 flags;
 	FREED	freespace;
-	BYTE	FAR *dpath="A:\\";
+	BYTE	*dpath="A:\\";
 	BYTE	sbase=0;
+	FINDD	finddata;
+	BOOLEAN	lfnsearch;
+	UWORD	shandle;
 
-	if(f_check (cmd, "dsawlprcn2", &flags, NO))	/* if any bad flags */
+	if(f_check (cmd, "dsawlprcn2b", &flags, NO))	/* if any bad flags */
 	    return;					/*    don't do it   */
 
 	flags = dir_flags(flags);	/* Manipulate the flags to remove   */
@@ -844,10 +876,15 @@
 	{
 	    strcpy(s,"d:"); s[0] = (BYTE) (ddrive + 'A');
 	    append_slash(s);
-	    ms_x_curdir(ddrive+1,s+3);	/* get the current dir */
+	    ret=ms_l_curdir(ddrive+1,s+3);	/* get the current dir */
+	    if (ret==ED_FUNCTION)
+	      ms_x_curdir(ddrive+1,s+3);
+	}
+	else {
+	    ret=ms_l_expand(s,path);
+	    if (ret==ED_FUNCTION)
+	      ms_x_expand(s,path);
 	}
-	else
-	    ms_x_expand(s,path);
 
 	ext = fptr(path);
 	if(*ext == '.' && strcmp(dotdot+1, ext) && strcmp(dotdot, ext)) {
@@ -869,14 +906,20 @@
 	    if(!iswild(ext)) {			/* specified and it does not*/
 
 #if defined(PASSWORD)
-	      if (ddrive != -1 && ms_x_chdir(s) < 0) {
+	      ret=ms_l_chdir(s);
+	      if (ret==ED_FUNCTION)
+		ret=ms_x_chdir(s);
+/*	      if (ddrive != -1 && ms_x_chdir(s) < 0) {*/
+	      if (ddrive != -1 && ret < 0) {
 	/* if cd to current dir fails then current dir must be password     */
 	/* protected. So let's do the next bit the non-novell way.	    */
 
 	/* This method of determining if the user has specified a directory */
 	/* DOES NOT work on NOVELL drives.				    */
 
-		ret = ms_x_chmod(path, 0, 0);	/* contain a '.'. Skip if   */
+		ret = ms_l_chmod(path, 0, 0);	/* contain a '.'. Skip if   */
+		if (ret==ED_FUNCTION)
+		  ret=ms_x_chmod(path,0,0);
 		if(ret > 0 && (ret & ATTR_DIR))	/* a path was specified.    */
 		    break;			/* Otherwise append ".*".   */
 
@@ -893,18 +936,24 @@
 #endif
 		if (ddrive != -1)
 		{
-		    ret = ms_x_chdir(path);	 /* try to cd to path specified */
+		    ret = ms_l_chdir(path);	 /* try to cd to path specified */
+		    if (ret==ED_FUNCTION)
+		      ret=ms_x_chdir(path);
 #if defined(PASSWORD)
 		    if (memory) *memory = 0; /* remove password again */
 #endif
 		    if (ret >= 0) {		 /* if there wasn't an error... */
-			ms_x_chdir(s);	 /* ...restore original directory... */
+			ret=ms_l_chdir(s);	 /* ...restore original directory... */
+			if (ret==ED_FUNCTION)
+			  ms_x_chdir(s);
 			break;		 /* ...and get the hell out */
 		    }
 		}
 		else
 		{
-		    ret = ms_x_chmod(path,0,0);
+		    ret = ms_l_chmod(path,0,0);
+		    if (ret==ED_FUNCTION)
+		      ret=ms_x_chmod(path,0,0);
 		    if (ret >= 0 && (ret & ATTR_DIR)) break; 
 		}
 #if defined(PASSWORD)
@@ -921,6 +970,7 @@
 	if(nofiles(path, ATTR_ALL, NO, YES)) 	/* if no files/dirs or error*/
 	    return;				/* then we can't do this    */
 
+	if (!OPT(DIR_BARE)) {
 	if (ddrive != -1)
 	{
 	    strcpy (temp, "d:");		/* Display the drive Volume	*/
@@ -929,12 +979,15 @@
 	}
 	else
 	    show_crlf(OPT(DIR_PAGE));
+	}
 
 #if 0
 	/* this has been done earlier */
 	strcpy(s, "d:"); s[0] = (BYTE) (ddrive + 'A');
 	append_slash(s);
-	ms_x_curdir(ddrive+1, s+3);	/* Get the current dir		*/
+	ret=ms_l_curdir(ddrive+1, s+3);	/* Get the current dir		*/
+	if (ret==ED_FUNCTION)
+	  ms_x_curdir(ddrive+1,s+3);
 #endif
 
 	strip_path(path, memory = (BYTE *)heap());/* Get the Path Spec and  */
@@ -942,26 +995,40 @@
 		(memory[1] == ':' ? 3 : 1))	/* Path Character.	    */
 		memory[--i] = '\0';
 
+	if (!OPT(DIR_BARE)) {
 	if(i == 0 || (i == 2 && memory[1] == ':')) {
 	    printf (MSG_DIR, temp, s+3);	/* DIR of current Directory  */
 	}
 	else
 	{
-	  if (ddrive == -1 || ms_x_chdir(s) < 0) { /* assume this means pword protected */
+	  ret=ms_l_chdir(s);
+	  if (ret==ED_FUNCTION)
+	    ret=ms_x_chdir(s);
+/*	  if (ddrive == -1 || ms_x_chdir(s) < 0) {*/ /* assume this means pword protected */
+	  if (ddrive == -1 || ret < 0) { /* assume this means pword protected */
 	    ext = memory+strlen(memory)+1;
-	    ms_x_expand(ext,memory);
+	    ret=ms_l_expand(ext,memory);
+	    if (ret==ED_FUNCTION)
+	      ms_x_expand(ext,memory);
 	    if (ddrive != -1)
 	      printf(MSG_DIR, temp, ext+3);
 	    else
 	      printf(MSG_DIR,"",ext+1);
 	  }
 	  else {
-	    ms_x_chdir(memory); 		/* Change the directory      */
-	    ms_x_curdir(ddrive+1, memory);	/* Get the current directory */
-	    ms_x_chdir(s);			/* Restore the directory     */
+	    ret=ms_l_chdir(memory); 		/* Change the directory      */
+	    if (ret==ED_FUNCTION)
+	      ms_x_chdir(memory);
+	    ret=ms_l_curdir(ddrive+1, memory);	/* Get the current directory */
+	    if (ret==ED_FUNCTION)
+	      ms_x_curdir(ddrive+1,memory);
+	    ret=ms_l_chdir(s);			/* Restore the directory     */
+	    if (ret==ED_FUNCTION)
+	      ms_x_chdir(s);
 	    printf (MSG_DIR, temp, memory);
 	  }
 	}
+	}
 
 	others = 0;			/* assume no SYS/DIR files	*/
 	nfiles = 0;			/* initialize file count	*/
@@ -969,33 +1036,82 @@
 
 	system = OPT(DIR_SYS) ? ATTR_SYS : 0;
 
-	ret = ms_x_first(path, ATTR_ALL, &search);
+	ret = ms_l_first(path, ATTR_ALL, &finddata);
+	if (ret!=ED_FUNCTION) {
+	  if (!ret && finddata.sname[0]==0) {
+	    strcpy(finddata.sname,finddata.lname);
+	    finddata.lname[0]=0;
+	  }
+	  shandle=finddata.handle;
+	  lfnsearch=1;
+	}
+	else {
+	  ret = ms_x_first(path, ATTR_ALL, &search);
+	  if (!ret) {
+	    finddata.fattr=search.fattr;
+	    finddata.ftime=search.ftime;
+	    finddata.fdate=search.fdate;
+	    finddata.fsize=search.fsize;
+	    finddata.fsizeh=0;
+	    strcpy(finddata.sname,search.fname);
+	    finddata.lname[0]=0;
+	  }
+	  lfnsearch=0;
+	}
 
-	if(!ret && (search.fattr & ATTR_DEV))	/* Check if the user has     */
+	if(!ret && (finddata.fattr & ATTR_DEV))	/* Check if the user has     */
 	    ret = ED_FILE;			/* specified a device then   */
 						/* generate an error.	     */
 	while(!ret) {
-	    if(!OPT(DIR_ALL) && (search.fattr & ATTR_SYS) != system) {
+	    if(!OPT(DIR_ALL) && (finddata.fattr & ATTR_SYS) != system) {
 						/* not the correct file type*/
 		others++;			/* remember others do exist */
-		ret = ms_x_next(&search);	/* get the next file and    */
+		if (lfnsearch) {
+		  ret = ms_l_next(shandle,&finddata);	/* get the next file and    */
+		  if (!ret && finddata.sname[0]==0) {
+		    strcpy(finddata.sname,finddata.lname);
+		    finddata.lname[0]=0;
+		  }
+		}
+		else {
+		  ret = ms_x_next(&search);	/* get the next file and    */
+		  if (!ret) {
+		    finddata.fattr=search.fattr;
+		    finddata.ftime=search.ftime;
+		    finddata.fdate=search.fdate;
+		    finddata.fsize=search.fsize;
+		    finddata.fsizeh=0;
+		    strcpy(finddata.sname,search.fname);
+		    finddata.lname[0]=0;
+		  }
+		}
 		continue;			/* continue the display     */
 	    }
 
-	    ext = strchr(search.fname, '.');	/* Get the file extension   */
-	    if(ext && ext != search.fname)	/* set the extension to NULL*/
+	    ext = strchr(finddata.sname, '.');	/* Get the file extension   */
+	    if(ext && ext != finddata.sname)	/* set the extension to NULL*/
 		*ext++ = '\0';			/* if no '.' exists or this */
 	    else				/* is the ".." or "." entry.*/
 		ext = "";
 
-	    if(OPT(DIR_WIDE)) {
+	    if(OPT(DIR_BARE)) {
+	      if (*finddata.lname)
+		printf ("%s",finddata.lname);
+	      else
+		if (*ext)
+		  printf ("%s.%s",finddata.sname,ext);
+		else
+		  printf ("%s",finddata.sname);
+	      show_crlf(OPT(DIR_PAGE));
+	    }
+	    else if(OPT(DIR_WIDE)) {
 		if ((nfiles % 5) == 0)
 		    show_crlf(OPT(DIR_PAGE));
 
 		printf ("%c:%c%-9s%-3s",
 			(nfiles % 5) ? ' ' : ddrive + 'A',
-			(search.fattr & ATTR_DIR) ? *pathchar : ' ',
-			search.fname, ext);
+			(finddata.fattr & ATTR_DIR) ? *pathchar : ' ',
+			finddata.sname, ext);
 	    }
 	    else {
 		if (OPT(DIR_2COLS)) {
@@ -1003,41 +1119,73 @@
 		}
 		else
 		    show_crlf(OPT(DIR_PAGE));
-		printf("%-9s%-3s", search.fname, ext);
-		if (search.fattr & ATTR_DIR)
+		printf("%-9s%-3s", finddata.sname, ext);
+		if (finddata.fattr & ATTR_DIR)
 /*		    printf(" <DIR>   ");*/
 		  if (OPT(DIR_2COLS))
-		    printf(" <DIR>    ");
+		    printf(" <DIR>     ");
 		  else
-		    printf(" <DIR>        ");
-		else
+		    printf(" <DIR>         ");
+		else {
+		  ret=conv64(&finddata.fsize,&finddata.fsizeh);
 		  if (OPT(DIR_2COLS))
 /*		    printf ("%9lu", search.fsize);*/
-		    printf ("%10lu", search.fsize);
+		    printf ("%11lu", finddata.fsize);
 		  else
-		    printf ("%14s", thousands(search.fsize));
+		    printf ("%14s", thousands(finddata.fsize));
+		  switch (ret) {
+		    case 1:  printf("K");
+			     break;
+		    default: printf(" ");
+			     break;
+		  }
+		}
 
-		if(search.fdate) {	   /* if timestamp exists */
-		    printf (" "); disp_filedate (search.fdate);
-		    printf (" "); disp_filetime (search.ftime);
-		    if ((OPT(DIR_2COLS)) && (nfiles%2 == 0)) printf ("   ");
+		if(finddata.fdate) {	   /* if timestamp exists */
+/*		    printf (" "); disp_filedate (finddata.fdate);*/
+		    if (!OPT(DIR_2COLS)) printf(" ");
+		    disp_filedate (finddata.fdate);
+		    printf (" "); disp_filetime (finddata.ftime);
+		    if (!OPT(DIR_2COLS)) printf (" %s",finddata.lname);
+		    if ((OPT(DIR_2COLS)) && (nfiles%2 == 0)) printf (" ");
 		}
 		else {
 		    if ((OPT(DIR_2COLS)) && (nfiles%2 == 0)) printf("\t\t\t");
 		}
 	    }
 	    nfiles ++;
-	    ret = ms_x_next(&search);
+	    if (lfnsearch) {
+	      ret = ms_l_next(shandle,&finddata);	/* get the next file and    */
+	      if (!ret && finddata.sname[0]==0) {
+		strcpy(finddata.sname,finddata.lname);
+		finddata.lname[0]=0;
+	      }
+	    }
+	    else {
+	      ret = ms_x_next(&search);
+	      if (!ret) {
+		finddata.fattr=search.fattr;
+		finddata.ftime=search.ftime;
+		finddata.fdate=search.fdate;
+		finddata.fsize=search.fsize;
+		finddata.fsizeh=0;
+		strcpy(finddata.sname,search.fname);
+		finddata.lname[0]=0;
+	      }
+	    }
 	}
 
+	if (lfnsearch) ms_l_findclose(shandle);
+
+	if (!OPT(DIR_BARE)) {
 	if(others + nfiles == 0) {	/* If no matching files then exit  */
 	    e_check(ED_FILE);		/* after displaying File Not Found */
 	}
+	}
 
 	dpath[0]=ddrive+'A';
-	freespace.size=sizeof(freespace);
 	freespace.ver=0;
-	ret=ms_edrv_space(&dpath,(BYTE *)&freespace,sizeof(freespace));
+	ret=ms_edrv_space(dpath,(BYTE *)&freespace,sizeof(freespace));
 	if (ret==0) {
 	  nfree=freespace.freecl*freespace.secpclus;
 	  if (ULONG_MAX/freespace.bytepsec>=nfree)
@@ -1060,25 +1208,26 @@
 	nfree = (ULONG)ret * (ULONG)free * (ULONG)secsiz;
 	}
 
-	show_crlf(OPT(DIR_PAGE));
-	if (ddrive != -1) {
-/*	    printf ("%9d %s%10ld %s", nfiles, MSG_FILES, nfree, MSG_FREE);*/
-/*	    printf ("%9s %s%15ls %s", thousands(nfiles), MSG_FILES, thousands(nfree), MSG_FREE);*/
-	    printf ("%9s %s", thousands(nfiles), MSG_FILES);
-	    printf ("%15ls ", thousands(nfree));
-	    if (sbase==1) printf("K");
-	    printf("%s",MSG_FREE);
-	}
-	else
-/*	    printf ("%9d %s", nfiles, MSG_FILES);*/
-	    printf ("%9s %s", thousands(nfiles), MSG_FILES);
-	show_crlf(OPT(DIR_PAGE));
+	if (!OPT(DIR_BARE)) {
+	  show_crlf(OPT(DIR_PAGE));
+	  if (ddrive != -1) {
+/*	      printf ("%9d %s%10ld %s", nfiles, MSG_FILES, nfree, MSG_FREE);*/
+/*	      printf ("%9s %s%15ls %s", thousands(nfiles), MSG_FILES, thousands(nfree), MSG_FREE);*/
+	      printf ("%9s %s", thousands(nfiles), MSG_FILES);
+	      printf ("%15ls ", thousands(nfree));
+	      if (sbase==1) printf("K");
+	      printf("%s",MSG_FREE);
+	  }
+	  else
+/*	      printf ("%9d %s", nfiles, MSG_FILES);*/
+	      printf ("%9s %s", thousands(nfiles), MSG_FILES);
+	  show_crlf(OPT(DIR_PAGE));
 
-	if(others)			/* if others do exist, tell them */
-	    printf (MSG_EXIST, system ? MSG_NSYS : MSG_NDIR);
+	  if(others)			/* if others do exist, tell them */
+	      printf (MSG_EXIST, system ? MSG_NSYS : MSG_NDIR);
+	}
 }
 
-
 GLOBAL VOID CDECL cmd_echo(s, o)
 REG BYTE	*s;		/* Deblanked Command Line	*/
 REG BYTE	*o;		/* Original Untainted Commmand	*/
@@ -1178,7 +1327,11 @@
 	if(!d_check(path))
 	    return;
 #endif
-	if((ret = ms_x_mkdir(s)) != 0) {	/* if any errors occurred    */
+	ret=ms_l_mkdir(s);
+	if (ret==ED_FUNCTION)
+	  ret=ms_x_mkdir(s);
+/*	if((ret = ms_x_mkdir(s)) != 0) {*/	/* if any errors occurred    */
+	if(ret!=0) {				/* if any errors occurred    */
 	    if (ret == ED_DRIVE)		/* if invalid drive	     */
 		e_check(ret);			/*    then say so	     */
 	    else				/* else use standard formula */
@@ -1371,9 +1524,11 @@
 GLOBAL VOID CDECL cmd_ren(s)
 REG BYTE *s;
 {
-	BYTE	 srcfile[MAX_FILELEN], dstfile[MAX_FILELEN];
+/*	BYTE	 srcfile[MAX_FILELEN], dstfile[MAX_FILELEN];*/
+	BYTE	 srcfile[MAX_LFNLEN], dstfile[MAX_LFNLEN];
 /*	BYTE	 pattern[MAX_FILELEN-MAX_PATHLEN];  */
-	BYTE	 pattern[12];
+/*	BYTE	 pattern[12];*/
+	BYTE	 pattern[MAX_LFNLEN];
 	BYTE	 *enddir;
 #if defined(PASSWORD)
 	BYTE	*password;
@@ -1386,6 +1541,11 @@
 #endif
         char lastchar;
         unsigned length;
+	FINDD	finddata;
+	BOOLEAN	lfnsearch;
+	UWORD	shandle;
+	BOOLEAN	cont;
+	BYTE	t[MAX_LFNLEN];
 
 	if(f_check(s, "c", &flags, NO))		/* Check the selected flags */
 	    return;				/* and return on error	    */
@@ -1418,18 +1578,21 @@
 	    }
 	}
 
-	if (!iswild(srcfile)) {
-	    attr = ms_x_chmod(srcfile,0,0);
-	    if ((attr > 0) && (attr & ATTR_DIR)) {
+/*	if (!iswild(srcfile)) {
+	    attr = ms_l_chmod(srcfile,0,0);
+	    if (attr==ED_FUNCTION)
+	      attr=ms_x_chmod(srcfile,0,0);
+	    if ((attr > 0) && (attr & ATTR_DIR)) {*/
 
 		/* Don't try to rename directories. Leave it to RENDIR. */
 
-		printf(MSG_USE_RENDIR);
+/*		printf(MSG_USE_RENDIR);
 		return;
 	    }
-	}
+	}*/
 
-	if(nofiles(srcfile, ATTR_ALL, YES, NO))	/* if no source files then  */
+	strcpy(t,srcfile);
+	if(nofiles(t, ATTR_ALL, YES, NO))	/* if no source files then  */
 	    return;				/* error message and stop   */
 
 	if(nofiles(dstfile, ATTR_ALL, NO, NO))	/* Check the Destination    */
@@ -1458,39 +1621,72 @@
 	strcpy(pattern, fptr(dstfile)); 	/* Save the destination	    */
 						/* match pattern.	    */
 
-	ms_x_first (srcfile, (ATTR_STD&(~ATTR_SYS)), &search);
+	ret=ms_l_first(srcfile,((ATTR_STD|ATTR_DIR)&(~ATTR_SYS)),&finddata);
+	if (ret!=ED_FUNCTION) {
+	  shandle=finddata.handle;
+	  lfnsearch=1;
+	}
+	else {
+	  ret=ms_x_first(srcfile,((ATTR_STD|ATTR_DIR)&(~ATTR_SYS)),&search);
+	  if (!ret) {
+	    strcpy(finddata.lname,search.fname);
+	  }
+	  lfnsearch=0;
+	}
+/*	ms_x_first (srcfile, (ATTR_STD&(~ATTR_SYS)), &search);*/
 	do {
-	    strcpy(enddir, search.fname);	/* append file name to path */
+	    strcpy(enddir,finddata.lname);	/* append file name to path */
 
+	    cont=0;
 	    if(REN_CHECK) {			/* confirm option active?   */
 		printf(MSG_ERAQ, srcfile);	/* then prompt the user and */
 		if(!yes(YES, NO))		/* act on the reponse	    */
-		    continue;
+/*		    continue;*/
+		  cont=1;
 	    }
 
-	    strcpy(fptr(dstfile), pattern);	/* Assert the Destination   */
-	    repwild(srcfile, dstfile);		/* pattern.		    */
+	    if (!cont) {
+	      strcpy(fptr(dstfile), pattern);	/* Assert the Destination   */
+	      repwild(srcfile, dstfile);	/* pattern.		    */
 
 #if defined(PASSWORD)
-	    if(password)			/* Append the password to   */
+	      if(password)			/* Append the password to   */
 		strcat(srcfile, password);	/* the sorce file if one    */
 						/* has been specified.	    */
 #endif
 
-	    if((ret = ms_x_rename(srcfile, dstfile)) < 0) {
+	      ret=ms_l_rename(srcfile,dstfile);
+	      if (ret==ED_FUNCTION)
+		ret=ms_x_rename(srcfile,dstfile);
+/*	      if((ret = ms_x_rename(srcfile, dstfile)) < 0) {*/
+	      if(ret<0) {
 		crlfflg = YES;
 #if defined(CDOSTMP) || defined(CDOS)
 		if((ret == ED_ACCESS) &&
-		   (ms_x_first(dstfile, ATTR_ALL, &search) >= 0))
+		   ((lfnsearch && (ms_l_first(dstfile,ATTR_ALL,&finddata)>=0)) ||
+		   (!lfnsearch && (ms_x_first(dstfile, ATTR_ALL, &search) >= 0))))  )
 #else
 		if(ret == ED_ACCESS)
 #endif
-		    eprintf(MSG_REN);
+		  eprintf(MSG_REN);
 		else
-		    e_check(ret);
+		  e_check(ret);
+		if (lfnsearch) ms_l_findclose(shandle);
 		return;
+	      }
+	    }
+	    if (lfnsearch) {
+	      ret = ms_l_next(shandle,&finddata);	/* get the next file and    */
+	    }
+	    else {
+	      ret = ms_x_next(&search);		/* get the next file and    */
+	      if (!ret) {
+		strcpy(finddata.lname,search.fname);
+	      }
 	    }
-	} while(!ms_x_next(&search));		/* get the next file */
+/*	} while(!ms_x_next(&search));*/		/* get the next file */
+	} while(!ret);				/* get the next file */
+	if (lfnsearch) ms_l_findclose(shandle);
 }
 
 
@@ -1510,7 +1706,11 @@
 	if(!d_check(path))
 	    return;
 #endif
-	if((ret = ms_x_rmdir(s)) != 0) {	/* if can't remove directory */
+	ret=ms_l_rmdir(s);
+	if (ret==ED_FUNCTION)
+	  ret=ms_x_rmdir(s);
+/*	if((ret = ms_x_rmdir(s)) != 0) {*/	/* if can't remove directory */
+	if(ret!=0) {				/* if can't remove directory */
 	    if(ret == ED_DIR || ret == ED_FILE || ret == ED_ACCESS)
 	    					/* because its in use by     */	
 		eprintf(MSG_RMDIR);		/* by another process or is  */
@@ -1605,6 +1805,7 @@
  *	Displays or Sets the current system time 
  */
 #define	TIME_CON	(flags & 1)
+#define	TIME_SHOW	(flags & 2)
 
 GLOBAL VOID CDECL cmd_time(s)
 REG BYTE *s;
@@ -1612,7 +1813,7 @@
 	BYTE	buffer[18];			/* Local Input Buffer */
 	UWORD	flags;				/* Continuous Display	*/
 
-	if(f_check (s, "c", &flags, NO))	/* Check for valid Flags    */
+	if(f_check (s, "ct", &flags, NO))	/* Check for valid Flags    */
 	    return;
 
 	if(TIME_CON) {
@@ -1634,6 +1835,12 @@
 	    }
 	}
 
+	if(TIME_SHOW) {
+	  printf(CUR_TIME);
+	  disp_systime ();
+	  return;
+	}
+
 	if(*s) {
 	    if (check_time(s))
 		return;
@@ -1668,21 +1875,43 @@
 GLOBAL VOID CDECL cmd_truename(s)
 REG BYTE *s;
 {
-	BYTE	 path[MAX_FILELEN];
+/*	BYTE	 path[MAX_FILELEN];*/
+	BYTE	 path[MAX_LFNLEN];
+	int	 ddrive;
 
 	*path = 0;
 
 	/* expand path, current directory if none specified */
-	if (*s)
-		ret = ms_x_expand(path, s);
-	else
-		ret = ms_x_expand(path, ".");
+	if (*s) {
+		ret = ms_l_expand(path, s);
+		if (ret==ED_FUNCTION)
+		  ret=ms_x_expand(path,s);
+	}
+	else {
+		ret = ms_l_expand(path, ".");
+		if (ret==ED_FUNCTION)
+		  ret=ms_x_expand(path,".");
+	}
 
 	/* if we get an error report it, otherwise display expanded path */
 	if (ret)
-		e_check(ret);
-	else
-		printf(path);
+	  e_check(ret);
+	else {
+	  if (*(s+1)==':') {
+	    if (*s>96)
+	      ddrive=*s-97;
+	    else
+	      ddrive=*s-65;
+	  }
+	  else ddrive=drive;
+	  ret=get_lastdrive();
+	  if (ddrive+1>(ret>>8) || (!(get_driveflags(ddrive)&LFLG_SUBST) && ddrive+1>(ret&0xff))) {
+	    e_check(ED_DRIVE);
+	    return;
+	  }
+	  printf(path);
+	  crlf();
+	}
 }
 
 
@@ -1840,7 +2069,8 @@
 REG BYTE *cmd;
 {
 	WORD 	ret, h;			/* file handle			  */
-	BYTE	path[MAX_FILELEN];	/* Path and File Name		  */
+/*	BYTE	path[MAX_FILELEN];*/	/* Path and File Name		  */
+	BYTE	path[MAX_LFNLEN];	/* Path and File Name		  */
 	BYTE	*files;			/* pointer to file spec 	  */
 #if defined(PASSWORD)
 	BYTE	*password;
@@ -1848,7 +2078,11 @@
 	DTA	search; 		/* Local Search Buffer		  */
 	UWORD	flags;			/* only one switch permitted	  */
 	BOOLEAN wild_flag = FALSE;	/* Wild Card Type		  */
-	BYTE	passbuf[MAX_FILELEN];
+/*	BYTE	passbuf[MAX_FILELEN];*/
+	BYTE	passbuf[MAX_LFNLEN];
+	FINDD	finddata;
+	BOOLEAN	lfnsearch;
+	UWORD	shandle;
 
 	if(f_check(cmd, "p", &flags, NO))       /* if any bad flags */
 	    return;				/*    don't do it */
@@ -1880,18 +2114,31 @@
 	 */
 
 	if (wild_flag) {
-	    search.fattr = ATTR_STD;
-	    ret = ms_x_first(path, ATTR_STD, &search);
-
+	    finddata.fattr = ATTR_STD;
+/*	    ret = ms_x_first(path, ATTR_STD, &search);*/
+	    ret=ms_l_first(path,ATTR_STD,&finddata);
+	    if (ret!=ED_FUNCTION) {
+	      shandle=finddata.handle;
+	      lfnsearch=1;
+	    }
+	    else {
+	      ret=ms_x_first(path,ATTR_STD,&search);
+	      if (!ret) {
+		finddata.fattr=search.fattr;
+		strcpy(finddata.lname,search.fname);
+	      }
+	      lfnsearch=0;
+	    }
 	    if (ret < 0) {
 	    	e_check(ret);		/* if we can't find anything */
+		if (lfnsearch) ms_l_findclose(shandle);
 		return;			/* we'd better say so */
 	    }
 	}
 
 	do {
 	    if (wild_flag)
-		strcpy(files, search.fname);  	/* make it full pathname     */
+		strcpy(files,finddata.lname);  	/* make it full pathname     */
 	    strcpy(heap(), path);
 
 #if defined(PASSWORD)
@@ -1899,12 +2146,17 @@
 	        strcat(heap(), password);
 #endif
 
-	    h = ms_x_open(heap(), OPEN_READ);	/* Open file in sharing mode */
-	    if(h == ED_SHAREFAIL || h == ED_ACCESS)	/* if fails with a   */
-	        h = ms_x_open(heap(), 0);	/* sharing violation then try*/
-						/* opening with compatibilty */
-	    if(h < 0) {				/* mode.		     */
+	    h = ms_l_open(heap(), OPEN_READ);	/* Open file in sharing mode */
+	    if (h==ED_FUNCTION)
+	      h=ms_x_open(heap(),OPEN_READ);
+	    if(h == ED_SHAREFAIL || h == ED_ACCESS) {	/* if fails with a   */
+	        h = ms_l_open(heap(), 0);	/* sharing violation then try*/
+		if (h==ED_FUNCTION)		/* opening with compatibilty */
+		  h=ms_x_open(heap(),0);	/* mode.		     */
+	    }
+	    if(h < 0) {
 		e_check(h);
+		if (lfnsearch) ms_l_findclose(shandle);
 		return;
 	    }
 
@@ -1917,7 +2169,19 @@
 
 	    show_file(h, TYPE_PAGE);	/* Output the File to the Screen */
 	    ms_x_close(h);		/* Close the File */
-	} while (wild_flag && (ms_x_next(&search) >= 0));
+	    if (lfnsearch) {
+	      ret = ms_l_next(shandle,&finddata);
+	    }
+	    else {
+	      ret = ms_x_next(&search);
+	      if (!ret) {
+		finddata.fattr=search.fattr;
+		strcpy(finddata.lname,search.fname);
+	      }
+	    }
+/*	} while (wild_flag && (ms_x_next(&search) >= 0));*/
+	} while (wild_flag && ret>= 0);
+	if (lfnsearch) ms_l_findclose(shandle);
 }
 
 /*
@@ -1972,6 +2236,9 @@
 	else {	
 	    printf(MSG_LBL, ddrive+'A');
 
+	    while (!ret && (search.fattr==ATTR_LFN))
+	      ret = ms_x_next(&search);		/* skip LFN entries */
+
 	    if (ret)
 		printf(MSG_NOLBL);
 	    else {
@@ -2010,7 +2277,8 @@
 BYTE *s;
 BOOLEAN  confirm;
 {
-	BYTE	path[MAX_FILELEN];		/* FileName Buffer	    */
+/*	BYTE	path[MAX_FILELEN];*/		/* FileName Buffer	    */
+	BYTE	path[MAX_LFNLEN];		/* FileName Buffer	    */
 	BYTE	answer[20];			/* Yes/No string	    */
 	BYTE 	*files;				/* pointer to file spec	    */
 #if defined(PASSWORD)
@@ -2020,15 +2288,22 @@
 	DTA	search; 			/* Local Search Buffer	    */
 	UWORD	attr;				/* Erase Search Attributes  */
 #if !STACK
-	BYTE	passbuf[MAX_FILELEN];
+/*	BYTE	passbuf[MAX_FILELEN];*/
+	BYTE	passbuf[MAX_LFNLEN];
 #endif
 #if !(defined (CDOSTMP))
-	BYTE	savepath[MAX_PATHLEN+1];
-	BYTE	newpath[MAX_PATHLEN+2];		/* including trailing \	    */
+/*	BYTE	savepath[MAX_PATHLEN+1];
+	BYTE	newpath[MAX_PATHLEN+2];*/		/* including trailing \	    */
+	BYTE	savepath[MAX_LFNLEN+1];
+	BYTE	newpath[MAX_LFNLEN+2];		/* including trailing \	    */
 	BYTE	fcb[37];
 	WORD	ret;
 	WORD	i;
 #endif
+	FINDD	finddata;
+	BOOLEAN	lfnsearch;
+	UWORD	shandle;
+	BOOLEAN	cont;
 
 	if(f_check(s, "cps", &flags, NO))     	/* if any bad flags return  */
 	    return;
@@ -2089,6 +2364,10 @@
 	    }
 	}
 
+	if (!confirm)			/* Try LFN API first */
+	  if (!(ret=ms_l_unlink(path,attr)))
+	    return;			/* Seems to have succeeded... */
+
 	if(!confirm && ERASE_SYS &&	/* If no confirmation is required */
 #if !(defined (CDOSTMP))
 	   !iswild(path) &&		/* and this is an ambigous file   */
@@ -2119,7 +2398,9 @@
 
 	    strcpy (savepath, "d:\\");	/* get curpath on relevant drive  */
 	    *savepath = ddrive + 'A';
-	    ms_x_curdir (ddrive+1, savepath+3);
+	    ret=ms_l_curdir (ddrive+1, savepath+3);
+	    if (ret==ED_FUNCTION)
+	      ms_x_curdir(ddrive+1,savepath+3);
 	    
 	    strncpy (newpath, path, files - path);
 	    				/* extract new path		*/
@@ -2128,12 +2409,18 @@
 	    if ((i = strlen (newpath)) > (newpath[1] == ':' ? 3 : 1))
 	        newpath[--i] = '\0';	/* remove trailing backslash	*/
 	
-	    if (! ((i == 0) || ((i == 2) && (newpath[1] == ':'))) )
-	        if (ms_x_chdir (newpath))
+	    if (! ((i == 0) || ((i == 2) && (newpath[1] == ':'))) ) {
+		ret=ms_l_chdir(newpath);
+		if (ret==ED_FUNCTION)
+		  ret=ms_x_chdir(newpath);
+/*	        if (ms_x_chdir (newpath))*/
+	        if (ret)
 		    goto fcbdel_end;
+	    }
 	
 	    ret = ms_f_delete (fcb);
-	    ms_x_chdir (savepath);
+	    if (ms_l_chdir(savepath)==ED_FUNCTION)
+	      ms_x_chdir (savepath);
 	    
 	    if (!ret)
 	        return;			/* all done			  */
@@ -2142,27 +2429,60 @@
 	}
 #endif
 	    
-	if (ms_x_first(path, attr, &search)) return;
+	ret=ms_l_first(path,attr,&finddata);
+	if (ret!=ED_FUNCTION) {
+	  shandle=finddata.handle;
+	  lfnsearch=1;
+	}
+	else {
+	  ret=ms_x_first(path,attr,&search);
+	  if (!ret) {
+	    strcpy(finddata.lname,search.fname);
+	  }
+	  lfnsearch=0;
+	}
+/*	if (ms_x_first(path, attr, &search)) return;*/
+	if (ret) {
+	  if (lfnsearch) ms_l_findclose(shandle);
+	  return;
+	}
 	do {
-	    strcpy(files, search.fname);	/* make it full file name */
+	    strcpy(files, finddata.lname);	/* make it full file name */
 	    strcpy(heap(), path);		/* copy to an internal    */
 #if defined(PASSWORD)
 	    if(password)			/* buffer and append the  */
 		strcat(heap(), password);	/* password if present	  */
 #endif
 
+	    cont=0;
 	    if(confirm) {
-		printf(MSG_ERAQ, path);
-		if(!yes(YES, NO))
-		    continue;
-	    }
-
-	    if((ret = ms_x_unlink(heap())) != 0) {
+	      printf(MSG_ERAQ, path);
+	      if(!yes(YES, NO))
+		cont=1;
+	    }
+	    if (!cont) {
+	      ret=ms_l_unlink(heap(),attr);
+	      if (ret==ED_FUNCTION)
+		ret=ms_x_unlink(heap());
+/*	      if((ret = ms_x_unlink(heap())) != 0) {*/
+	      if (ret) {
 		printf(MSG_ERA, path);
 		e_check(ret);
 		crlf();
+	      }
+	    }
+	    if (lfnsearch) {
+	      ret = ms_l_next(shandle,&finddata);	/* get the next file and    */
+	    }
+	    else {
+	      ret = ms_x_next(&search);	/* get the next file and    */
+	      if (!ret) {
+		strcpy(finddata.lname,search.fname);
+	      }
 	    }
-	} while (!ms_x_next (&search));
+/*	} while (!ms_x_next (&search));*/
+	} while (!ret);
+	if (lfnsearch) ms_l_findclose(shandle);
 }
 
 #if defined(DOSPLUS)
@@ -2236,4 +2556,61 @@
 
 #endif
 
+GLOBAL VOID CDECL cmd_colour(s)
+BYTE	*s;
+{
+	COLDATA	colset;
+	WORD	fg,bg;
+	BOOLEAN	error=NO;
+
+	get_colour(&colset);
+	fg=colset.fgbg&15;
+	bg=colset.fgbg>>4;
 
+	s=deblank(s);
+
+	if (*s) {
+	
+	  switch(onoff(s)) {
+	    case	YES:
+	      colset.flags=1;
+	      s+=2;
+	      break;
+	    case	NO:
+	      colset.flags=2;
+	      fg=7;
+	      bg=0;
+	      colset.border=0;
+	      s+=3;
+	      break;
+	    default:
+	      if(*s) {
+	        if (isdigit(*s)) getdigit(&fg,&s);
+	        if (*s && !strchr(",",*s++)) error=TRUE;
+	        if (isdigit(*s)) getdigit(&bg,&s);
+	        if (*s && !strchr(",",*s++)) error=TRUE;
+	        if (isdigit(*s)) getdigit(&colset.border,&s);
+	        s=deblank(s);
+	        if (*s||fg>15||bg>15||colset.border>63) error=TRUE;
+	        if (!error) {
+		  colset.flags=1;
+	        }
+	      }
+	  }
+
+	  s=deblank(s);
+	  if (*s) error=TRUE;
+
+	  if (error) {
+	    printf("Invalid format!\n");
+	    return;
+	  }
+	  else {
+	    colset.fgbg=bg*16+fg;
+	    set_colour(&colset);
+	  }
+
+	}
+	else
+	  printf(MSG_COLOUR,colset.flags ? MSG_ON : MSG_OFF,fg,bg,colset.border);
+}
diff -u -P -r dr70107/command/command.h d110721/command/command.h
--- dr70107/command/command.h	2003-09-25 01:26:38.000000000 +0000
+++ d110721/command/command.h	2008-02-17 16:39:40.000000000 +0000
@@ -52,7 +52,9 @@
 #define MAX_PATHLEN	131	/* Maximum length of a Path "x:\...."	     */
 #define MAX_FILELEN	140	/* Maximum length of full file specification */
 				/* ie "x:\....\nnnnnnnn.eee;password"	     */
+#define MAX_LFNLEN	261	/* Maximum length of Long Filename	     */
 #define	MAX_ENVLEN	255	/* Maximum length of environment entry       */
+#define	MAX_LINE	255	/* Maximum length of command line            */
 
 #define DEFAULT_PROMPT	"$n$g"		/* Default Prompt string */
 
@@ -196,6 +198,7 @@
 #define 	ATTR_LBL	0x0008	/* find labels		 	*/
 #define 	ATTR_DIR	0x0010	/* find directories, too	*/
 #define		ATTR_DEV	0x0040	/* Attribute returned for Device*/
+#define		ATTR_LFN	0x000f	/* combination for LFN entries	*/
 
 #define STDIN		0	/* Standard Console Input Handle	*/
 #define STDOUT		1	/* Standard Console Output Handle	*/ 
@@ -219,6 +222,8 @@
 #define OPEN_WRITE	(OPEN_WO | OPEN_DRW)	/* Open Write Only	*/
 #define	OPEN_RDWR	(OPEN_RW | OPEN_DRW)	/* Open Read and Write	*/
 
+#define	LFLG_SUBST	0x1000		/* Drive is SUBSTituted		*/
+
 /*
  *	Set STACK to 1 to use dynamic string storage fuunction STACK
  *	which will reserve a any number of bytes on the stack for
diff -u -P -r dr70107/command/cstart.asm d110721/command/cstart.asm
--- dr70107/command/cstart.asm	2004-09-23 17:26:56.000000000 +0000
+++ d110721/command/cstart.asm	2008-11-17 08:11:14.000000000 +0000
@@ -250,7 +250,7 @@
 else					;  extra to save ENV in
 ;C_HEAP_SIZE	equ	0800h		; C routine Heap Size
 ;endif					; (observed sizes 500h-600h - IJ)
-C_HEAP_SIZE	equ	0860h		; C routine Heap Size
+C_HEAP_SIZE	equ	0CC0h		; C routine Heap Size
 ; For safety increased that value as UNC filenames require 128 byte buffers
 ; allocated dynamically on tha stack. With respect to the observed sizes
 ; above it might be dangerous to leave that value at 0800h. I would have
@@ -1667,7 +1667,7 @@
 	mov	es,ax			; on old 8088 or 8086 so interrupts
 	mov	ss,ax			; must be disabled
 	mov	sp,stack_min		; Get the lowest possible stack address
-	add	sp,12			; Add a little to avoid problems with
+	add	sp,16			; Add a little to avoid problems with
 	sti				; the stack check code.
 
 	mov	ax,0100h		; Termination Code Control-C Abort
@@ -3082,7 +3082,36 @@
 	and	al,7fh
 	mov	ah, 0			; set mode, clear screen (al bit 7 clear)
 	int	10h
-	
+
+	push	es
+	mov	ah,52h			; get List of Lists address
+	int	21h
+	les	bx,F52_CONDEV		; address of console device driver
+	mov	ax,es:24[bx]		; COLOUR command active?
+	cmp	al,01
+	 jne	int10_cls10		; no, then skip
+	push	ax
+	mov	bh,es:26[bx]		; colour of the border
+	mov	ax,1001h		; set border colour
+	int	10h
+	pop	ax
+	mov	dx,40h			; BIOS data segment
+	mov	es,dx
+	xor	bx,bx
+	xor	cx,cx
+	push	bp
+	mov	bp,sp
+	mov	dh,4[bp]
+	pop	bp
+;	mov	dh,byte ptr es:84h[bx]
+	mov	dl,byte ptr es:4ah[bx]
+	dec	dl
+	mov	bh,ah			; character colour
+	mov	ax,600h
+	int	10h
+
+int10_cls10:
+	pop	es
 	call	cginfo			; has resolution changed?
 	pop	ax			; restore screen lines
 
diff -u -P -r dr70107/command/csup.asm d110721/command/csup.asm
--- dr70107/command/csup.asm	2004-08-17 12:02:10.000000000 +0000
+++ d110721/command/csup.asm	2008-07-03 13:04:38.000000000 +0000
@@ -53,7 +53,7 @@
 
 codeOFFSET	equ	offset CGROUP:
 dataOFFSET	equ	offset DGROUP:
-STACKSLOP	equ	128		; Minimum Stack Size
+STACKSLOP	equ	256		; Minimum Stack Size
 
 jmps	macro	label			; Define a Macro to generate the
 	jmp	SHORT label		; Short Jmp instruction
@@ -343,6 +343,30 @@
 	ret
 get_key	ENDP
 
+	Public	_get_cmdname
+_get_cmdname:
+	cld
+	push	bp
+	mov	bp,sp
+	push	ds
+	push	si
+	push	es
+	push	di
+	mov	es,__psp2
+	mov	es,es:16h
+	push	ds
+	push	es
+	pop	ds
+	pop	es
+	mov	si,62h
+	mov	di,4[bp]
+get_cmdname10:
+	lodsb
+	stosb
+	or	al,al
+	 jnz	get_cmdname10
+	jmp	env_exit
+	
 	page
 	assume	cs:CGROUP, ds:DGROUP, es:nothing
 ifdef MSC
@@ -415,7 +439,7 @@
 	push	bp
 	mov	bp,sp
 	mov	ax,heap_top
-        add     ax,STACKSLOP
+;        add     ax,STACKSLOP
 	sub	bp,ax		
         jnc     noprobs
         xor     bp,bp
@@ -434,14 +458,14 @@
 PUBLIC	_heap
 _heap:
 	mov	ax,heap_top
-ifndef FINAL
+;ifndef FINAL
 ifdef WATCOMC
 	add	ax,STACKSLOP	; we'd better do some stack checking
 	cmp	ax,sp		; 'cause the C isn't doing it now
 	 jae	heap_error
 	sub	ax,STACKSLOP
 endif
-endif
+;endif
 	ret
 	
 ;
diff -u -P -r dr70107/command/dos7.h d110721/command/dos7.h
--- dr70107/command/dos7.h	2004-01-31 00:38:56.000000000 +0000
+++ d110721/command/dos7.h	2008-02-08 18:35:22.000000000 +0000
@@ -3,7 +3,7 @@
 ;
 ; This file is part of
 ; The DR-DOS/OpenDOS Enhancement Project - http://www.drdosprojects.de
-; Copyright (c) 2002-2004 Udo Kuhnt
+; Copyright (c) 2002-2008 Udo Kuhnt
 */
 
 typedef struct {
@@ -19,3 +19,20 @@
 	ULONG	npclus;		// number of physical allocation units
 /*reserved	equ	24h	; reserved bytes*/
 } FREED;
+
+typedef struct {
+	ULONG	fattr;		// file attributes
+	ULONG	ctime;
+	ULONG	ctimeh;
+	ULONG	atime;
+	ULONG	atimeh;
+	UWORD	ftime;		// file time
+	UWORD	fdate;		// file date
+	ULONG	ftimeh;
+	ULONG	fsizeh;		// file size high DWORD
+	ULONG	fsize;		// file size low DWORD
+	UWORD	handle;		// search handle
+	BYTE	resvd[6];
+	BYTE	lname[260];	// long file name
+	BYTE	sname[14];	// short file name
+} FINDD;
diff -u -P -r dr70107/command/doshndl.def d110721/command/doshndl.def
--- dr70107/command/doshndl.def	1970-01-01 00:00:00.000000000 +0000
+++ d110721/command/doshndl.def	2005-12-25 13:28:02.000000000 +0000
@@ -0,0 +1,146 @@
+;    File              : $DOSHNDL.DEF$
+;
+;    Description       :
+;
+;    Original Author   : DIGITAL RESEARCH
+;
+;    Last Edited By    : $CALDERA$
+;
+;-----------------------------------------------------------------------;
+;    Copyright Work of Caldera, Inc. All Rights Reserved.
+;      
+;    THIS WORK IS A COPYRIGHT WORK AND CONTAINS CONFIDENTIAL,
+;    PROPRIETARY AND TRADE SECRET INFORMATION OF CALDERA, INC.
+;    ACCESS TO THIS WORK IS RESTRICTED TO (I) CALDERA, INC. EMPLOYEES
+;    WHO HAVE A NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF
+;    THEIR ASSIGNMENTS AND (II) ENTITIES OTHER THAN CALDERA, INC. WHO
+;    HAVE ACCEPTED THE CALDERA OPENDOS SOURCE LICENSE OR OTHER CALDERA LICENSE
+;    AGREEMENTS. EXCEPT UNDER THE EXPRESS TERMS OF THE CALDERA LICENSE
+;    AGREEMENT NO PART OF THIS WORK MAY BE USED, PRACTICED, PERFORMED,
+;    COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED, ABRIDGED,
+;    CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;    TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF
+;    CALDERA, INC. ANY USE OR EXPLOITATION OF THIS WORK WITHOUT
+;    AUTHORIZATION COULD SUBJECT THE PERPETRATOR TO CRIMINAL AND
+;    CIVIL LIABILITY.
+;-----------------------------------------------------------------------;
+;
+;    *** Current Edit History ***
+;    *** End of Current Edit History ***
+;
+;    $Log$
+;
+;    ENDLOG
+
+DCNTRL_DSADD    equ dword ptr 0000h  
+DCNTRL_DSOFF    equ  word ptr 0000h  
+DCNTRL_DSSEG    equ  word ptr 0002h  
+DCNTRL_COUNT    equ  word ptr 0004h  
+DCNTRL_LEN	equ	6
+
+DHNDL_COUNT	equ	word ptr 00h		; 00 - Usage Count
+DHNDL_MODE	equ	word ptr 02h		; 02 - File Mode
+
+DHM_FCB		equ	8000h			; marks as FCB
+DHM_COMMIT	equ	4000h			; auto-commit file
+DHM_NOCRIT	equ	2000h			; no critical errors
+DHM_LOCAL	equ	10000000b		; file is not inherited
+DHM_SHAREMSK	equ	01110000b		; sharing bits
+DHM_COMPAT	equ	00000000b
+DHM_DENY_ALL	equ	00010000b		; exclusive - deny all
+DHM_DENY_WRITE	equ	00100000b
+DHM_DENY_READ	equ	00110000b
+DHM_DENY_NONE	equ	01000000b
+DHM_RWMSK	equ	00001111b		; read write bits
+DHM_RW		equ	00000010b		; file opened read/write
+DHM_WO		equ	00000001b		; file opened write only
+DHM_RO		equ	00000000b		; file opened read only
+
+;
+;	01h to 03h To be Determined
+;
+DHNDL_DATRB	equ	byte ptr 04h		; Disk attribute byte
+DHNDL_ATTR	equ	byte ptr 05h		; Attribute Byte
+DHNDL_WATTR	equ	word ptr 05h		; Attribute Word
+
+DHAT_REMOTE	equ	8000h			; set if file remote
+DHAT_TIMEOK	equ	4000h			; set if timestamp up to date
+DHAT_LOCAL	equ	1000h			; file is not inherited
+DHAT_NETPRN	equ	0800h			; device is networked printer
+DHAT_DEV	equ	0080h			; device/file bit
+DHAT_READY	equ	0040h			; ready/not ready bit
+DHAT_CLEAN	equ	0040h			; this bit CLEAR if dirty
+DHAT_BIN	equ	0020h			; raw/cooked bit
+DHAT_DRVMSK	equ	001Fh			; drive in bottom bits
+DHAT_CLK	equ	0008h			; -reserved-
+DHAT_NUL	equ	0004h			; handle is null device
+DHAT_COT	equ	0002h			; handle is console output device
+DHAT_CIN	equ	0001h			; handle is console input device
+
+DHNDL_DEVPTR	equ	dword ptr 07h		; 07 - pointer to device
+DHNDL_DEVOFF	equ	word ptr 07h		; 07 - offset of device
+DHNDL_DEVSEG	equ	word ptr 09h		; 09 - segment of device
+DHNDL_BLK1	equ	word ptr 0Bh		; 0B - first cluster in file
+						;      (lower 32 bits)
+DHNDL_TIME	equ	word ptr 0Dh		; 0D - file time stamp
+DHNDL_DATE	equ	word ptr 0Fh		; 0F - file date stamp
+DHNDL_SIZE	equ	dword ptr 11h		; 11 - file length
+						;      (lower 32 bits)
+DHNDL_SIZELO	equ	word ptr 11h
+DHNDL_SIZEHI	equ	word ptr 13h
+DHNDL_POS	equ	dword ptr 15h		; 15 - current file position
+						;      (lower 32 bits)
+DHNDL_POSLO	equ	word ptr 15h
+DHNDL_POSHI	equ	word ptr 17h
+DHNDL_IDX	equ	word ptr 19h		; 19 - relative cluster within file of last read
+						;      (lower 32 bits)
+DHNDL_DBLK	equ	word ptr 1Bh		; 1B - cluster # of dir entry
+						;      (lower 32 bits)
+DHNDL_DCNTHI	equ	byte ptr 1Eh		; 1E - dir offset # within cluster
+DHNDL_DCNTLO	equ	byte ptr 1Fh		; 1F - dir offset # within cluster
+DHNDL_NAME	equ	byte ptr 20h		; 20 - File/Device Name
+DHNDL_EXT	equ	byte ptr 28h		; 28 - File extension
+DHNDL_SFT	equ	dword ptr 2Bh		; 2B - pointer to previous SFT
+DHNDL_UID	equ	word ptr 2Fh		; 2F - Owning Machine ID
+DHNDL_PSP	equ	word ptr 31h		; 31 - Owning PSP
+DHNDL_SHARE	equ	word ptr 33h		; 33 - Offset of sharing record
+DHNDL_BLK	equ	word ptr 35h		; 35 - absolute cluster of last read
+						;      (lower 32 bits)
+						; 37 - dword reserved for IFS
+DHNDL_BLK1H	equ	word ptr 3Bh		; 3B - first cluster in file
+						;      (higher 32 bits)
+DHNDL_IDXH	equ	word ptr 3Dh		; 3D - relative cluster within file of last read
+						;      (higher 32 bits)
+DHNDL_DBLKH	equ	word ptr 3Fh		; 3F - cluster # of dir entry
+						;      (higher 32 bits)
+DHNDL_BLKH	equ	word ptr 41h		; 41 - absolute cluster of last read
+						;      (higher 32 bits)
+DHNDL_SIZEX	equ	dword ptr 43h		; 43 - file length
+						;      (higher 32 bits)
+DHNDL_SIZEXLO	equ	word ptr 43h
+DHNDL_SIZEXHI	equ	word ptr 45h
+DHNDL_POSX	equ	dword ptr 47h		; 47 - current file position
+						;      (higher 32 bits)
+DHNDL_POSXLO	equ	word ptr 47h
+DHNDL_POSXHI	equ	word ptr 49h
+DHNDL_LEN	equ	4Bh
+
+; With DOS 3 structures _DBLK is a 16 bit
+
+
+; Logical Drive Table format
+LDT_NAME	equ	byte ptr 00h		; 00 - Ascii Name field
+LDT_FLAGS	equ	word ptr 43h		; 43 - Flag field
+LDT_PDT		equ	dword ptr 45h		; 45 - PDT for this drive
+LDT_BLK		equ	word ptr 49h		; 49 - directory sector 
+LDT_ROOT	equ	word ptr 4bh		; 4B - virtual block root
+LDT_DRV		equ	byte ptr 4dh		; 4D - physical drive 
+LDT_ROOTLEN	equ	word ptr 4fh		; 4F - Length of root portion
+LDT_BLKH	equ	word ptr 51h
+LDT_ROOTH	equ	word ptr 53h
+LDT_LEN		equ	58h
+
+LFLG_NETWRKD	equ	8000h
+LFLG_PHYSICAL	equ	4000h
+LFLG_JOINED	equ	2000h
+LFLG_SUBST	equ	1000h
diff -u -P -r dr70107/command/dosif.asm d110721/command/dosif.asm
--- dr70107/command/dosif.asm	2004-02-01 19:47:06.000000000 +0000
+++ d110721/command/dosif.asm	2008-11-17 10:41:00.000000000 +0000
@@ -142,6 +142,7 @@
 else
 include	f52data.def
 endif
+include doshndl.def
 ;
 ifdef	CDOSTMP
 OK_RIF		equ	00111000b	; All Responsese are Valid
@@ -363,36 +364,17 @@
 
 	push	bp
 	mov	bp,sp
-	push	ds
 	push	es
-	push	dx
 	push	di
-	push	bx
-	mov	di,6[bp]		; ES:DI pointer to buffer
-	push	ds
+	mov	dx,4[bp]		; DS:DX pointer to drive path
+	push	ds			; ES:DI pointer to buffer
 	pop	es
-	mov	bx,8[bp]		; CX length of buffer
-	mov	cx,[bx]
-	mov	bx,4[bp]		; DS:DX pointer to drive path
-	mov	dx,[bx]
-	mov	ax,2[bx]
-	mov	ds,ax
+	mov	di,6[bp]
+	mov	cx,8[bp]		; CX length of buffer
 	mov	ax,MS_EDRV_SPACE
-	int	DOS_INT
-	 jc	_ms_edrv_space20	; error?
-	cmp	ax,7300h		; function not implemented?
-	 jne	_ms_edrv_space10
-	mov	al,0ffh			; generic error code
-	stc
-	jmp	_ms_edrv_space20
-_ms_edrv_space10:
-	xor	ax,ax
-_ms_edrv_space20:
-	pop	bx
+	call	call73
 	pop	di
-	pop	dx
 	pop	es
-	pop	ds
 	pop	bp
 	ret
 
@@ -417,6 +399,17 @@
 	mov	ah,MS_X_MKDIR
 	jmp	ms_dx_call
 
+	Public _ms_l_mkdir
+;----------
+_ms_l_mkdir:
+;----------
+	push	bp
+	mov	bp,sp
+	mov	dx,4[bp]		; DS:DX directory name
+	mov	ax,MS_L_MKDIR
+	call	call71
+	pop	bp
+	ret
 
 	Public	_ms_x_rmdir
 ;----------
@@ -425,6 +418,17 @@
 	mov	ah,MS_X_RMDIR
 	jmp	ms_dx_call
 
+	Public	_ms_l_rmdir
+;----------
+_ms_l_rmdir:
+;----------
+	push	bp
+	mov	bp,sp
+	mov	dx,4[bp]		; DS:DX directory name
+	mov	ax,MS_L_RMDIR
+	call	call71
+	pop	bp
+	ret
 
 	Public	_ms_x_chdir
 ;----------
@@ -433,6 +437,18 @@
 	mov	ah,MS_X_CHDIR
 	jmp	ms_dx_call
 
+	Public	_ms_l_chdir
+;----------
+_ms_l_chdir:
+;----------
+	push	bp
+	mov	bp,sp
+	mov	dx,4[bp]		; DS:DX directory name
+	mov	ax,MS_L_CHDIR
+	call	call71
+	pop	bp
+	ret
+
 	Public	_ms_x_creat
 ;----------
 _ms_x_creat:
@@ -459,6 +475,39 @@
 	pop	bp
 	ret
 
+	Public	_ms_l_creat
+;---------
+_ms_l_creat:
+;---------
+	push	bp
+	mov	bp,sp
+	push	si
+	mov	cx,6[bp]		; create attributes
+	mov	bx,OPEN_RW		; create mode
+	mov	dx,18			; create or truncate if exists
+	jmp	ms_l_creat_entry
+
+	Public	_ms_l_open
+;---------
+_ms_l_open:
+;---------
+	push	bp
+	mov	bp,sp
+	push	si
+	mov	bx,6[bp]		; open mode
+	mov	dx,1			; open if exists
+ms_l_creat_entry:
+	mov	si,4[bp]		; DX:SI filename
+	mov	ax,MS_L_OPEN
+	stc
+	int	DOS_INT
+	 jnc	ms_l_open10
+	call	call71_alt_entry
+ms_l_open10:
+	pop	si
+	pop	bp
+	ret
+
 	Public _ms_x_close
 ;----------
 _ms_x_close:
@@ -548,6 +597,21 @@
 	mov	ah,MS_X_UNLINK
 	jmp	ms_dx_call
 
+	Public	_ms_l_unlink
+;-----------
+_ms_l_unlink:
+;-----------
+	push	bp
+	mov	bp,sp
+	push	si
+	mov	dx,4[bp]		; DS:DX -> filename
+	mov	cx,6[bp]		; search attributes
+	mov	si,1			; wildcards enabled
+	mov	ax,MS_L_UNLINK
+	call	call71
+	pop	si
+	pop	bp
+	ret
 
 	Public	_ms_x_lseek
 ;----------
@@ -626,6 +690,28 @@
 	pop	bp
 	ret
 
+	Public	_ms_l_chmod
+;----------
+_ms_l_chmod:
+;----------
+	push	bp
+	mov	bp,sp
+	mov	dx,4[bp]		; DS:DX filename
+	mov	cx,6[bp]		; file attributes
+	mov	bl,8[bp]		; get/set attributes
+	mov	ax,MS_L_CHMOD
+	stc
+	int	DOS_INT
+	 jnc	ms_l_chmod10
+	call	call71_alt_entry
+	jmp	ms_l_chmod20
+ms_l_chmod10:
+	cmp	byte ptr 8[bp],0	; get attributes?
+	 jne	ms_l_chmod20
+	mov	ax,cx			; return attributes
+ms_l_chmod20:
+	pop	bp
+	ret
 
 	Public	_ms_x_curdir
 ;-----------
@@ -644,6 +730,21 @@
 	pop	bp
 	ret
 
+	Public	_ms_l_curdir
+;-----------
+_ms_l_curdir:
+;-----------
+	push	bp
+	mov	bp,sp
+	push	si
+	mov	dl,4[bp]		; DL drive number (0 = current drive)
+	mov	si,6[bp]		; DS:SI path buffer
+	mov	ax,MS_L_CURDIR
+	call	call71
+	pop	si
+	pop	bp
+	ret
+
 	Public _ms_x_exit
 ;---------
 _ms_x_exit:
@@ -786,6 +887,26 @@
 	pop	bp
 	CRET	4
 
+	Public	_ms_l_expand
+_ms_l_expand:
+	push	bp
+	mov	bp,sp
+	push	es
+	push	di
+	push	si
+	push	ds
+	pop	es
+	mov	si,6[bp]		; DS:SI source string
+	mov	di,4[bp]		; ES:DI destination buffer
+	xor	cx,cx			; sub function 0, no subst expansion
+	mov	ax,MS_L_EXPAND
+	call	call71
+	pop	si
+	pop	di
+	pop	es
+	pop	bp
+	ret
+
 	Public	_ms_x_wait
 ;---------
 _ms_x_wait:		; retrieve child return code
@@ -820,6 +941,64 @@
 	mov	ah,MS_X_NEXT		; get the function
 	jmp	ms_call_dos		; get DX, call DOS, handle errors
 
+	Public	_ms_l_first
+;----------
+_ms_l_first:
+;----------
+	push	bp
+	mov	bp,sp
+	push	es
+	push	di
+	push	si
+	push	ds
+	pop	es
+	mov	dx,4[bp]		; get ASCII string
+	mov	cx,6[bp]		; get attribute
+	mov	si,1			; request DOS date/time format
+	mov	di,8[bp]		; get buffer address
+	mov	ax,MS_L_FIRST		; LFN FindFirst
+	stc
+	int	DOS_INT
+	mov	es:24h[di],ax		; save search handle
+	call	call71_alt_entry
+	pop	si
+	pop	di
+	pop	es
+	pop	bp
+	ret
+
+	Public	_ms_l_next
+;----------
+_ms_l_next:
+;----------
+	push	bp
+	mov	bp,sp
+	push	es
+	push	di
+	push	si
+	push	ds
+	pop	es
+	mov	bx,4[bp]		; get search handle
+	mov	si,1			; request DOS date/time format
+	mov	di,6[bp]		; get buffer address
+	mov	ax,MS_L_NEXT		; LFN FindNext
+	call	call71
+	pop	si
+	pop	di
+	pop	es
+	pop	bp
+	ret
+
+	Public	_ms_l_findclose
+;----------
+_ms_l_findclose:
+;----------
+	push	bp
+	mov	bp,sp
+	mov	bx,4[bp]		; get search handle
+	mov	ax,MS_L_FINDCLOSE	; LFN FindClose
+	jmp	ms_call_dos
+
 ms_dx_call:				; call DOS with parameter in DX
 	push	bp
 	mov	bp,sp
@@ -854,6 +1033,50 @@
 	pop	bp
 	ret
 
+	Public	_ms_l_rename
+;-----------
+_ms_l_rename:
+;-----------
+	push	bp
+	mov	bp,sp
+	push	es
+	push	di
+	push	ds
+	pop	es
+	mov	dx,4[bp]		; DS:DX old filename
+	mov	di,6[bp]		; ES:DI new filename
+	mov	ax,MS_L_RENAME
+	call	call71
+	pop	di
+	pop	es
+	pop	bp
+	ret
+
+call71:
+	stc				; just in case it is not implemented
+	int	DOS_INT
+call71_alt_entry:
+	 jnc	call71_20
+	cmp	ax,7100h		; function implemented?
+call73_entry:
+	 jne	call71_10
+	mov	ax,0ffffh		; error code -1 - invalid function
+	jmp	call71_30
+call71_10:
+	neg	ax
+	jmp	call71_30
+call71_20:
+	sub	ax,ax			; no error
+call71_30:
+	ret
+
+call73:
+	stc				; just in case it is not implemented
+	int	DOS_INT
+	 jnc	call71_20
+	cmp	ax,7300h		; function implemented?
+	jmp	call73_entry
+
 	Public	_ms_x_datetime
 ;	ret = _ms_x_datetime (gsflag, h, &time, &date);
 ;-------------
@@ -996,6 +1219,79 @@
 	xchg	ax,bx
 	ret
 endif
+
+	Public	_get_lastdrive
+;-----------
+_get_lastdrive:
+;-----------
+	push	es
+	mov	ah,52h			; get List of Lists
+	int	DOS_INT
+	mov	ax,es:20h[bx]		; number of drives
+;	xor	ah,ah
+	pop	es
+	ret
+
+	Public	_get_driveflags
+;-----------
+_get_driveflags:
+;-----------
+	push	bp
+	mov	bp,sp
+	push	es
+	mov	ah,52h			; get List of Lists
+	int	DOS_INT
+	les	bx,es:16h[bx]		; ES:BX -> Path Control Table
+	mov	ax,LDT_LEN		; length of table entry
+	mul	word ptr 4[bp]		; drive number (A=0)
+	add	bx,ax			; offset in LDT
+	mov	ax,es:LDT_FLAGS[bx]
+	pop	es
+	pop	bp
+	ret
+
+	Public	_conv64
+;-----------
+_conv64:
+;-----------
+	push	bp
+	mov	bp,sp
+	push	si
+	push	di
+	mov	si,4[bp]
+	mov	di,6[bp]
+	xor	dx,dx
+conv64_10:
+	cmp	word ptr [di],0		; greater than 2^32-1?
+	 jne	conv64_20
+	cmp	word ptr 2[di],0
+	 je	conv64_40
+conv64_20:
+	mov	ax,1[si]		; /256
+	mov	[si],ax
+	mov	al,3[si]
+	mov	ah,[di]
+	mov	2[si],ax
+	mov	ax,1[di]
+	mov	[di],ax
+	mov	al,3[di]
+	xor	ah,ah
+	mov	2[di],ax
+	mov	cx,2
+conv64_30:
+	shr	byte ptr 2[di],1	; /4
+	rcr	word ptr [di],1
+	rcr	word ptr 2[si],1
+	rcr	word ptr [si],1
+	loop	conv64_30
+	inc	dx
+conv64_40:
+	xchg	ax,dx
+	pop	di
+	pop	si
+	pop	bp
+	ret
+
 	Public	_ms_f_verify
 ;-----------
 _ms_f_verify:
@@ -2949,5 +3245,145 @@
 
 _nov_connection	ENDP
 
+	Public	_get_colour
+;-----------
+_get_colour:
+;-----------
+	push	bp
+	mov	bp,sp
+	push	es
+	mov	ah,52h			; get List of Lists
+	int	DOS_INT
+	les	bx,F52_CONDEV		; get console driver address
+get_colour10:
+	xor	cx,cx
+	dec	cx			; CX=FFFFh
+	mov	ax,es
+	cmp	ax,cx			; check if CON driver address valid
+	 jne	get_colour20
+	cmp	bx,cx
+	 jne	get_colour20
+	xor	ax,ax			; FFFF:FFFFh means end of chain
+	xor	dx,dx
+	jmp	get_colour40
+get_colour20:
+	call	check_colour		; test for CON with COLOUR support
+	 je	get_colour30
+	les	bx,es:[bx]		; go to next driver in chain
+	jmp	get_colour10
+get_colour30:
+	mov	ax,es:24[bx]		; get current COLOUR parameters
+	mov	dl,es:26[bx]
+get_colour40:
+	mov	bx,4[bp]		; and store them in variables
+	mov	ds:[bx],ax
+	mov	ds:2[bx],dl
+	pop	es
+	pop	bp
+	ret
+
+	Public	_set_colour
+;-----------
+_set_colour:
+;-----------
+	push	bp
+	mov	bp,sp
+	push	es
+	mov	ah,52h			; get List of Lists
+	int	DOS_INT
+	les	bx,F52_CONDEV		; get console driver address
+set_colour10:
+	xor	cx,cx
+	dec	cx			; CX=FFFFh
+	mov	ax,es
+	cmp	ax,cx			; check if CON driver address valid
+	 jne	set_colour20
+	cmp	bx,cx
+	 je	set_colour40		; FFFF:FFFFh means end of chain
+set_colour20:
+	call	check_colour		; test for CON with COLOUR support
+	 je	set_colour30
+	les	bx,es:[bx]		; go to next driver in chain
+	jmp	set_colour10
+set_colour30:
+	push	bx
+	mov	bx,4[bp]		; get new parameters
+	mov	ax,ds:[bx]
+	mov	dl,ds:2[bx]
+	pop	bx
+	mov	dh,al
+	and	al,1
+	mov	es:24[bx],al		; and update COLOUR with these
+	test	dh,2
+	 jnz	set_colour35
+	mov	es:25[bx],ah
+	mov	es:26[bx],dl
+set_colour35:
+	push	ax
+	mov	bh,dl
+	mov	ax,1001h		; set new border colour
+	int	10h
+	pop	bx
+	xchg	bh,bl
+	call	col_screen		; update screen colours
+set_colour40:
+	pop	es
+	pop	bp
+	ret
+
+check_colour:
+	push	ds			; check for COLOUR support in driver
+	push	si
+	push	di
+	push	cs
+	pop	ds
+	lea	si,cs:colour_sig	; signature
+	lea	di,10[bx]
+	mov	cx,14			; length of signature
+	cld
+	repz	cmpsb			; compare string
+	pop	di
+	pop	si
+	pop	ds
+	ret				; zero flag set if COLOUR supported
+
+colour_sig	db	"CON     ","COLOUR"
+
+col_screen:
+	mov	ah,0fh			; get current screen page
+	int	10h			; screen page in BH
+	mov	ah,3			; get cursor position
+	int	10h
+	push	dx
+
+	mov	si,40h			; BIOS data segment
+	mov	es,si
+	xor	si,si
+	xor	dx,dx			; start in upper left corner
+	mov	cx,1			; only one char per time
+col_screen10:
+	push	es
+	push	si
+	mov	ah,2			; set cursor position
+	int	10h
+	mov	ah,8			; read character with colour
+	int	10h			; AL = char, AH = colour
+	mov	ah,9			; write char back, BL = colour
+	int	10h
+	pop	si
+	pop	es
+	inc	dl			; mov to next column
+	cmp	dl,es:4ah[si]		; already at the end of the line?
+	 jne	col_screen10		; no, do it again
+	xor	dl,dl			; else continue at first column
+	inc	dh			; in next line
+	cmp	dh,es:84h[si]		; already last in last line
+	 jbe	col_screen10		; not finished, yet
+
+	pop	dx
+	mov	ah,2			; restore cursor position
+	int	10h
+	ret
+
 _TEXT	ENDS
 	END
diff -u -P -r dr70107/command/dosif.h d110721/command/dosif.h
--- dr70107/command/dosif.h	2004-01-31 15:44:10.000000000 +0000
+++ d110721/command/dosif.h	2008-07-20 16:19:58.000000000 +0000
@@ -34,6 +34,8 @@
 ;    ENDLOG
 */
 
+#include	"dos7.h"
+
 EXTERN	VOID	CDECL	debug(VOID);
 
 #define	EXT_SUBST 1
@@ -43,6 +45,7 @@
 EXTERN BYTE * CDECL   heap_get(WORD);
 EXTERN BYTE * CDECL   heap(VOID);
 EXTERN VOID CDECL     heap_set(BYTE *);
+EXTERN UWORD CDECL    heap_size(VOID);
 #endif
 
 #if !defined(MWC)
@@ -107,6 +110,21 @@
 EXTERN WORD CDECL     ms_switchar(VOID);
 EXTERN WORD CDECL     ms_x_expand(BYTE *, BYTE *);
 
+EXTERN WORD CDECL     ms_edrv_space(BYTE *,BYTE *,UWORD);
+EXTERN WORD CDECL     ms_l_first(BYTE *, UWORD, FINDD *);
+EXTERN WORD CDECL     ms_l_next(UWORD, FINDD *);
+EXTERN WORD CDECL     ms_l_findclose(UWORD);
+EXTERN WORD CDECL     ms_l_unlink(BYTE *,UWORD);
+EXTERN WORD CDECL     ms_l_rename(BYTE *, BYTE *);
+EXTERN WORD CDECL     ms_l_expand(BYTE *, BYTE *);
+EXTERN WORD CDECL     ms_l_chdir(BYTE *);
+EXTERN WORD CDECL     ms_l_chmod(BYTE *, UWORD, UWORD);
+EXTERN WORD CDECL     ms_l_curdir(UWORD, BYTE *);
+EXTERN WORD CDECL     ms_l_rmdir(BYTE *);
+EXTERN WORD CDECL     ms_l_mkdir(BYTE *);
+EXTERN WORD CDECL     ms_l_creat(BYTE *, UWORD);
+EXTERN WORD CDECL     ms_l_open(BYTE *, UWORD);
+
 EXTERN VOID CDECL     mem_alloc(BYTE FAR * NEAR *, UWORD *, UWORD, UWORD);
 EXTERN VOID CDECL     mem_free (BYTE FAR * NEAR *);
 
@@ -126,6 +144,10 @@
 EXTERN VOID CDECL     restore_term_addr();
 #endif
 
+EXTERN UWORD CDECL     get_lastdrive(VOID);
+EXTERN UWORD CDECL     get_driveflags(UWORD);
+EXTERN UWORD CDECL     conv64(ULONG *, ULONG *);
+
 #if defined(DOSPLUS)
 EXTERN WORD CDECL     ms_x_getcp(UWORD *, UWORD *);
 EXTERN WORD CDECL     ms_x_setcp(UWORD);
@@ -143,6 +165,8 @@
 EXTERN BOOLEAN CDECL  env_del(BYTE *);			/* CSUP.ASM	*/
 EXTERN BOOLEAN CDECL  env_ins(BYTE *);			/* CSUP.ASM	*/
 
+EXTERN BOOLEAN CDECL  get_cmdname(BYTE *);		/* CSUP.ASM	*/
+
 #if defined(CDOSTMP)
 #define	system	bdos	/* Call the BDOS Function for Common routines	*/
 #else
@@ -180,4 +204,12 @@
 EXTERN	WORD	CDECL	get_scr_width(VOID);
 EXTERN	WORD	CDECL	novell_copy(WORD,WORD,ULONG);
 
-EXTERN WORD CDECL     ms_edrv_space(BYTE FAR * NEAR *,BYTE *,UWORD);
+#define COLDATA struct coldata
+COLDATA {
+	BYTE	flags;
+	BYTE	fgbg;
+	BYTE	border;
+};
+
+EXTERN	VOID	CDECL	get_colour(COLDATA *);
+EXTERN	VOID	CDECL	set_colour(COLDATA *);
diff -u -P -r dr70107/command/global.c d110721/command/global.c
--- dr70107/command/global.c	1997-04-16 21:41:44.000000000 +0000
+++ d110721/command/global.c	2008-02-24 21:04:52.000000000 +0000
@@ -166,3 +166,5 @@
 WORD	global_strat;
 WORD	global_in_hiload = 0;
 WORD	hidden_umb[10];
+
+UWORD	heap_min=0x4000;
diff -u -P -r dr70107/command/global.h d110721/command/global.h
--- dr70107/command/global.h	1997-04-16 21:10:56.000000000 +0000
+++ d110721/command/global.h	2008-02-24 21:05:28.000000000 +0000
@@ -153,3 +153,5 @@
 
 #define ERROR_EXIT	0x0200		/* Exit because of a Critical Error */
 #define BREAK_EXIT	0x0100		/* Exit because of a Control-Break  */
+
+EXTERN	UWORD	heap_min;
diff -u -P -r dr70107/command/help.h d110721/command/help.h
--- dr70107/command/help.h	1997-04-16 21:11:22.000000000 +0000
+++ d110721/command/help.h	2008-07-18 11:15:12.000000000 +0000
@@ -89,6 +89,7 @@
 #define 	HELP_VER     NULL
 #define 	HELP_VERIFY  NULL
 #define 	HELP_VOL     NULL
+#define 	HELP_COLOUR  NULL
 #else
 #define 	HELP_AND     help_and 
 #define 	HELP_APPEND  help_append 
@@ -142,6 +143,7 @@
 #define 	HELP_VER     help_ver    
 #define 	HELP_VERIFY  help_verify 
 #define 	HELP_VOL     help_vol    
+#define 	HELP_COLOUR  help_colour
 
 EXTERN BYTE	help_and    [];
 EXTERN BYTE	help_append [];
@@ -195,4 +197,5 @@
 EXTERN BYTE	help_ver    [];
 EXTERN BYTE	help_verify [];
 EXTERN BYTE	help_vol    [];
+EXTERN BYTE	help_colour [];
 #endif
diff -u -P -r dr70107/command/make.bat d110721/command/make.bat
--- dr70107/command/make.bat	2005-01-10 23:07:20.000000000 +0000
+++ d110721/command/make.bat	2008-07-09 11:26:32.000000000 +0000
@@ -1,6 +1,8 @@
 @ECHO off
 SET TOOLS=C:\MASM\BINB
 
+SET OPT_S=
+
 SET MASM=C:\MASM\BIN\ML.EXE /c /Zm
 SET WATCOM=C:\WATCOM
 SET WATCOMH=%WATCOM%\H
@@ -32,9 +34,9 @@
 
 rem %MASM% /Fo.\bin\message message
 rem IF ERRORLEVEL 1 GOTO FAILED
-%MASM% /Fo.\bin\resident resident
+%MASM% /Fo.\bin\resident.obj resident.asm
 IF ERRORLEVEL 1 GOTO FAILED
-%MASM% /Fo.\bin\txhelp txhelp
+%MASM% /Fo.\bin\txhelp.obj txhelp.asm
 IF ERRORLEVEL 1 GOTO FAILED
 
 %MASM% /DDOSPLUS /DWATCOMC /DPASCAL /DFINAL /I.\ /Fo.\bin\message.obj .\message.asm
@@ -48,24 +50,24 @@
 %MASM% /DDOSPLUS /DWATCOMC /DPASCAL /DFINAL /I.\ /Fo.\bin\crit.obj .\crit.asm
 IF ERRORLEVEL 1 GOTO FAILED
 
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\com.obj .\com.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\com.obj .\com.c
 IF ERRORLEVEL 1 GOTO FAILED
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\comint.obj .\comint.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\comint.obj .\comint.c
 IF ERRORLEVEL 1 GOTO FAILED
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\support.obj .\support.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\support.obj .\support.c
 IF ERRORLEVEL 1 GOTO FAILED
 
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\printf.obj .\printf.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\printf.obj .\printf.c
 IF ERRORLEVEL 1 GOTO FAILED
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\batch.obj .\batch.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\batch.obj .\batch.c
 IF ERRORLEVEL 1 GOTO FAILED
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\global.obj .\global.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\global.obj .\global.c
 IF ERRORLEVEL 1 GOTO FAILED
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\config.obj .\config.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\config.obj .\config.c
 IF ERRORLEVEL 1 GOTO FAILED
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\comcpy.obj .\comcpy.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\comcpy.obj .\comcpy.c
 IF ERRORLEVEL 1 GOTO FAILED
-%WC% /s /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\cmdlist.obj .\cmdlist.c
+%WC% %OPT_S% /DFINAL /i=. /ms /os /dWATCOMC /i=%WATCOMH% /fo.\bin\cmdlist.obj .\cmdlist.c
 IF ERRORLEVEL 1 GOTO FAILED
 
 ECHO -w -d -f- -K -O -X -Z -c -ms -I%BCC20H% -DMESSAGE -DDOSPLUS -zSCGROUP -zTCODE -zR_MSG > RESP1
@@ -113,12 +115,12 @@
 REM **********************
 REM CLEAN UP THE AREA
 REM **********************
-rem SET TOOLS=
-rem SET MASM=
-rem SET WC=
-rem SET LINK510=
-rem SET BCC20=
-rem SET WATCOMH=
-rem SET BCC20H=
-rem SET LOCTOOLS=
-
+SET TOOLS=
+SET MASM=
+SET WC=
+SET LINK510=
+SET BCC20=
+SET WATCOMH=
+SET BCC20H=
+SET LOCTOOLS=
+SET OPT_S=
diff -u -P -r dr70107/command/message.asm d110721/command/message.asm
--- dr70107/command/message.asm	2005-03-06 19:25:18.000000000 +0000
+++ d110721/command/message.asm	2011-07-21 18:23:58.000000000 +0000
@@ -17,7 +17,7 @@
 	public	_msg_version
 	public	msg_version
 msg_version	label	byte
-_msg_version	db	LF, "Enhanced DR-DOS 7.01.07 (6.3.2005) ", "based on Caldera OpenDOS 7.01", LF, NUL
+_msg_version	db	LF, "Enhanced DR-DOS 7.01.08 WIP (21.7.2011) ", "based on Caldera OpenDOS 7.01", LF, NUL
 	public	_msg_lbl
 	public	msg_lbl
 msg_lbl	label	byte
@@ -82,6 +82,10 @@
 	public	msg_optline
 msg_optline	label	byte
 _msg_optline	db	"%s (Y/N) ? ", NUL
+	public	_msg_optline2
+	public	msg_optline2
+msg_optline2	label	byte
+_msg_optline2	db	"%s (Y,N,R) ? ", NUL
 	public	_msg_batterm
 	public	msg_batterm
 msg_batterm	label	byte
@@ -141,7 +145,7 @@
 	public	_path_template
 	public	path_template
 path_template	label	byte
-_path_template	db	"%.122s", LF, NUL
+_path_template	db	"%s", LF, NUL
 	public	_msg_ren
 	public	msg_ren
 msg_ren	label	byte
@@ -206,7 +210,7 @@
 	public	msg_cpyright
 msg_cpyright	label	byte
 _msg_cpyright	db	"Copyright (c) 1976, 1997 Caldera, Inc. ", "All rights reserved.", LF
-		db	"Patches to original OpenDOS source code ", "Copyright (c) 2002-2005 Udo Kuhnt", LF, NUL
+		db	"Patches to original OpenDOS source code ", "Copyright (c) 2002-2011 Udo Kuhnt", LF, NUL
 	public	_msg_serialno
 	public	msg_serialno
 msg_serialno	label	byte
@@ -507,6 +511,10 @@
 	public	msg_nohelp
 msg_nohelp	label	byte
 _msg_nohelp	db	"Unable to give Help. Cannot find file %s.", LF, NUL
+	public	_msg_colour
+	public	msg_colour
+msg_colour	label	byte
+_msg_colour	db	"COLOUR = %s,%d,%d,%d", LF, NUL
 
 _MSG	ends
 
diff -u -P -r dr70107/command/message.def d110721/command/message.def
--- dr70107/command/message.def	1997-04-16 22:11:56.000000000 +0000
+++ d110721/command/message.def	2008-07-12 10:49:02.000000000 +0000
@@ -186,6 +186,8 @@
 	extrn	msg_onoff	: byte
 	extrn	_msg_optline	: byte
 	extrn	msg_optline	: byte
+	extrn	_msg_optline2	: byte
+	extrn	msg_optline2	: byte
 	extrn	_msg_outactive	: byte
 	extrn	msg_outactive	: byte
 	extrn	_msg_path	: byte
@@ -244,3 +246,5 @@
 	extrn	wed_d	: byte
 	extrn	_yes_no	: byte
 	extrn	yes_no	: byte
+	extrn	_msg_colour	: byte
+	extrn	msg_colour	: byte
diff -u -P -r dr70107/command/message.h d110721/command/message.h
--- dr70107/command/message.h	1997-04-16 22:11:56.000000000 +0000
+++ d110721/command/message.h	2008-07-12 10:39:36.000000000 +0000
@@ -92,6 +92,7 @@
 extern char near msg_on[];
 extern char near msg_onoff[];
 extern char near msg_optline[];
+extern char near msg_optline2[];
 extern char near msg_outactive[];
 extern char near msg_path[];
 extern char near msg_pathdrv[];
@@ -121,3 +122,4 @@
 extern char near us_date[];
 extern char near wed_d[];
 extern char near yes_no[];
+extern char near msg_colour[];
diff -u -P -r dr70107/command/msdos.equ d110721/command/msdos.equ
--- dr70107/command/msdos.equ	2004-01-31 00:27:16.000000000 +0000
+++ d110721/command/msdos.equ	2008-02-07 18:23:06.000000000 +0000
@@ -123,6 +123,18 @@
 MS_X_COMMIT	equ	68h
 
 MS_EDRV_SPACE	equ	7303h
+MS_L_UNLINK	equ	7141h
+MS_L_FIRST	equ	714eh
+MS_L_NEXT	equ	714fh
+MS_L_FINDCLOSE	equ	71a1h
+MS_L_RENAME	equ	7156h
+MS_L_EXPAND	equ	7160h
+MS_L_CHDIR	equ	713bh
+MS_L_CHMOD	equ	7143h
+MS_L_CURDIR	equ	7147h
+MS_L_RMDIR	equ	713ah
+MS_L_MKDIR	equ	7139h
+MS_L_OPEN	equ	716ch
 
 DOS_INT     equ 21h ; DOS Entry Point
 ;
@@ -131,3 +143,5 @@
 STDERR		equ	2	; Standard Error Output
 STDAUX		equ	3	; Auxilary Device Handle
 STDPRN		equ	4	; Printer Device Handle
+
+OPEN_RW		equ	2	; Open in Read/Write mode
\ No newline at end of file
diff -u -P -r dr70107/command/support.c d110721/command/support.c
--- dr70107/command/support.c	2005-02-18 02:17:12.000000000 +0000
+++ d110721/command/support.c	2008-03-09 15:26:34.000000000 +0000
@@ -813,7 +813,8 @@
 GLOBAL VOID repwild(src,dest)
 REG BYTE  *src,*dest;
 {
-        BYTE    t[13];
+/*        BYTE    t[13];*/
+        BYTE    t[MAX_LFNLEN];
 	BYTE	*temp;
 	
 	temp=&t[0];				/* ptr to temp array */
@@ -894,6 +895,9 @@
 
 #define	YES_CHAR	(*farptr(YES_NO+0))
 #define	NO_CHAR		(*farptr(YES_NO+1))
+#define RUN_CHAR	'R'
+
+EXTERN UWORD	boot_key_scan_code;
 
 GLOBAL BOOLEAN yes(abort, def)
 BOOLEAN abort, def;
@@ -1176,6 +1180,7 @@
 	REG BYTE *cp;
 	DTA	search;
 	WORD	ret;
+	FINDD	finddata;
 
 	if ((cp = d_check (path)) == NULLPTR)	/* if bad drive letter */
 	    return FAILURE;			/*    don't do it */
@@ -1185,7 +1190,14 @@
 	}
 	else if(!iswild (cp))			/* else is it path or file? */
 	{					/* wild cards imply files */
-	    ret = ms_x_first(path, ATTR_ALL, &search);	/* get attributes */
+	    ret = ms_l_first(path, ATTR_ALL, &finddata); /* get attributes */
+
+	    if (ret==ED_FUNCTION) {
+	      ret=ms_x_first(path,ATTR_ALL,&search);
+	      finddata.fattr=search.fattr;
+	    }
+	    else
+	      ms_l_findclose(finddata.handle);
 
 	    if(ret == ED_ROOM)
 	        ret = ED_FILE;
@@ -1207,7 +1219,7 @@
 		    return FAILURE;		/* no files found	     */
 		}
 
-	    if (search.fattr & ATTR_DIR) {	/* if path names directory   */
+	    if (finddata.fattr & ATTR_DIR) {	/* if path names directory   */
 		append_slash(path); 		/* make it all files in it   */
 		strcat(path, d_slash_stardotstar+3);
 	    }
@@ -1216,7 +1228,12 @@
 		return SUCCESS; 		/* exist. If no return	     */
 	}
 
-	ret = ms_x_first(path, attrib, &search);  /* Search for the file     */
+	ret = ms_l_first(path, attrib, &finddata);  /* Search for the file     */
+
+	if (ret==ED_FUNCTION)
+	  ret=ms_x_first(path,attrib,&search);
+	else
+	  ms_l_findclose(finddata.handle);
 
 	if(ret < 0)				/* Check the error returned  */
 	    if(!exist && (ret==ED_FILE || ret==ED_ROOM)) /* If file does not exist but*/
@@ -1236,11 +1253,16 @@
 GLOBAL BOOLEAN file_exist(filename)
 BYTE *filename;
 {
-BYTE filebuf[MAX_PATHLEN];
+/*BYTE filebuf[MAX_PATHLEN];*/
+BYTE filebuf[MAX_LFNLEN];
 WORD h;
 
 	get_filename(filebuf, filename, NO);
-	if((h = ms_x_open(filebuf, OPEN_READ)) > 0) {
+	h=ms_l_open(filebuf,OPEN_READ);
+	if (h==ED_FUNCTION)
+	  h=ms_x_open(filebuf,OPEN_READ);
+/*	if((h = ms_x_open(filebuf, OPEN_READ)) > 0) {*/
+	if (h>0) {
 	    ms_x_close(h);
 	    return TRUE;
 	}
@@ -1287,7 +1309,8 @@
 BYTE	*line;
 {
 	BYTE	c;
-	BYTE	*s;	
+	BYTE	*s;
+	BYTE	yn;
 
 	if (*line == 13 || *line == 10 || *line == 0) return;
 
@@ -1299,9 +1322,36 @@
 	    s++;
 	    strcpy(line,s);
 	}
-	else printf(MSG_OPTLINE,line);
+	else
+	  if (boot_key_scan_code==0x4200)
+	    printf(MSG_OPTLINE2,line);
+	  else
+	    printf(MSG_OPTLINE,line);
 	
-	if (!yes(NO,NO)) *line = 0;
+	while (!((yn==YES_CHAR)||(yn==NO_CHAR)||((yn==RUN_CHAR)&&(boot_key_scan_code==0x4200)))) {
+#if defined(CDOSTMP)
+	  yn = (BYTE) bdos(C_RAWIO, 0xFD);	/* Input a character and */
+#else
+	  yn = (BYTE) msdos((MS_C_RAWIN), NULL);	 
+#endif						/* read the response	*/
+	  yn=toupper(yn);			/* both upper and lower case */
+	  if (yn==13)				/* accept <CR> for Y */
+	    yn=YES_CHAR;
+	  if (yn==32)				/* <SPACE> for N */
+	    yn=NO_CHAR;
+	  if (yn==27)				/* and <ESC> for R */
+	    yn=RUN_CHAR;
+	  if (!((yn==YES_CHAR)||(yn==NO_CHAR)||((yn==RUN_CHAR)&&(boot_key_scan_code==0x4200))))
+	    eprintf("\7");
+	  else {
+	    putc(yn);				/* echo the character */
+	    crlf(); 				/* new line		*/
+	  }
+	}
+
+/*	if (!yes(NO,NO)) *line = 0;*/
+	if (yn==NO_CHAR) *line = 0;		/* skip this line if NO */
+	if (yn==RUN_CHAR) boot_key_scan_code=0; /* run-through, deselect F8 key */
 
 	/*printf("\n");*/
 	
diff -u -P -r dr70107/command/toupper.h d110721/command/toupper.h
--- dr70107/command/toupper.h	1997-04-16 21:14:58.000000000 +0000
+++ d110721/command/toupper.h	2008-07-12 10:51:02.000000000 +0000
@@ -172,6 +172,7 @@
 #define	MSG_BADCMD	msg_badcmd	
 #define	MSG_PATHDRV	msg_pathdrv	
 #define MSG_OPTLINE	msg_optline
+#define MSG_OPTLINE2	msg_optline2
 #define	MSG_BATTERM	msg_batterm	
 #define	MSG_BATMISS	msg_batmiss	
 #define	MSG_BATNEST	msg_batnest	
@@ -346,3 +347,5 @@
 #endif
 
 #endif
+
+#define MSG_COLOUR	msg_colour
diff -u -P -r dr70107/command/txhelp.asm d110721/command/txhelp.asm
--- dr70107/command/txhelp.asm	1997-04-17 18:39:12.000000000 +0000
+++ d110721/command/txhelp.asm	2011-07-18 11:57:04.000000000 +0000
@@ -148,6 +148,9 @@
 		public	help_vol
 help_vol	equ	$ - _single_table
 		dw	CHELP:_help_vol
+		public	help_colour
+help_colour	equ	$ - _single_table
+		dw	CHELP:_help_colour
 
 
 _DATA	ends
@@ -176,19 +179,20 @@
 		db	"es in copy", LF, TAB, TAB, "/C prompt for confirmation by user before copying", LF, TAB, TAB, "/Z zeros top bit of every byte in destination", LF, "Examples:", LF, TAB, "COPY file1+file2 file"
 		db	"3", LF, TAB, "COPY *.txt c:dir1", NUL
 _help_date	db	"DATE", TAB, "Displays and changes the date.", LF, LF, "Syntax:", LF, TAB, "DATE /H", LF, TAB, "DATE [mm-dd-yy] (US format)", LF, TAB, "DATE [dd-mm-yy] (European format)", LF, TAB, "DATE [yy-"
-		db	"mm-dd] (Japanese format)", LF, LF, TAB, "/H", TAB, "gives this screen", LF, TAB, "mm", TAB, "month 1 to 12", LF, TAB, "dd", TAB, "day 1 to 31", LF, TAB, "yy", TAB, "2 or 4 digit year", LF
+		db	"mm-dd] (Japanese format)", LF, TAB, "DATE [/T]", LF, LF, TAB, "/H", TAB, "gives this screen", LF, TAB, "mm", TAB, "month 1 to 12", LF, TAB, "dd", TAB, "day 1 to 31", LF, TAB, "yy", TAB, "2 or 4"
+		db	" digit year", LF, TAB, "/T", TAB, "displays current date without prompting for new date", LF
 		db	TAB, "none", TAB, "no parameters displays date then prompts for new date", LF, LF, "Examples:", LF, TAB, "DATE 16-11-90", LF, TAB, "DATE", NUL
 _help_del	db	"DEL", TAB, "Erases files.", LF, LF, "Syntax:", LF, TAB, "DEL /H", LF, TAB, "DEL wildspec [/C|/P][/S]", LF, LF, TAB, "/H", TAB, "  gives this screen", LF, TAB, "/C|/P", TAB, "  prompt befo"
 		db	"re deletion", LF, TAB, "/S", TAB, "  include system files", LF, TAB, "wildspec  file to be deleted (wildcards allowed)", LF, LF, "Examples:", LF, TAB, "DEL *.EXE /CS", LF, TAB, "DEL MYFILE."
 		db	"TXT", NUL
 _help_delq	db	"DELQ", TAB, "Erases files but queries you before doing so.", LF, LF, "Syntax:", LF, TAB, "DELQ /H", LF, TAB, "DELQ wildspec [/S]", LF, LF, TAB, "/H", TAB, "  gives this screen", LF, TAB, "/"
 		db	"S", TAB, "  include system files", LF, TAB, "wildspec  file to be deleted (wildcards allowed)", LF, LF, "Examples:", LF, TAB, "DELQ *.EXE /S", LF, TAB, "DELQ MYFILE.TXT", NUL
-_help_dir	db	"DIR", TAB, "Displays the files in a directory.", LF, LF, "Syntax:", TAB, "DIR /H", LF, TAB, "DIR [wildspec] [/L|/2|/W] [/P|/N] [/A|/D|/S] [/C|/R]", LF, LF, TAB, "/H", TAB, "  gives this scree"
+_help_dir	db	"DIR", TAB, "Displays the files in a directory.", LF, LF, "Syntax:", TAB, "DIR /H", LF, TAB, "DIR [wildspec] [/L|/2|/W|/B] [/P|/N] [/A|/D|/S] [/C|/R]", LF, LF, TAB, "/H", TAB, "  gives this scree"
 		db	"n", LF, TAB, "wildspec  files to be displayed (wildcards allowed)", LF, TAB, "/A", TAB, "  displays all files", LF, TAB, "/C or /R  make other switches default for next time", LF, TAB, "/D", TAB
 		db	"  displays files without system attribute set (default)", LF, TAB, "/L", TAB, "  long format. Include size, date and time (default)", LF, TAB, "/2", TAB, "  as above except files are displayed i"
 		db	"n two columns", LF, TAB, "/N", TAB, "  return to default paging switch", LF, TAB, "/P", TAB, "  pause at end of full page. Default is no paging", LF, TAB, "/S", TAB, "  displays files with sy"
-		db	"stem attribute set", LF, TAB, "/W", TAB, "  wide format. Displays file and directory names only", LF, TAB, "none", TAB, "  no parameters displays all files using current default", LF, TAB, TAB
-		db	"  switches", LF, "Example:", LF, TAB, "DIR /C /W", NUL
+		db	"stem attribute set", LF, TAB, "/W", TAB, "  wide format. Displays file and directory names only", LF, TAB, "/B", TAB, "  displays filenames only", LF, TAB, "none", TAB, "  no parameters dis"
+		db	"plays all files using current default", LF, TAB, TAB, "  switches", LF, "Example:", LF, TAB, "DIR /C /W", NUL
 _help_echo	db	"ECHO", TAB, "Used in batch files, this command is used to display a message", LF, TAB, "to the screen.", LF, LF, "Syntax:", LF, TAB, "ECHO /H", LF, TAB, "ECHO [ON|OFF|string]", LF, LF, TAB, "/"
 		db	"H", TAB, "gives this screen", LF, TAB, "ON", TAB, "turn echoing on (default)", LF, TAB, "OFF", TAB, "turn echoing off", LF, TAB, "string", TAB, "display ""string""", LF, LF, "Examples:", LF
 		db	TAB, "ECHO OFF", LF, TAB, "ECHO You are running the %%OS%% operating system.", NUL
@@ -247,9 +251,11 @@
 _help_shift	db	"SHIFT", TAB, "Used in batch files, this command allows you to change the", LF, TAB, "position of command line parameters to access more than 10", LF, TAB, "(%%0 through %%9) replacement variables."
 		db	LF, LF, "Syntax:", LF, TAB, "SHIFT [/H]", LF, LF, TAB, "/H", TAB, "gives this screen", LF, LF, "Example:", LF, TAB, ":loop", LF, TAB, "if ""%%1"" == """" goto done", LF, TAB, "copy %%1 "
 		db	"c:\archive", LF, TAB, "shift", LF, TAB, "goto loop", LF, TAB, ":done", NUL
-_help_time	db	"TIME", TAB, "Displays and changes the time of day.", LF, LF, "Syntax:", LF, TAB, "TIME /H", LF, TAB, "TIME [hh[:mm[:ss]][a|p] [/C]", LF, LF, TAB, "/H", TAB, "gives this screen", LF, TAB, "h"
+_help_time	db	"TIME", TAB, "Displays and changes the time of day.", LF, LF, "Syntax:", LF, TAB, "TIME /H", LF, TAB, "TIME [hh[:mm[:ss]][a|p] [/C] [/T]", LF, LF, TAB, "/H", TAB, "gives this screen", LF, TAB, "h"
 		db	"h", TAB, "hours 0 to 23 (24 hour clock) or 1 to 12 if a or p specified", LF, TAB, "mm", TAB, "minutes 0 to 59", LF, TAB, "ss", TAB, "seconds 0 to 59", LF, TAB, "a|p", TAB, "am|pm", LF, TAB
-		db	"/C", TAB, "displays time continuously", LF, TAB, "none", TAB, "no parameters displays the current time, then prompts for a", LF, TAB, TAB, "new time. Press Return to leave the time unchanged", LF
+		db	"/C", TAB, "displays time continuously", LF
+		db	TAB, "/T", TAB, "displays current time without prompting for new time", LF
+		db	TAB, "none", TAB, "no parameters displays the current time, then prompts for a", LF, TAB, TAB, "new time. Press Return to leave the time unchanged", LF
 		db	LF, "Examples:", LF, TAB, "TIME 5:23:8", LF, TAB, "TIME 7:32", LF, TAB, "TIME", NUL
 _help_type	db	"TYPE", TAB, "Displays the contents of a text file on screen.", LF, LF, "Syntax:", LF, TAB, "TYPE /H", LF, TAB, "TYPE wildspec [/P]", LF, LF, TAB, "/H", TAB, "  gives this screen", LF, TAB, "w"
 		db	"ildspec  file to be displayed (wildcards allowed)", LF, TAB, "/P", TAB, "  pause when screen full", LF, LF, "Examples:", LF, TAB, "TYPE *.TXT /P", LF, TAB, "TYPE C:\AUTOEXEC.BAT", NUL
@@ -267,6 +273,15 @@
 _help_hiload	db	"HILOAD", TAB, "Load and execute a program in upper memory.", LF, LF, "Syntax:", LF, TAB, "HILOAD /H", LF, TAB, "HILOAD fname", LF, LF, TAB, "/H", TAB, "gives this screen", LF, TAB, "fname", TAB
 		db	"filename of program to load", LF, LF, TAB, "(LOADHIGH and LH can be used instead of HILOAD)", LF, LF, "HILOAD only has an effect if MemoryMAX software is present and there is", LF, "upper memory"
 		db	" available. If this is not so then the program will load and", LF, "execute in conventional memory.", LF, LF, "Example:", LF, TAB, "HILOAD CURSOR", NUL
+_help_colour	db	"COLOUR", TAB, "Changes or displays the current text/border colour", LF, LF
+		db	"Syntax:", LF, TAB, "COLOUR /H", LF, TAB, "COLOUR ON|OFF", LF, TAB, "COLOUR [fg][,[bg][,[bd]]]", LF, LF
+		db	TAB, "/H", TAB, "gives this screen", LF
+		db	TAB, "ON|OFF", TAB, "enables/disables colour scheme without changing it", LF
+		db	TAB, "fg", TAB, "foreground colour 0-15", LF
+		db	TAB, "bg", TAB, "background colour 0-15", LF
+		db	TAB, "bd", TAB, "border colour 0-63", LF
+		db	TAB, "none", TAB, "displays current settings", LF, LF
+		db	"Examples:", LF, TAB, "COLOUR", LF, TAB, "COLOUR OFF", LF, TAB, "COLOUR 15,1,11", NUL
 
 _HELP	ends
 
diff -u -P -r dr70107/command/txhelp.def d110721/command/txhelp.def
--- dr70107/command/txhelp.def	1997-04-16 22:11:56.000000000 +0000
+++ d110721/command/txhelp.def	2008-07-18 11:12:58.000000000 +0000
@@ -55,3 +55,4 @@
 help_ver	equ	74
 help_verify	equ	76
 help_vol	equ	78
+help_colour	equ	80
diff -u -P -r dr70107/command/txhelp.h d110721/command/txhelp.h
--- dr70107/command/txhelp.h	1997-04-16 22:11:56.000000000 +0000
+++ d110721/command/txhelp.h	2008-07-18 11:12:30.000000000 +0000
@@ -109,3 +109,5 @@
 #define help_verify		((char near *)dls_table[38])
 #define DLS_help_vol		39
 #define help_vol		((char near *)dls_table[39])
+#define DLS_help_colour		40
+#define help_colour		((char near *)dls_table[40])
diff -u -P -r dr70107/drbio/bdosldr.a86 d110721/drbio/bdosldr.a86
--- dr70107/drbio/bdosldr.a86	2005-01-24 19:46:52.000000000 +0000
+++ d110721/drbio/bdosldr.a86	2009-01-04 14:03:34.000000000 +0000
@@ -78,6 +78,8 @@
 ;-----------
 	les	di,boot_device		; get device driver address
 	mov	dl,boot_drv		; get the boot drive sub unit
+	xor	dh,dh
+	dec	dh
 	mov	ax,es
 	or	ax,di			; make sure boot device is initialised
 	 jnz	login_drive10
@@ -97,22 +99,37 @@
 	call	device_request		; tell it to build a BPB
 ;	 jc	dev_fail		; return if can't determine BPB
 	 jnc	login_drive15
-	jmp	dev_fail		; return if can't determine BPB
+	jmp	login_drive17		; return if can't determine BPB
 login_drive15:
+	cmp	dl,boot_drv
+	 jne	login_drive16
+	mov	dh,dl
+login_drive16:
 	les	di,ds:RH2_BPB
 	mov	ax,part_off
 	cmp	es:word ptr BPB_HIDDEN[di],ax
 	 jne	login_drive17
 	mov	ax,part_off+2
 	cmp	es:word ptr BPB_HIDDEN+2[di],ax
-	 je	login_drive18
+	 jne	login_drive17
+	mov	dh,dl
+	jmps	login_drive18
 login_drive17:
-	inc	boot_drv
-	mov	dl,boot_drv
+	inc	dl
+	 jz	login_drive18
 	jmps	login_drive12
 login_drive18:
-	mov	dl,boot_drv
+	cmp	dh,255
+	 jne	login_drive19
+	jmp	dev_fail
+login_drive19:
+	mov	dl,dh
+	mov	boot_drv,dl
 	mov	init_drv,dl
+	mov	bx,offset req_hdr
+	mov	ds:RH_UNIT,dl		; save logical unit to use
+	mov	ds:RH_CMD,CMD_BUILD_BPB
+	call	device_request		; tell it to build a BPB
 	push	ds ! push si
 	push	ds ! pop es
 	mov	di,offset local_bpb	; ES:DI -> local BPB copy
@@ -186,6 +203,7 @@
 	mov	ax,4452h
 	int	21h			; try and get DRDOS version number
 	 jc	dev_fail		;  it's not DRDOS !
+	and	ax,0fffeh		; don't be so picky
 	cmp	ax,VER_MUSTBE		; version check the DRDOS BDOS
 	 jne	dev_fail		;  reject all but the one we want
 	ret				; return now I'm happy
@@ -246,7 +264,8 @@
 	clc
 	ret
 devreq_err:
-	jmp	dev_fail		; print error message
+	stc
+;	jmp	dev_fail		; print error message
 
 
 	ret
@@ -281,8 +300,9 @@
 	mov	start_cluster+2,bp
 	mov	start_cluster,cx
 	call	clus2sec
+	xor	ah,ah
 	mov	al,BT_sctr_per_cluster
-	cbw
+;	cbw
 	mul	BT_bytes_per_sector
 	mov	bx,32
 	div	bx
diff -u -P -r dr70107/drbio/biosinit.a86 d110721/drbio/biosinit.a86
--- dr70107/drbio/biosinit.a86	2005-01-24 17:29:08.000000000 +0000
+++ d110721/drbio/biosinit.a86	2011-07-21 18:20:16.000000000 +0000
@@ -80,7 +80,7 @@
 INIT_WINDOWS	equ	0004h		; Disable windows support
 
 COMMAND_BASE	equ	000E0h		; must cover FFFF:D0 for CALL5 fixup
-COMMAND_SIZE	equ	01680h
+COMMAND_SIZE	equ	01FA0h
 
 CGROUP	GROUP	CODE, INITCODE, INITDATA, INITPSP, INITENV, DATAEND
 CODE	CSEG
@@ -94,12 +94,24 @@
 DOS_FLAG	equ	word ptr  .001Ch	; Compressed Data Flag
 DOS_CODE	equ	word ptr  .001Eh	; DOS Code Length (Bytes)
 DOS_DATA	equ	word ptr  .0020h	; DOS Data Length (Bytes)
+UPX_POS		equ	word ptr  .0024h	; position of UPX signature
 NO_YES_CHARS	equ	word ptr  .0028h	; DOS Data No/Yes characters
 
 INT31_SEGMENT	equ	word ptr .00C6h		; DOS Data Segment pointer
 						; for ROM systems
 JMPF_OPCODE	equ	0EAh			; 8086 JMPF instruction
 
+;F5KEY		equ	3F00h
+;F8KEY		equ	4200h
+
+SWITCH_F	equ	01h
+SWITCH_N	equ	02h
+
+	extrn	oldxbda:word
+	extrn	newxbda:word
+	extrn	xbdalen:word
+	extrn	oldmemtop:word
+	
 INITCODE	CSEG	PARA 'INITCODE'
 	extrn	cleanup:near			; BIOS Clean Up routine
 	extrn	config_init:near		; CONFIG Code Init
@@ -118,7 +130,7 @@
 		db	'XXXX-0000-987654321X '
 
 		db	'Patches to original OpenDOS source code '
-		db	'Copyright (c) 2002-2005 Udo Kuhnt'
+		db	'Copyright (c) 2002-2011 Udo Kuhnt'
 
 
 	Public	biosinit
@@ -305,6 +317,26 @@
 	mov	dos_cseg,ax		; Update the DOS Code Segment
 	mov	ds,ax
 
+	mov	ax,UPX_POS		; test for UPX compression
+	cmp	ax,cs:word ptr UPX_SIGN
+	 jne	dos_noupx		; not UPX-compressed
+	mov	ax,UPX_POS+2
+	cmp	ax,cs:word ptr UPX_SIGN+2
+	 jne	dos_noupx
+	push	ds
+	push	cs			; return address after decompression
+	mov	ax,offset dos_upx
+	push	ax
+	mov	ax,ds			; entry point of decompression stub
+	sub	ax,10h
+	push	ax
+	mov	ax,100h
+	push	ax
+	retf				; unpack DRDOS.SYS
+dos_upx:
+	pop	ds
+dos_noupx:
+
 	mov	cl,4
 
 	mov	ax,ds:DOS_CODE		; get size of DOS code
@@ -487,6 +519,72 @@
 	jmps	load_e10
 
 eject
+
+	Public	get_boot_options
+get_boot_options:
+;----------------
+; On Entry:
+;	None
+; On Exit:
+;	AX = boot options
+	call	option_key		; poll keyboard for a while
+	 jnz	get_boot_options20	; if key available return that
+	test	boot_switches,SWITCH_N	; boot keys disabled?
+	 jnz	get_boot_options20	; then do not check shift key, either
+	mov	ah,2			; else ask ROS for shift state
+	int	16h
+	and	ax,3			; a SHIFT key is the same as F5KEY
+	 jz	get_boot_options20
+	mov	ax,F5KEY		; ie. bypass everything
+get_boot_options20:
+	ret
+
+option_key:
+;----------
+; On Entry:
+;	None
+; On Exit:
+;	AX = keypress if interesting (F5/F8)
+;	ZF clear if we have an interesting key
+;
+; Poll keyboard looking for a key press. We do so for a maximum of 36 ticks
+; (approx 2 seconds).
+;
+	xor	ax,ax
+	int	1Ah			; get ticks in DX
+	mov	cx,dx			; save in CX for later
+option_key10:
+	push	cx		
+	mov	ah,1
+	int	16h			; check keyboard for key
+	pop	cx
+	 jnz	option_key30		; stop if key available
+	test	boot_switches,SWITCH_F	; SWITCHES /F present?
+	 jnz	option_key20		; yes, skip delay
+	push	cx
+	xor	ax,ax
+	int	1Ah			; get ticks in DX
+	pop	cx
+	sub	dx,cx			; work out elapsed time
+	cmp	dx,36			; more than 2 secs ?
+	 jb	option_key10
+option_key20:
+	xor	ax,ax			; timeout, set ZF, no key pressed
+	ret
+
+option_key30:
+	test	boot_switches,SWITCH_N	; boot keys disabled?
+	 jnz	option_key20		; yes, continue without reading it
+	cmp	ax,F5KEY		; if it is a key we want then
+	 je	option_key40		;  read it, else just leave
+	cmp	ax,F8KEY		;  in the type-ahead buffer
+	 jne	option_key20
+option_key40:
+	xor	ax,ax
+	int	16h			; read the key
+	test	ax,ax			; clear ZF to indicate we have a key
+	ret
+
 ;
 ;	Initialise the PSP and inform DOS of the
 ;	location of the BIOSINIT PSP. The MS_P_SETPSP *MUST* be the first 
@@ -629,8 +727,11 @@
 
 	call	relocate_system		; relocate system as requested
 
-	mov	configpass,2
+	mov	configpass,3
 	mov	cfg_head,0
+	mov	cfg_tail,0
+	mov	cfg_seeklo,0
+	mov	cfg_seekhi,0
 	call	preload_done
 
 	push	es			; Free all of the unused memory
@@ -950,24 +1051,33 @@
 reloc_xbda15:
 	call	alloc_seg		; allocate low mem
 reloc_xbda20:
+	push	cx
 	xor	bx,bx
 	xchg	ax,dx
 	xor	ah,ah
 	mov	al,es:[bx]		; length of XBDA in kilobytes
-	mov	cl,10			; make this bytes instead
+	mov	cl,9			; make this words instead
 	shl	ax,cl
 	xchg	ax,cx
 	push	ds
-	push	es			; copy it to new position
+	mov	ax,es			; save old XBDA segment address,
+	push	es
+	mov	es,BIOS_SEG		; segment address of low memory code
+	mov	es:oldxbda,ax		; save old XBDA segment address,
+	mov	es:newxbda,dx		; new address
+	mov	es:xbdalen,cx		; and length for Int 19h
+	pop	es
+	push	es			; copy XBDA to new position
 	pop	ds
 	mov	es,dx
 	xor	di,di
 	xor	si,si
-	rep	movsb
+	rep	movsw
 	mov	ax,40h			; and update the BIOS data area with the new address
 	mov	ds,ax
 	mov	ds:0eh[bx],es
 	pop	ds
+	pop	cx
 	les	bx,func52_ptr		; now get the start of the MCB chain
 	mov	es,es:F52_DMDROOT[bx]
 	mov	si,mem_size
@@ -979,12 +1089,24 @@
 	inc	ax
 	cmp	di,si			; is this the one that includes the old XBDA?
 	 je	reloc_xbda40		; yes
+	cmp	es:DMD_ID,IDZ		; already the last one?
+	 jne	reloc_xbda31		; no
+	push	si
+	inc	si
+	cmp	ax,si			; XBDA immediately following this block?
+	pop	si
+	 je	reloc_xbda35		; yes
+	jmp	reloc_xbda130		; did not find it
+reloc_xbda31:
 	cmp	ax,si			; already past the right position?
-	 ja	reloc_xbda130		; that cannot be helped
+	 jna	reloc_xbda32		; no
+	jmp	reloc_xbda130		; that cannot be helped
+reloc_xbda32:
 	mov	es,ax			; get the address of the next MCB
-	cmp	es:DMD_ID,IDZ		; already the last one?
-	 jne	reloc_xbda30		; no, try again
-	jmps	reloc_xbda130		; did not find it
+	jmps	reloc_xbda30		; try again
+reloc_xbda35:
+	add	es:DMD_LEN,cx		; length of XBDA
+	jmp	reloc_xbda45
 reloc_xbda40:
 	push	ax			; save length of old MCB
 	push	es:DMD_PSP		; and the old PSP pointer
@@ -1009,11 +1131,15 @@
 	mov	es:F52_DMD_UPPER[bx],9fffh
 	les	bx,drdos_ptr
 	mov	es:DRDOS_DMD_UPPER[bx],9fffh
+reloc_xbda45:
 	mov	mem_size,0a000h		; and the base mem top
 	mov	ax,40h			; also update the new base mem size
 	mov	es,ax			; in the BIOS data area
 	mov	bx,13h
-	mov	es:[bx],640
+	mov	ax,640
+	xchg	es:[bx],ax
+	mov	es,BIOS_SEG
+	mov	es:oldmemtop,ax		; save old conventional memory top
 reloc_xbda130:
 	pop	es			; restore ES again
 reloc_xbda140:
@@ -1868,7 +1994,6 @@
 	stc				; it's not a 386
 	ret
 
-
 INITDATA	dseg	'INITDATA'
 
 
@@ -1882,6 +2007,11 @@
 	extrn	configPass:byte
 	extrn	part_off:word
 	extrn	cfg_head:word
+	extrn	cfg_tail:word
+	extrn	cfg_seeklo:word
+	extrn	cfg_seekhi:word
+	extrn	boot_options:word
+	extrn	boot_switches:byte
 
 ;
 ;	PUBLIC Variables which are initialised by the BIOS before the
@@ -2071,6 +2201,8 @@
 dosdata_len	dw	0
 int_stubs_seg	dw	0
 
+UPX_SIGN	db	'UPX!'
+
 INITPSP		DSEG	PARA 'INITDATA'
 		db	'Z'			; dummy DMD header
 		dw	0008h			; owner is system
diff -u -P -r dr70107/drbio/biosmsgs.asm d110721/drbio/biosmsgs.asm
--- dr70107/drbio/biosmsgs.asm	2005-03-06 19:23:06.000000000 +0000
+++ d110721/drbio/biosmsgs.asm	2011-07-21 18:18:44.000000000 +0000
@@ -31,7 +31,7 @@
 	public	_starting_dos_msg
 	public	starting_dos_msg
 starting_dos_msg	label	byte
-_starting_dos_msg	db	CR, LF, "Starting Enhanced DR-DOS 7.01.07 (6.3.2005)", CR, LF, NUL
+_starting_dos_msg	db	CR, LF, "Starting Enhanced DR-DOS 7.01.08 WIP (21.7.2011)", CR, LF, NUL
 	public	_lba_supp_msg
 	public	lba_supp_msg
 lba_supp_msg		label	byte
diff -u -P -r dr70107/drbio/config.a86 d110721/drbio/config.a86
--- dr70107/drbio/config.a86	2004-12-11 18:38:50.000000000 +0000
+++ d110721/drbio/config.a86	2008-11-19 12:14:44.000000000 +0000
@@ -83,6 +83,8 @@
 	extrn	HookInt2F:near
 	extrn	UnhookInt2F:near
 	extrn	Verify386:near
+	extrn	preload_done:near
+	extrn	get_boot_options:near
 	
 	Public config_init
 config_init:				; Initialize the CONFIG data
@@ -148,6 +150,29 @@
 
 	call	config_process		; Process CONFIG.SYS
 
+	call	get_boot_options	; look for user keypress
+	mov	boot_options,ax		;  return any options
+	cmp	ax,F5KEY
+	 jne	cfg_no_f5
+	lea	dx,cs:f5key_msg
+	mov	ah,MS_C_WRITESTR
+	int	DOS_INT
+	jmps	cfg_no_f8
+cfg_no_f5:
+	cmp	ax,F8KEY
+	 jne	cfg_no_f8
+	lea	dx,cs:f8key_msg
+	mov	ah,MS_C_WRITESTR
+	int	DOS_INT
+cfg_no_f8:
+
+	mov	configPass,1		; second pass of CONFIG.SYS
+	mov	cfg_head,0
+	mov	cfg_tail,0
+	mov	cfg_seeklo,0
+	mov	cfg_seekhi,0
+	call	preload_done
+
 	cmp	num_files,MIN_NUM_FILES	; Ensure the Minimum number of File
 	jae	cfg_ex10		; have been allocated.
 	mov	num_files,MIN_NUM_FILES
@@ -158,7 +183,7 @@
 
 	call	SetupDeblocking		; do our thing with deblocking
 
-	mov	byte ptr configPass,1
+	mov	byte ptr configPass,2
 	call	config_finish		; clean up configuration
 	call	setup_fopen		; allocate disk hashing
 	call	setup_history
@@ -1318,10 +1343,14 @@
 	extrn	func52_ptr:dword
 	extrn	drdos_ptr:dword
 	extrn	res_ddsc_ptr:dword
-
-
+	extrn	cfg_head:word
+	extrn	cfg_tail:word
+	extrn	cfg_seeklo:word
+	extrn	cfg_seekhi:word
+	extrn	boot_options:word
 
 include	initmsgs.def				; Include TFT Header File
+include	biosmsgs.def
 
 
 	extrn	preload_drv:byte
diff -u -P -r dr70107/drbio/config.equ d110721/drbio/config.equ
--- dr70107/drbio/config.equ	2004-09-07 23:01:34.000000000 +0000
+++ d110721/drbio/config.equ	2008-11-19 11:34:42.000000000 +0000
@@ -142,3 +142,5 @@
 IDM             equ     'M'		; not last id code
 IDZ             equ     'Z'		; last id code
 
+F5KEY		equ	3F00h		; keys returned by BIOS
+F8KEY		equ	4200h		;  in boot_options
diff -u -P -r dr70107/drbio/disk.asm d110721/drbio/disk.asm
--- dr70107/drbio/disk.asm	2004-12-08 13:18:54.000000000 +0000
+++ d110721/drbio/disk.asm	2009-05-09 01:47:02.000000000 +0000
@@ -179,7 +179,6 @@
 	extrn	output_hex:near
 	extrn	diskaddrpack:word
 
-
 udsc_root	label	dword
 		dw	-1,-1
 
@@ -1304,6 +1303,17 @@
 	mov	ax,P_MCNT[bp]		; get physical transfer length
 	sub	P_COUNT[bp],ax		; subtract from total transfer length
 	 jz	trkrw90			; exit if none left
+trkrw85_lba:
+	test	es:UDSC_INT13BITS[di],1	; LBA supported on this drive?
+	 jz	trkrw85			; no, then use CHS routine
+	xor	ah,ah			; update current LBA
+	add	word ptr P_LBABLOCK[bp],ax
+	adc	word ptr p_LBABLOCK+2[bp],0
+	mov	ah,SECSIZE/16
+	mul	ah			; AX = paras to inc DMA address
+	add	P_DMASEG[bp],ax		; update DMA segment
+	jmps	trkrw90
+trkrw85:
 	add	P_SECTOR[bp],al		; update current sector
 	mov	ah,SECSIZE/16
 	mul	ah			; AX = paras to inc DMA address
@@ -2316,7 +2326,19 @@
 
 	call	new_unit		; ES:DI -> UDSC
 	mov	es:UDSC_RUNIT[di],dl	; set physical drive (ROS code)
+	push	dx
+	mov	ah,ROS_LBACHK
+	mov	bx,55aah
+	int_____DISK_INT
+	pop	dx
+	 jc	equip_nolba
+	cmp	bx,0aa55h
+	 jnz	equip_nolba
+	xor	ah,ah
+	mov	es:UDSC_INT13EXT[di],ax	; version of int 13 extensions
+	mov	es:UDSC_INT13BITS[di],cx ; int 13 API support bitmap
 
+equip_nolba:
 	call	floppy_type		; determine type, build default BPB
 
 	cmp	nfloppy,1		; do we only have single drive?
@@ -2408,6 +2430,9 @@
 	cmp	cl,36			; 36 spt ?
 	 jne	equip_no_type		; don't recognise anything
 equip_type:
+	cmp	bl,0			; 360K 5.25"?
+	je	equip_type_ok		; yes
+	mov	es:UDSC_NCYL[di],80	; else assume 80 tracks
 	cmp	bl,3			; is it 1.44 Mb 3.5" type?
 	 jb	equip_type_ok		; skip if 360K, 1.2Mb, 720K (0, 1, 2)
 	mov	bl,7			; use reserved "Other" type
@@ -2434,9 +2459,43 @@
 	mov	es,ax			; ES = DS
 	rep	movsb			; make default BPB current BPB in UDSC
 	popx	<cx, si, di, es>
+
+;	test	es:UDSC_INT13BITS[di],7	; extended functions available?
+;	 jz	equip_type_nolba	; no, must be a standard FDD
+	push	cx
+	push	si
+	pushx	<es,di,dx>
+	mov	ah,ROS_LBAPARAM		; get extended drive parameters
+	lea	si,int13ex_para		; DS:SI -> drive parameter buffer
+	int_____DISK_INT
+	popx	<dx,di,es>
+	 jc	equip_type_nolba	; error, assume standard FDD
+	test	word ptr 2[si],4	; removable drive?
+	 jnz	equip_type_nolba	; no
+	or	es:UDSC_FLAGS[di],UDF_HARD ; classify it as hard disk
+	mov	ax,4[si]		; number of cylinders
+	mov	es:UDSC_NCYL[di],ax
+	mov	ax,8[si]		; number of heads
+	mov	nhead,al
+	mov	ax,0ch[si]		; number of sectors per track
+	mov	nsect,al
+	mov	ax,10h[si]		; total number of sectors
+	mov	es:word ptr (UDSC_BPB+BPB_SIZE)[di],ax
+	mov	ax,12h[si]
+	mov	es:word ptr (UDSC_BPB+BPB_SIZE+2)[di],ax
+	lea	bx,es:UDSC_BPB[di]
+	pushx	<es,di,si,dx>
+	call	hd_bpb			; build BPB from scratch
+	popx	<dx,si,di,es>
+	pop	si
+	lea	si,es:UDSC_BPB[di]
+	push	si
+equip_type_nolba:
+	pop	si
+	pop	cx
 	pushx	<es, di>
 	lea	di,es:UDSC_DEVBPB[di]
-	rep	movsb			; copy default BPB device BPB in UDSC
+	rep	movsb			; copy BPB to device BPB in UDSC
 	popx	<di, es>
 	ret
 
@@ -2741,11 +2800,13 @@
 	mov	word ptr partend+2,ax
 	sub	word ptr partend,1	; minus one
 	sbb	word ptr partend+2,0
+	mov	al,[si+4]		; get partition type
+	mov	parttype,al
 	test	int13ex_bits,1		; LBA support present?
 	 jnz	login_p0		; yes, then proceed normally
-	cmp	byte ptr [si+4],FAT16X_ID	; LBA partition?
+	cmp	parttype,FAT16X_ID	; LBA partition?
 	 je	login_p9		; ignore this if LBA support not present
-	cmp	byte ptr [si+4],FAT32X_ID	; LBA partition?
+	cmp	parttype,FAT32X_ID	; LBA partition?
 	 je	login_p9		; ignore this if LBA support not present
 	mov	ax,word ptr partend+2	; partition within CHS bounds?
 	cmp	ax,word ptr partend_max+2
@@ -2783,9 +2844,9 @@
 
 log_p0:
 	call	new_unit		; ES:DI -> new UDSC
-	cmp	byte ptr [si+4],FAT16X_ID	; LBA partition?
+	cmp	parttype,FAT16X_ID	; LBA partition?
 	 je	log_p0a			; yes, then always use LBA
-	cmp	byte ptr [si+4],FAT32X_ID	; LBA partition?
+	cmp	parttype,FAT32X_ID	; LBA partition?
 	 je	log_p0a			; yes, then always use LBA
 	mov	ax,word ptr partend+2	; test if beyond CHS barrier
 	cmp	ax,word ptr partend_max+2
@@ -2848,17 +2909,9 @@
 
 	mov	BPB_TOTSEC[bx],ax	; set partition size for < 32 Mb
 					; we'll zero this later if > 32 Mb
-	push	es
-	push	di
-	push	ax
-	push	dx
-	push	si
+	pushx	<es,di,ax,dx,si>
 	call	hd_bpb			; build BPB from scratch
-	pop	si
-	pop	dx
-	pop	ax
-	pop	di
-	pop	es
+	popx	<si,dx,ax,di,es>
 	
 	cmp	byte ptr -11[si],0E9h	; look for a jmp
 	jz	log_p1a
@@ -3004,23 +3057,94 @@
 	cmp	dx,32			; less than 32*65536 sectors (1 Gb)?
 	 jb	hd_bpb20		; yes, leave cluster size the same
 	mov	BPB_ALLOCSIZ[bx],32*2	; use 32 K clusters if 1-2 Gb
+	cmp	dx,64			; less than 64*65536 sectors (2 Gb)?
+	 jb	hd_bpb20		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],64*2	; use 64 K clusters if 2-4 Gb
+	cmp	dx,128			; less than 128*65536 sectors (4 Gb)?
+	 jb	hd_bpb20		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],0	; use 128 K clusters if 4-8 Gb
+	cmp	dx,256			; more than 256*65536 sectors (8 Gb)?
+	 jae	hd_bpb30		; then use FAT32 instead
 
 hd_bpb20:				; cluster size determined
 	sub	ax,1+(512*32/SECSIZE)	; subtract reserved+root directory
 	sbb	dx,0			; (note: 32 bytes per entry)
 	xor	cx,cx
 	mov	ch,BPB_ALLOCSIZ[bx]	; CX = (256 * # of clusters on drive)
-;	dec	cx
-	dec	ch
+	dec	cx
 	add	ax,cx			; add in for rounding error
 	adc	dx,0
 	inc	cx
+	 jnz	hd_bpb25
+	xchg	ax,dx
+	jmps	hd_bpb26
+hd_bpb25:
 	div	cx			; AX = # of fat sectors
+hd_bpb26:
 	mov	BPB_FATSEC[bx],ax	; remember FAT size
 	mov	es:UDSC_FSTYPE+4[di],'6'; change "FAT12" to "FAT16"
 	ret
 	
-
+hd_bpb30:				; build BPB for FAT32
+	mov	BPB_DIRMAX[bx],0	; FAT32, so no fixed root dir
+	mov	BPB_FATADD[bx],3	; assume 1 boot, 1 reserved, 1 info sector
+	mov	word ptr BPB_FSROOT[bx],2; assume root dir is in first cluster
+	mov	BPB_FSINFO[bx],2	; FS info sector at 2, this is standard
+	mov	BPB_BOOTBAK[bx],0ffffh	; no backup boot sector
+	mov	BPB_ALLOCSIZ[bx],1	; use 0.5 K clusters <64 Mb
+	cmp	dx,2			; less than 2*65536 sectors (64 Mb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],1*2	; use 1 K clusters if 64-256 Mb
+	cmp	dx,8			; less than 8*65536 sectors (256 Mb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],2*2	; use 2 K clusters if 256-1024 Mb
+	cmp	dx,32			; less than 32*65536 sectors (1 Gb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],4*2	; use 4 K clusters if 1-4 Gb
+	cmp	dx,128			; less than 128*65536 sectors (4 Gb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],8*2	; use 8 K clusters if 4-16 Gb
+	cmp	dx,512			; less than 512*65536 sectors (16 Gb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],16*2	; use 16 K clusters if 16-64 Gb
+	cmp	dx,2048			; less than 2048*65536 sectors (64 Gb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],32*2	; use 32 K clusters if 64-256 Gb
+	cmp	dx,8192			; less than 8192*65536 sectors (256 Gb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],64*2	; use 64 K clusters if 256-1024 Gb
+	cmp	dx,32768		; less than 32768*65536 sectors (1024 Gb)?
+	 jb	hd_bpb40		; yes, leave cluster size the same
+	mov	BPB_ALLOCSIZ[bx],0	; use 128 K clusters if >1024 Gb
+	
+hd_bpb40:				; cluster size determined
+	sub	ax,1			; subtract reserved
+	sbb	dx,0
+	xor	cx,cx
+	mov	ch,BPB_ALLOCSIZ[bx]
+	shr	cx,1			; CX = (128 * # of clusters on drive)
+	dec	cx
+	add	ax,cx			; add in for rounding error
+	adc	dx,0
+	inc	cx
+;	div	cx			; AX = # of fat sectors
+	push	bp
+	push	dx
+	push	ax
+	xor	ax,ax
+	push	ax
+	push	cx
+	sub	sp,8
+	call	div32i
+	add	sp,4
+	pop	ax
+	pop	dx
+	add	sp,8
+	pop	bp
+	mov	word ptr BPB_BFATSEC[bx],ax	; remember FAT size
+	mov	word ptr BPB_BFATSEC+2[bx],dx
+	mov	es:UDSC_FSTYPE+3[di],'3'; change "FAT12" to "FAT32"
+	ret
 
 new_unit:
 	push	ds
@@ -3063,6 +3187,43 @@
 	pop	ds
 	ret
 
+div32i:					; 32-bit division
+;--------
+; On Entry:
+;	32-bit dividend & divisor on stack
+;	space for 32-bit quotient & remainder reserved on stack
+;	SP-16
+; On Exit:
+;	32-bit quotient & remainder on stack
+;	SP-16
+; Modified registers:
+;	AX,CX,DX,BP
+	mov	bp,sp			; base address of temporary variables
+	add	bp,2
+	xor	ax,ax			; clear work registers
+	xor	dx,dx
+	mov	cx,32			; 32 bits
+div32i_loop:
+	shl	word ptr 4[bp],1	; multiply quotient with two
+	rcl	word ptr 6[bp],1
+	shl	word ptr 12[bp],1	; shift one bit from dividend
+	rcl	word ptr 14[bp],1
+	rcl	ax,1			; to work registers
+	rcl	dx,1
+	cmp	dx,10[bp]		; compare high word with divisor
+	 jb	div32i_2
+	 ja	div32i_1
+	cmp	ax,8[bp]		; compare low word
+	 jb	div32i_2
+div32i_1:
+	or	word ptr 4[bp],1	; divisor fits one time
+	sub	ax,8[bp]		; subtract divisor
+	sbb	dx,10[bp]
+div32i_2:
+	loop	div32i_loop		; loop back if more bits to shift
+	mov	[bp],ax			; save remainder onto stack
+	mov	2[bp],dx
+	ret
 
 ICODE	ends
 
@@ -3084,6 +3245,9 @@
 int13ex_ver	dw	0		; version of int 13 extensions
 int13ex_bits	dw	0		; int 13 API support bitmap
 
+int13ex_para	dw	30		; extended drive parameters
+		db	28 dup (?)
+
 ;	Public	diskaddrpack
 ;diskaddrpack:				; disk address packet structure for LBA access
 ;		db	10h		; size of packet
@@ -3099,6 +3263,7 @@
 ptstart		dd	0		; block offset of current partition table
 lastpart	dd	0		; last checked partition
 extoffvalid	db	0		; extoffset valid flag
+parttype	db	0		; ID of partition
 
 	Public	init_runit
 init_runit	db	0		; poked with ROS Unit at boot
diff -u -P -r dr70107/drbio/doshndl.def d110721/drbio/doshndl.def
--- dr70107/drbio/doshndl.def	2003-08-02 22:40:00.000000000 +0000
+++ d110721/drbio/doshndl.def	2005-12-25 13:28:02.000000000 +0000
@@ -81,16 +81,21 @@
 DHNDL_DEVOFF	equ	word ptr 07h		; 07 - offset of device
 DHNDL_DEVSEG	equ	word ptr 09h		; 09 - segment of device
 DHNDL_BLK1	equ	word ptr 0Bh		; 0B - first cluster in file
+						;      (lower 32 bits)
 DHNDL_TIME	equ	word ptr 0Dh		; 0D - file time stamp
 DHNDL_DATE	equ	word ptr 0Fh		; 0F - file date stamp
 DHNDL_SIZE	equ	dword ptr 11h		; 11 - file length
+						;      (lower 32 bits)
 DHNDL_SIZELO	equ	word ptr 11h
 DHNDL_SIZEHI	equ	word ptr 13h
 DHNDL_POS	equ	dword ptr 15h		; 15 - current file position
+						;      (lower 32 bits)
 DHNDL_POSLO	equ	word ptr 15h
 DHNDL_POSHI	equ	word ptr 17h
 DHNDL_IDX	equ	word ptr 19h		; 19 - relative cluster within file of last read
+						;      (lower 32 bits)
 DHNDL_DBLK	equ	word ptr 1Bh		; 1B - cluster # of dir entry
+						;      (lower 32 bits)
 DHNDL_DCNTHI	equ	byte ptr 1Eh		; 1E - dir offset # within cluster
 DHNDL_DCNTLO	equ	byte ptr 1Fh		; 1F - dir offset # within cluster
 DHNDL_NAME	equ	byte ptr 20h		; 20 - File/Device Name
@@ -100,12 +105,25 @@
 DHNDL_PSP	equ	word ptr 31h		; 31 - Owning PSP
 DHNDL_SHARE	equ	word ptr 33h		; 33 - Offset of sharing record
 DHNDL_BLK	equ	word ptr 35h		; 35 - absolute cluster of last read
+						;      (lower 32 bits)
 						; 37 - dword reserved for IFS
-DHNDL_BLK1H	equ	word ptr 3Bh
-DHNDL_IDXH	equ	word ptr 3Dh
-DHNDL_DBLKH	equ	word ptr 3Fh
-DHNDL_BLKH	equ	word ptr 41h
-DHNDL_LEN	equ	43h
+DHNDL_BLK1H	equ	word ptr 3Bh		; 3B - first cluster in file
+						;      (higher 32 bits)
+DHNDL_IDXH	equ	word ptr 3Dh		; 3D - relative cluster within file of last read
+						;      (higher 32 bits)
+DHNDL_DBLKH	equ	word ptr 3Fh		; 3F - cluster # of dir entry
+						;      (higher 32 bits)
+DHNDL_BLKH	equ	word ptr 41h		; 41 - absolute cluster of last read
+						;      (higher 32 bits)
+DHNDL_SIZEX	equ	dword ptr 43h		; 43 - file length
+						;      (higher 32 bits)
+DHNDL_SIZEXLO	equ	word ptr 43h
+DHNDL_SIZEXHI	equ	word ptr 45h
+DHNDL_POSX	equ	dword ptr 47h		; 47 - current file position
+						;      (higher 32 bits)
+DHNDL_POSXLO	equ	word ptr 47h
+DHNDL_POSXHI	equ	word ptr 49h
+DHNDL_LEN	equ	4Bh
 
 ; With DOS 3 structures _DBLK is a 16 bit
 
diff -u -P -r dr70107/drbio/fdos.equ d110721/drbio/fdos.equ
--- dr70107/drbio/fdos.equ	2004-02-27 14:12:14.000000000 +0000
+++ d110721/drbio/fdos.equ	2005-12-27 15:57:12.000000000 +0000
@@ -204,6 +204,7 @@
 ;					; 0x04 - DELETE password
 ;					; 0x02 - WRITE password
 ;					; 0x01 - READ password
+DSIZEX		equ	12		;file size extension for FAT+ (bit 0-2 and 5-7)
 DUNDEL		equ	13		;1st letter of deleted file
 DPWD		equ	word ptr 14	;16-bit password hash code
 DMODTIME    	equ	word ptr 16	;delwatch time (hhhhhmmmmmmsssss)
diff -u -P -r dr70107/drbio/genercfg.a86 d110721/drbio/genercfg.a86
--- dr70107/drbio/genercfg.a86	2004-12-12 22:30:26.000000000 +0000
+++ d110721/drbio/genercfg.a86	2008-12-25 11:28:36.000000000 +0000
@@ -84,8 +84,13 @@
 TRUE	   	equ	0FFFFh		; value of TRUE
 FALSE	   	equ	0		; value of FALSE
 
-F5KEY		equ	3F00h		; keys returned by BIOS
-F8KEY		equ	4200h		;  in boot_options
+;F5KEY		equ	3F00h		; keys returned by BIOS
+;F8KEY		equ	4200h		;  in boot_options
+
+SWITCH_F	equ	01h		; in boot_switches
+SWITCH_N	equ	02h
+
+SWITCH_MAX	equ	10		; maximum number of SWITCH commands
 
 CGROUP		group	INITCODE, INITDATA, INITENV
 
@@ -230,29 +235,35 @@
 ;
 	push	si
 	push	di
-	cmp	configpass,2
-	 jb	cfg_query05
-	test	CFG_FLAGS[di],CF_LAST
-	stc
-	 jnz	cfg_query06
-	jmp	cfg_query90
+	mov	dx,CFG_FLAGS[di]	; flags for this config command
+	cmp	configpass,0		; CF_ALL does not include pass 0
+	 je	cfg_query05		; so skip the test in this pass
+	test	dx,CF_ALL		; present in all phases?
+	 jnz	cfg_query06		; yes, then execute it
 cfg_query05:
-	test	CFG_FLAGS[di],CF_LAST
+	and	dl,CF_NOF-1		; config pass to execute in
+	cmp	dl,configpass		; does the phase number match?
+	 je	cfg_query06		; yes
 	stc
-	 jz	cfg_query06
-	jmp	cfg_query90
+	jmp	cfg_query90		; else skip the command
+
 cfg_query06:
 	test	CFG_FLAGS[di],CF_NOF	; are Function Keys allowed ?
 ;	clc				; if not process the command
 	 jz $+5 ! jmp cfg_query90
 	cmp	ax,F5KEY		; F5 bypasses CONFIG processing
 	stc				;  so bypass this line
-	 je	cfg_query90
+;	 je	cfg_query90
+	 jne	cfg_query07
+	jmp	cfg_query90
+cfg_query07:
 	test	CFG_FLAGS[di],CF_QUERY	; specific QUERY request ?
 	 jnz	cfg_query10
 	cmp	ax,F8KEY		; should we prompt for everything ?
 	clc				; if not process the command
-	 jne	cfg_query90
+;	 jne	cfg_query90
+	 je	cfg_query10
+	jmp	cfg_query90
 cfg_query10:
 	push	si
 	mov	si,CFG_NAME[di]		; DS:SI -> command name we matched
@@ -284,10 +295,14 @@
 	mov	ah,MS_C_WRITE
 	mov	dl,yes_char
 	int	DOS_INT			; do "Y"
-	mov	dl,'/'
-	int	DOS_INT			; do "/"
+	mov	dl,','
+	int	DOS_INT			; do ","
 	mov	dl,no_char
 	int	DOS_INT			; do "N"
+	mov	dl,','
+	int	DOS_INT			; do ","
+	mov	dl,run_char
+	int	DOS_INT			; do "R"
 	mov	ah,MS_C_WRITESTR
 	mov	dx,offset confirm_msg2
 	int	DOS_INT			; do ") ? "
@@ -301,8 +316,43 @@
 	 jnz	cfg_query70
 	mov	ah,MS_C_RAWIN
 	int	DOS_INT			; throw away function keys
-    jmps    cfg_query60  
+;    jmps    cfg_query60  
 cfg_query70:
+	cmp	al,13			; accept <CR> for 'yes'
+	 jne	cfg_query71
+	mov	al,yes_char
+	jmps	cfg_query80
+cfg_query71:
+	cmp	al,32			; accept <SPACE> for 'no'
+	 jne	cfg_query72
+	mov	al,no_char
+	stc
+	jmps	cfg_query80
+cfg_query72:
+	cmp	al,27			; accept <ESC> for 'run'
+	 jne	cfg_query73
+	mov	al,run_char
+	mov	boot_options,0
+	jmps	cfg_query80
+cfg_query73:
+	call	toupper			; make response upper case
+	cmp	al,yes_char
+	 je	cfg_query80
+	cmp	al,no_char
+	 jne	cfg_query75
+	stc
+	jmps	cfg_query80
+cfg_query75:
+	cmp	al,run_char
+	 je	cfg_query76
+	mov	ah,MS_C_WRITE
+	mov	dl,7
+	int	DOS_INT			; beep
+	jmps	cfg_query60
+cfg_query76:
+	mov	boot_options,0
+cfg_query80:
+	pushf
 	push	ax			; save response
 	mov	ah,MS_C_WRITE
 	mov	dl,al
@@ -311,10 +361,11 @@
 	mov	dx,offset confirm_msg3	; "DEVICE=FILENAME.SYS (Y/N) ?"
 	int	DOS_INT			; now do CR/LF to tidy up
 	pop	ax
-	call	toupper			; make response upper case
-	cmp	al,yes_char		; is it yes ?
-	 je	cfg_query90
-	stc				; return CY set, skip this line
+;	call	toupper			; make response upper case
+;	cmp	al,yes_char		; is it yes ?
+;	 je	cfg_query90
+;	stc				; return CY set, skip this line
+	popf
 cfg_query90:
 	pop	di
 	pop	si
@@ -1090,9 +1141,15 @@
 	 je	func_switches10
 	cmp	ah,CR			; check for end-of-line
 	 je	func_switches10
+	cmp	ax,'F/'
+	 jne	func_switches05
+	or	boot_switches,SWITCH_F
+	jmps	func_switches
+func_switches05:
 	cmp	ax,'N/'
 	 jne	func_switches
-	mov	boot_options,0		; disable boot options
+;	mov	boot_options,0		; disable boot options
+	or	boot_switches,SWITCH_N	; disable boot options
 func_switches10:
 	ret
 
@@ -2011,6 +2068,8 @@
 
 func_switch:				; SWITCH=option0, option1
 ; GOSUB to appropriate label
+	cmp	configpass,1
+	 ja	func_switch05
 	call	wait_for_key		; wait until a key is pressed
 	 jc	func_switch01		; ignore if timeout
 	mov	ah,MS_C_RAWIN
@@ -2028,11 +2087,47 @@
 	 jns	func_switch05
 	mov	al,10			; make '0' into 10
 func_switch05:
+	mov	di,0
+	xor	bx,bx
+	mov	cx,cfg_seeklo
+	mov	dx,cfg_seekhi
+	sub	cx,cfg_tail
+	sbb	dx,0
+	add	cx,cfg_head
+	adc	dx,0
+func_switch06:
+	cmp	di,cfg_switchnum
+	 jae	func_switch10
+	cmp	word ptr cfg_switchbuf[bx],cx
+	 jne	func_switch07
+	cmp	word ptr cfg_switchbuf+2[bx],dx
+	 je	func_switch11
+func_switch07:
+	cmp	di,SWITCH_MAX
+	 jae	func_switch11
+	inc	di
+	add	bx,5
+	jmps	func_switch06
+func_switch10:
+	cmp	configpass,1
+	 ja	func_switch12
+	inc	di
+	mov	cfg_switchnum,di
+func_switch11:
+	cmp	configpass,1
+	 ja	func_switch12
+	mov	word ptr cfg_switchbuf[bx],cx
+	mov	word ptr cfg_switchbuf+2[bx],dx
+	mov	cfg_switchbuf+4[bx],al
+	jmps	func_switch15
+func_switch12:
+	mov	al,cfg_switchbuf+4[bx]
+func_switch15:
 	cbw				; AX = lines to skip
 	xchg	ax,cx			; make CX the loop count
 	 jcxz	func_switch30
 	mov	bx,si			; BX -> saved command line start
-func_switch10:
+func_switch20:
 	push	bx
 	push	cx
 	mov	di,offset dev_name	; copy and discard a label
@@ -2046,13 +2141,13 @@
 	pop	cx
 	pop	bx
 	 jc	func_switch40		; stop at end of line
-	loop	func_switch10
+	loop	func_switch20
 func_switch30:
 	jmp	func_gosub		; execute a GOSUB
 
 func_switch40:
 	mov	si,bx			; retract to start of line
-	jmps	func_switch		;  then back to sleep again
+	jmp	func_switch		;  then back to sleep again
 
 func_gosub:		; GOSUB="label"
 ;----------
@@ -2159,6 +2254,87 @@
 	int	10h			; Eeeek!! call the ROS
 	ret
 
+func_colour:				; Set fore-/background/border colour
+	push	es
+	call	comma			; check for leading ','
+	 jnc	func_colour10		; no fg col set, skip to bg
+	call	atoi			; else get foreground colour code
+	 jc	func_colour30		; no numerical value follows, skip
+	and	al,15			; only 0-15 supported
+	les	bx,dword ptr condev_off	; store in console driver
+	mov	es:byte ptr 24[bx],1	; and mark COLOUR as active
+	mov	es:25[bx],al
+	call	separator		; more to set?
+	 jc	func_colour30		; no
+func_colour10:
+	call	comma			; another comma following?
+	 jnc	func_colour20		; then skip to next section
+	call	atoi			; get value
+	 jc	func_colour30		; none found, done
+	and	al,15			; mask to 0-15
+	mov	cl,4			; * 16
+	shl	al,cl
+	les	bx,dword ptr condev_off	; store in console driver
+	mov	es:byte ptr 24[bx],1	; mark COLOUR as active
+	or	es:25[bx],al
+	call	separator		; finished now?
+	 jc	func_colour30		; it seems so
+func_colour20:
+	call	atoi			; else get border colour
+	 jc	func_colour30		; if there is one
+	and	al,15			; only use lower four bits
+	les	bx,dword ptr condev_off	; store in console driver
+	mov	es:byte ptr 24[bx],1	; mark COLOUR as active
+	or	es:26[bx],al
+	mov	bh,al			; and set border colour right away
+	mov	ax,1001h
+	int	10h
+func_colour30:
+	les	bx,dword ptr condev_off	; get address of console driver
+	cmp	es:byte ptr 24[bx],1	; check if any colour was changed
+	 jne	func_colour40		; apparently not
+	mov	bl,es:byte ptr 25[bx]	; else get the fg/bg colour
+	call	col_screen		; and apply it to the whole screen
+func_colour40:	
+	pop	es			; done
+	ret
+
+col_screen:
+	mov	ah,0fh			; get current screen page
+	int	10h			; screen page in BH
+	mov	ah,3			; get cursor position
+	int	10h
+	push	dx
+
+	mov	si,40h			; BIOS data segment
+	mov	es,si
+	xor	si,si
+	xor	dx,dx			; start in upper left corner
+	mov	cx,1			; only one char per time
+col_screen10:
+	push	es
+	push	si
+	mov	ah,2			; set cursor position
+	int	10h
+	mov	ah,8			; read character with colour
+	int	10h			; AL = char, AH = colour
+	mov	ah,9			; write char back, BL = colour
+	int	10h
+	pop	si
+	pop	es
+	inc	dl			; mov to next column
+	cmp	dl,es:4ah[si]		; already at the end of the line?
+	 jne	col_screen10		; no, do it again
+	xor	dl,dl			; else continue at first column
+	inc	dh			; in next line
+	cmp	dh,es:84h[si]		; already last in last line
+	 jbe	col_screen10		; not finished, yet
+
+	pop	dx
+	mov	ah,2			; restore cursor position
+	int	10h
+	ret
+
 func_timeout:
 ; set TIMEOUT for keyboard input
 	call	atoi			; AX = # timeout count
@@ -2261,12 +2437,34 @@
 func_query:
 ; ?optional command
 	cmp	boot_options,F5KEY	; if F5 has been pressed then
-	 je	func_query50		;  do nothing
+;	 je	func_query50		;  do nothing
+	 jne	func_query05
+	jmp	func_query50
+func_query05:
 	call	whitespace		; discard any following whitespace
 	lodsb				; get a character	
 	cmp	al,'?'			; is it another '?', is so swallow it
 	 je	func_query		;  and go round again
 	dec	si			; it wasn't a '?', forget we looked
+	mov	dl,1			; assume execution in main phase
+	push	si
+	push	dx
+	call	scan			; scan the command list
+	pop	dx
+	pop	si
+	 jc	func_query06
+	mov	dx,CFG_FLAGS[di]	; flags for this config command
+	cmp	configpass,0		; CF_ALL does not include pass 0
+	 je	func_query06
+	test	dx,CF_ALL		; present in all phases?
+	 jnz	func_query07		; yes, proceed with query
+func_query06:
+	and	dl,CF_NOF-1		; config pass to execute in
+	cmp	dl,configpass		; does the phase number match?
+	 je	func_query07		; yes, proceed with query
+	stc
+	jmp	func_query50		; no, no need to ask for it
+func_query07:
 	push	si			; save current position
 	lodsb				; get next real char
 	xor	cx,cx			; assume no prompt string
@@ -2310,8 +2508,28 @@
 	 jnz	func_query40
 	mov	ah,MS_C_RAWIN
 	int	DOS_INT			; throw away function keys
-    jmps    func_query30
+;    jmps    func_query30
 func_query40:
+	cmp	al,13			; accept <CR> for 'yes'
+	 jne	func_query41
+	mov	al,yes_char
+	jmps	func_query45
+func_query41:
+	cmp	al,32			; accept <SPACE> for 'no'
+	 jne	func_query42
+	mov	al,no_char
+	jmps	func_query45
+func_query42:
+	call	toupper
+	cmp	al,yes_char
+	 je	func_query45
+	cmp	al,no_char
+	 je	func_query45
+	mov	ah,MS_C_WRITE
+	mov	dl,7
+	int	DOS_INT
+	jmps	func_query30
+func_query45:
 	push	ax			; save response
 	mov	ah,MS_C_WRITE
 	mov	dl,al
@@ -2320,7 +2538,7 @@
 	mov	dx,offset confirm_msg3
 	int	DOS_INT			; now do CR/LF to tidy up
 	pop	ax
-	call	toupper			; make response upper case
+;	call	toupper			; make response upper case
 	pop	si			; recover starting position
 	cmp	al,yes_char
 	 jne	func_query50
@@ -3516,13 +3734,17 @@
 		rb	64		; space for bigger CHAIN'd file
 cfg_file_end	rb	0
 
+	Public	cfg_seeklo,cfg_seekhi
 cfg_seeklo	dw	0		; offset we have reached in CONFIG file
 cfg_seekhi	dw	0		; in case Richards CONFIG file > 64k
 
-	Public	cfg_head
+	Public	cfg_head,cfg_tail
 cfg_head	dw	0		; offset we are at in CONFIG_BUF
 cfg_tail	dw	0		; # bytes currently in CONFIG_BUF
 
+cfg_switchnum	dw	0		; number of SWITCH decisions stored
+cfg_switchbuf	rb	5*SWITCH_MAX	; buffer for config lines/key presses
+
 cfg_buffer	rb	CFG_BUF_LEN	; individual lines live here
 
 ;
@@ -3625,67 +3847,69 @@
 CFG_FLAGS	equ	word ptr .0004h		; Command flags
 CFG_SIZE	equ	6			; Size of each Entry
 
-CF_NOF		equ	0001h		; set if F5/F8 should be ignored
-CF_LC		equ	0002h		; set if case should be preserved
-CF_QUERY	equ	0004h		; set at run time eg. "DEVICE?"
-CF_LAST		equ	0020h		; execute in last config pass
+CF_LAST		equ	0003h		; execute in last config pass
+CF_NOF		equ	0008h		; set if F5/F8 should be ignored
+CF_LC		equ	0010h		; set if case should be preserved
+CF_QUERY	equ	0020h		; set at run time eg. "DEVICE?"
+CF_ALL		equ	0040h		; execute in all config passes
 
 cfg_table	rw	0
 if not ADDDRV
-	dw	cmd_country,	func_country,	0	; COUNTRY=nnn,nnn,country
-	dw	cmd_shell,	func_shell,	0	; SHELL=filename
-	dw	cmd_lastdrive,	func_lastdrive,	0	; LASTDRIVE=d:
-	dw	cmd_hilastdrive,func_hilastdrive,0	; HILASTDRIVE=d:
-	dw	cmd_break,	func_break,	0	; BREAK=ON/OFF
-	dw	cmd_buffers,	func_buffers,	0	; BUFFERS=nn
-	dw	cmd_hibuffers,	func_hibuffers,	0	; HIBUFFERS=nn
-	dw	cmd_fcbs,	func_fcbs,	0	; FCBS=nn
-	dw	cmd_hifcbs,	func_hifcbs,	0	; HIFCBS=nn
-	dw	cmd_files,	func_files,	0	; FILES=nn
-	dw	cmd_hifiles,	func_hifiles,	0	; HIFILES=nn
-	dw	cmd_stacks,	func_stacks,	0	; STACKS=nn
-	dw	cmd_histacks,	func_histacks,	0	; HISTACKS=nn
-	dw	cmd_fastopen,	func_fastopen,	0	; FASTOPEN=nnn
-	dw	cmd_drivparm,	func_drivparm,	0	; DRIVPARM=/d:nn ...
-	dw	cmd_history,	func_history,	0	; HISTORY=ON|OFF,NNN
+	dw	cmd_country,	func_country,	1	; COUNTRY=nnn,nnn,country
+	dw	cmd_shell,	func_shell,	1	; SHELL=filename
+	dw	cmd_lastdrive,	func_lastdrive,	1	; LASTDRIVE=d:
+	dw	cmd_hilastdrive,func_hilastdrive,1	; HILASTDRIVE=d:
+	dw	cmd_break,	func_break,	1	; BREAK=ON/OFF
+	dw	cmd_buffers,	func_buffers,	1	; BUFFERS=nn
+	dw	cmd_hibuffers,	func_hibuffers,	1	; HIBUFFERS=nn
+	dw	cmd_fcbs,	func_fcbs,	1	; FCBS=nn
+	dw	cmd_hifcbs,	func_hifcbs,	1	; HIFCBS=nn
+	dw	cmd_files,	func_files,	1	; FILES=nn
+	dw	cmd_hifiles,	func_hifiles,	1	; HIFILES=nn
+	dw	cmd_stacks,	func_stacks,	1	; STACKS=nn
+	dw	cmd_histacks,	func_histacks,	1	; HISTACKS=nn
+	dw	cmd_fastopen,	func_fastopen,	1	; FASTOPEN=nnn
+	dw	cmd_drivparm,	func_drivparm,	1	; DRIVPARM=/d:nn ...
+	dw	cmd_history,	func_history,	1	; HISTORY=ON|OFF,NNN
 	dw	cmd_hiinstalllast,func_hiinstall,CF_LAST; HIINSTALLLAST=cmdstring
-	dw	cmd_hiinstall,	func_hiinstall,	0	; HIINSTALL=cmdstring
-	dw	cmd_installhigh, func_hiinstall, 0	; INSTALLHIGH=cmdstring
+	dw	cmd_hiinstall,	func_hiinstall,	1	; HIINSTALL=cmdstring
+	dw	cmd_installhigh, func_hiinstall, 1	; INSTALLHIGH=cmdstring
 	dw	cmd_installlast,func_install,	CF_LAST	; INSTALLLAST=cmdstring
-	dw	cmd_install,	func_install,	0	; INSTALL=cmdstring
-	dw	cmd_hidos,	func_hidos,	0	; HIDOS=ON/OFF
-	dw	cmd_dosdata,	func_dosdata,	0	; DOSDATA=UMB
-	dw	cmd_ddscs,	func_ddscs,	0	; DDSCS=HIGH,UMB
-	dw	cmd_xbda,	func_xbda,	0	; XBDA=LOW,UMB
-	dw	cmd_dos,	func_dos,	0	; DOS=HIGH
-	dw	cmd_set,	func_set,	CF_LC	; SET envar=string
+	dw	cmd_install,	func_install,	1	; INSTALL=cmdstring
+	dw	cmd_hidos,	func_hidos,	1	; HIDOS=ON/OFF
+	dw	cmd_dosdata,	func_dosdata,	1	; DOSDATA=UMB
+	dw	cmd_ddscs,	func_ddscs,	1	; DDSCS=HIGH,UMB
+	dw	cmd_xbda,	func_xbda,	1	; XBDA=LOW,UMB
+	dw	cmd_dos,	func_dos,	1	; DOS=HIGH
+	dw	cmd_set,	func_set,	1+CF_LC	; SET envar=string
 	dw	cmd_switches,	func_switches,	CF_NOF	; SWITCHES=...
 endif
-	dw	cmd_hidevice,	func_hidevice,	0	; HIDEVICE=filename
-	dw	cmd_devicehigh,	func_hidevice,	0	; DEVICEHIGH=filename
-	dw	cmd_device,	func_device,	0	; DEVICE=filename
-	dw	cmd_remark,	func_remark,	CF_NOF	; REM Comment
-	dw	cmd_semicolon,	func_remark,	CF_NOF	; ; Comment
-	dw	cmd_colon,	func_remark,	CF_NOF	; :label
-	dw	cmd_chain,	func_chain,	0	; CHAIN=filename
-	dw	cmd_goto,	func_goto,	0	; GOTO=label
-	dw	cmd_gosub,	func_gosub,	0	; GOSUB=label
-	dw	cmd_return,	func_return,	0	; RETURN (from GOSUB)
-	dw	cmd_cls,	func_cls,	0	; Clear Screen
-	dw	cmd_cpos,	func_cpos,	0	; Set Cursor Position
-	dw	cmd_timeout,	func_timeout,	0	; set ? TIMEOUT
-	dw	cmd_switch,	func_switch,	0	; SWITCH=n
-	dw	cmd_onerror,	func_onerror,	CF_LC	; ONERROR='n' optional command
-	dw	cmd_query,	func_query, CF_NOF+CF_LC; ?optional command
-	dw	cmd_echo,	func_echo,	CF_LC	; ECHO=string
-	dw	cmd_exit,	func_exit,	0	; EXIT
-	dw	cmd_error,	func_error,	0	; ERROR='n'
-	dw	cmd_getkey,	func_getkey,	0	; GETKEY
-	dw	cmd_yeschar,	func_yeschar,	0	; YESCHAR=
-	dw	cmd_deblock,	func_deblock,	0	; DEBLOCK=xxxx
-	dw	cmd_numlock,	func_numlock,	0	; NUMLOCK=ON/OFF
-	dw	cmd_version,	func_version,	0	; VERSION=x.xx
-	dw	cmd_common,	func_common,	0	; [COMMON]
+	dw	cmd_hidevice,	func_hidevice,	1	; HIDEVICE=filename
+	dw	cmd_devicehigh,	func_hidevice,	1	; DEVICEHIGH=filename
+	dw	cmd_device,	func_device,	1	; DEVICE=filename
+	dw	cmd_remark,	func_remark,	1+CF_NOF; REM Comment
+	dw	cmd_semicolon,	func_remark,	1+CF_NOF; ; Comment
+	dw	cmd_colon,	func_remark,	1+CF_NOF; :label
+	dw	cmd_chain,	func_chain,	CF_ALL	; CHAIN=filename
+	dw	cmd_goto,	func_goto,	CF_ALL	; GOTO=label
+	dw	cmd_gosub,	func_gosub,	CF_ALL	; GOSUB=label
+	dw	cmd_return,	func_return,	CF_ALL	; RETURN (from GOSUB)
+	dw	cmd_cls,	func_cls,	1	; Clear Screen
+	dw	cmd_cpos,	func_cpos,	1	; Set Cursor Position
+	dw	cmd_colour,	func_colour,	1	; Set Fore-/Background/Border Colour
+	dw	cmd_timeout,	func_timeout,	1	; set ? TIMEOUT
+	dw	cmd_switch,	func_switch,	1+CF_ALL; SWITCH=n
+	dw	cmd_onerror,	func_onerror,	1+CF_ALL+CF_LC; ONERROR='n' optional command
+	dw	cmd_query,	func_query, CF_ALL+CF_NOF+CF_LC; ?optional command
+	dw	cmd_echo,	func_echo,	1+CF_LC	; ECHO=string
+	dw	cmd_exit,	func_exit,	CF_ALL	; EXIT
+	dw	cmd_error,	func_error,	1+CF_ALL; ERROR='n'
+	dw	cmd_getkey,	func_getkey,	1	; GETKEY
+	dw	cmd_yeschar,	func_yeschar,	1	; YESCHAR=
+	dw	cmd_deblock,	func_deblock,	1	; DEBLOCK=xxxx
+	dw	cmd_numlock,	func_numlock,	1	; NUMLOCK=ON/OFF
+	dw	cmd_version,	func_version,	1	; VERSION=x.xx
+	dw	cmd_common,	func_common,	1	; [COMMON]
  	dw	0				; end of table
 
 if not ADDDRV
@@ -3730,6 +3954,7 @@
 cmd_return	db	'RETURN',0
 cmd_cls		db	'CLS',0
 cmd_cpos	db	'CPOS',0
+cmd_colour	db	'COLOUR',0
 cmd_timeout	db	'TIMEOUT',0
 cmd_switch	db	'SWITCH',0
 cmd_onerror	db	'ONERROR',0
@@ -3783,8 +4008,9 @@
 envstart	rb	253		; initial env buffer
 envend		dw	0		; make it double null terminated
 		db	1Ah		; EOF marker env buffer
-	Public	boot_options
+	Public	boot_options, boot_switches
 boot_options	dw	0
+boot_switches	db	0
 ; set by BIOS to either the SHIFT states, or to F5KEY or F8KEY
 
 EXE_LENGTH	equ	001Ch
diff -u -P -r dr70107/drbio/ibmros.equ d110721/drbio/ibmros.equ
--- dr70107/drbio/ibmros.equ	2003-01-25 17:52:38.000000000 +0000
+++ d110721/drbio/ibmros.equ	2009-05-04 17:18:36.000000000 +0000
@@ -71,6 +71,7 @@
 ROS_LBAREAD	equ	42h		; extended read
 ROS_LBAWRITE	equ	43h		; extended write
 ROS_LBAVERIFY	equ	44h		; extended verify
+ROS_LBAPARAM	equ	48h		; get extended drive parameters
 
 PRN_ERROR	equ	00101001b	; printer error bits
 PRN_NOTBUSY	equ	10000000b
diff -u -P -r dr70107/drbio/init.asm d110721/drbio/init.asm
--- dr70107/drbio/init.asm	2004-10-26 14:26:32.000000000 +0000
+++ d110721/drbio/init.asm	2008-11-17 08:03:26.000000000 +0000
@@ -83,6 +83,8 @@
 
 F5KEY		equ	3F00h
 F8KEY		equ	4200h
+
+SWITCH_F	equ	01h
 	
 IVECT	segment	at 0000h
 
@@ -165,6 +167,7 @@
 	extrn	init_runit:byte
 	extrn	comspec_drv:byte
 	extrn	init_flags:word
+	extrn	boot_switches:byte
 
 
 include	biosmsgs.def			; Include TFT Header File
@@ -221,6 +224,8 @@
 		dw	DA_CHARDEV+DA_SPECIAL+DA_ISCOT+DA_ISCIN+DA_IOCTL
 		dw	CG:strat, CG:IntCon
 		db	'CON     '
+		db	'COLOUR'
+col_mode	db	0,7,0
 
 aux_drvr	dw	CG:prn_drvr, 0		; link to next device driver
 		dw	DA_CHARDEV
@@ -338,8 +343,30 @@
 	movsw
 	movsw				; restore this vector
 	loop	Int19Trap10		; go and do another
+	cmp	oldxbda,0		; has the XBDA been moved?
+	 je	Int19Trap20		; no
+	mov	es,oldxbda		; yes, move it back
+	mov	cx,xbdalen
+	mov	ds,newxbda
+	xor	si,si
+	xor	di,di
+	rep	movsw
+	mov	ax,40h			; update BIOS data
+	mov	ds,ax
+	xor	di,di
+	mov	ax,es
+	mov	0eh[di],ax
+	mov	ax,oldmemtop		; also restore old conventional
+					; memory top
+	mov	13h[di],ax
+Int19Trap20:
 	int	19h			; and go to original int 19...
 
+	Public	oldxbda,newxbda,xbdalen,oldmemtop
+oldxbda		dw	0		; old XBDA segment address
+newxbda		dw	0		; new XBDA segment address
+xbdalen		dw	0		; length of XBDA in words
+oldmemtop	dw	0		; old conventional mem limit
 
 	orgabs	16ch			; PRN:/AUX: the device number
 
@@ -477,10 +504,62 @@
 	cmp	al,8			; back space character
 	 je	Fastcon30		; special case
 Fastcon10:
-	mov	ah,0Eh			; use ROS TTY-like output function
+	push	es
+	push	cx
+	mov	cx,40h
+	mov	es,cx
+	mov	bx,cs:word ptr col_mode	; get colour mode
+	xchg	bh,bl
+	cmp	bh,0			; check if COLOUR is active
+	 je	Fastcon15		; no, continue normally
+	cmp	al,7			; check for non-printable chars
+	 je	Fastcon15
+	cmp	al,0ah
+	 je	Fastcon13
+	cmp	al,0dh
+	 je	Fastcon15
+	xor	bh,bh			; assume video page 0
+	mov	ah,9
+	mov	cx,1			; one char to display
+	int	10h			; display char with given colour
+	mov	bl,ah
+	mov	ah,3
+	int	10h
+	inc	dl
+	cmp	dl,es:4ah
+	 jb	Fastcon12
+	mov	dl,0
+Fastcon11:
+	inc	dh
+	cmp	dh,es:84h
+	 jbe	Fastcon12
+	dec	dh
+	push	dx
+	mov	ax,601h
+	xor	cx,cx
+	mov	dl,es:4ah
+	dec	dl
+	mov	dh,es:84h
+	mov	bh,cs:byte ptr col_mode+1
+	int	10h
+	pop	dx
+Fastcon12:
+	mov	ah,2
+	mov	bh,es:62h
+	int	10h
+	jmps	Fastcon20
+Fastcon13:
+	mov	ah,3
+	xor	bh,bh
+	int	10h
+	jmps	Fastcon11
+Fastcon15:
+	mov	ah,0eh			; use ROS TTY-like output function
 	mov	bx,7			; use the normal attribute
 	int	VIDEO_INT		; output the character in AL
 Fastcon20:
+	pop	cx
+	pop	es
 	popx	<bp, di, si, bx, ax>
 	iret
 
@@ -778,8 +857,12 @@
 
 	Assume	DS:CGROUP, ES:CGROUP
 
-	call	get_boot_options	; look for user keypress
-	mov	boot_options,ax		;  return any options
+	mov	si,offset CGROUP:drdosprojects_msg
+	call	output_msg
+	mov	si,offset CGROUP:starting_dos_msg
+	call	output_msg
+;	call	get_boot_options	; look for user keypress
+;	mov	boot_options,ax		;  return any options
 
 	mov	ah,EXT_MEMORY
 	int	SYSTEM_INT		; find out how much extended memory
@@ -917,67 +1000,69 @@
 	ret
 output_hex40	db	20h,NUL		; end of string
 
-get_boot_options:
-;----------------
-; On Entry:
-;	None
-; On Exit:
-;	AX = boot options
-	mov	si,offset CGROUP:drdosprojects_msg
-	call	output_msg
-	mov	si,offset CGROUP:starting_dos_msg
-	call	output_msg
-	call	option_key		; poll keyboard for a while
-	 jnz	get_boot_options20	; if key available return that
-	mov	ah,2			; else ask ROS for shift state
-	int	16h
-	and	ax,3			; a SHIFT key is the same as F5KEY
-	 jz	get_boot_options20
-	mov	ax,F5KEY		; ie. bypass everything
-get_boot_options20:
-	ret
-
-option_key:
-;----------
-; On Entry:
-;	None
-; On Exit:
-;	AX = keypress if interesting (F5/F8)
-;	ZF clear if we have an interesting key
+;get_boot_options:
+;;----------------
+;; On Entry:
+;;	None
+;; On Exit:
+;;	AX = boot options
+;	mov	si,offset CGROUP:drdosprojects_msg
+;	call	output_msg
+;	mov	si,offset CGROUP:starting_dos_msg
+;	call	output_msg
+;	call	option_key		; poll keyboard for a while
+;	 jnz	get_boot_options20	; if key available return that
+;	mov	ah,2			; else ask ROS for shift state
+;	int	16h
+;	and	ax,3			; a SHIFT key is the same as F5KEY
+;	 jz	get_boot_options20
+;	mov	ax,F5KEY		; ie. bypass everything
+;get_boot_options20:
+;	ret
 ;
-; Poll keyboard looking for a key press. We do so for a maximum of 36 ticks
-; (approx 2 seconds).
+;option_key:
+;;----------
+;; On Entry:
+;;	None
+;; On Exit:
+;;	AX = keypress if interesting (F5/F8)
+;;	ZF clear if we have an interesting key
+;;
+;; Poll keyboard looking for a key press. We do so for a maximum of 36 ticks
+;; (approx 2 seconds).
+;;
+;	xor	ax,ax
+;	int	1Ah			; get ticks in DX
+;	mov	cx,dx			; save in CX for later
+;option_key10:
+;	push	cx		
+;	mov	ah,1
+;	int	16h			; check keyboard for key
+;	pop	cx
+;	 jnz	option_key30		; stop if key available
+;	cmp	boot_switches,SWITCH_F	; SWITCHES /F present?
+;	 je	option_key20		; yes, skip delay
+;	push	cx
+;	xor	ax,ax
+;	int	1Ah			; get ticks in DX
+;	pop	cx
+;	sub	dx,cx			; work out elapsed time
+;	cmp	dx,36			; more than 2 secs ?
+;	 jb	option_key10
+;option_key20:
+;	xor	ax,ax			; timeout, set ZF, no key pressed
+;	ret
 ;
-	xor	ax,ax
-	int	1Ah			; get ticks in DX
-	mov	cx,dx			; save in CX for later
-option_key10:
-	push	cx		
-	mov	ah,1
-	int	16h			; check keyboard for key
-	pop	cx
-	 jnz	option_key30		; stop if key available
-	push	cx
-	xor	ax,ax
-	int	1Ah			; get ticks in DX
-	pop	cx
-	sub	dx,cx			; work out elapsed time
-	cmp	dx,36			; more than 2 secs ?
-	 jb	option_key10
-option_key20:
-	xor	ax,ax			; timeout, set ZF, no key pressed
-	ret
-
-option_key30:
-	cmp	ax,F5KEY		; if it is a key we want then
-	 je	option_key40		;  read it, else just leave
-	cmp	ax,F8KEY		;  in the type-ahead buffer
-	 jne	option_key20
-option_key40:
-	xor	ax,ax
-	int	16h			; read the key
-	test	ax,ax			; clear ZF to indicate we have a key
-	ret
+;option_key30:
+;	cmp	ax,F5KEY		; if it is a key we want then
+;	 je	option_key40		;  read it, else just leave
+;	cmp	ax,F8KEY		;  in the type-ahead buffer
+;	 jne	option_key20
+;option_key40:
+;	xor	ax,ax
+;	int	16h			; read the key
+;	test	ax,ax			; clear ZF to indicate we have a key
+;	ret
 
 ICODE	ends
 
@@ -1011,7 +1096,8 @@
 
 RCODE_ALIGN	segment public para 'RCODE'
 ifndef ROMSYS
-	db	1100h dup(0)		; reserve space for command.com
+;	db	1100h dup(0)		; reserve space for command.com
+	db	1A00h dup(0)		; reserve space for command.com
 endif
 RCODE_ALIGN	ends
 
diff -u -P -r dr70107/drbio/initmsgs.asm d110721/drbio/initmsgs.asm
--- dr70107/drbio/initmsgs.asm	1997-04-17 17:21:52.000000000 +0000
+++ d110721/drbio/initmsgs.asm	2008-11-19 12:17:58.000000000 +0000
@@ -18,6 +18,10 @@
 	public	no_char
 no_char	label	byte
 _no_char	db	"Nn", NUL
+	public	_run_char
+	public	run_char
+run_char	label	byte
+_run_char	db	"Rr", NUL
 	public	_bad_command
 	public	bad_command
 bad_command	label	byte
@@ -74,6 +78,14 @@
 	public	dos_msg
 dos_msg	label	byte
 _dos_msg	db	CR, LF, "Can't load DOS file.$", NUL
+	public	_f5key_msg
+	public	f5key_msg
+f5key_msg	label	byte
+_f5key_msg	db	CR,LF,"F5 key was pressed, skipping configuration files",CR,LF,"$",NUL
+	public	_f8key_msg
+	public	f8key_msg
+f8key_msg	label	byte
+_f8key_msg	db	CR,LF,"F8 key was pressed, single-stepping configuration files",CR,LF,"$",NUL
 
 INITDATA	ends
 
diff -u -P -r dr70107/drbio/initmsgs.def d110721/drbio/initmsgs.def
--- dr70107/drbio/initmsgs.def	1997-04-17 09:53:28.000000000 +0000
+++ d110721/drbio/initmsgs.def	2008-11-19 12:12:42.000000000 +0000
@@ -30,3 +30,9 @@
 	extrn	no_char	: byte
 	extrn	_yes_char	: byte
 	extrn	yes_char	: byte
+	extrn	_run_char	: byte
+	extrn	run_char	: byte
+	extrn	_f5key_msg	: byte
+	extrn	f5key_msg	: byte
+	extrn	_f8key_msg	: byte
+	extrn	f8key_msg	: byte
diff -u -P -r dr70107/drbio/stacks.asm d110721/drbio/stacks.asm
--- dr70107/drbio/stacks.asm	2004-04-16 16:53:58.000000000 +0000
+++ d110721/drbio/stacks.asm	2007-04-21 16:36:50.000000000 +0000
@@ -44,6 +44,7 @@
 
 	Assume	CS:STACKS, DS:Nothing, ES:Nothing, SS:Nothing
 
+	Public	StackCode
 StackCode:
 
 ;************
@@ -55,6 +56,7 @@
 StackCB		dw	0		; NumOfStacks*8 = size of control array
 StackSize       dw	0		; size of an individual stack
 StackPtr	label dword		; pointer to stack data		
+	Public	StackSeg,StackOff
 StackOff	dw	offset STACKS:StackHeap
 StackSeg	dw	0
 FirstStack	dw	offset STACKS:StackHeap
@@ -249,6 +251,7 @@
 	mov	es,ax		; ES = interrupt vectors
 	push	cs
 	pop	ds
+			Assume DS:STACKS
 	lea	si,i19Table	; DS:SI -> table to restore
 Int1910:
 	lodsw
diff -u -P -r dr70107/drdos/bdevio.a86 d110721/drdos/bdevio.a86
--- dr70107/drdos/bdevio.a86	2004-08-13 17:32:32.000000000 +0000
+++ d110721/drdos/bdevio.a86	2007-05-22 01:31:18.000000000 +0000
@@ -204,6 +204,10 @@
 
 byteoff		dw	0		; fdosrw local variable
 		dw	0		; byte offset with file
+		dw	0,0
+
+fsize		dw	0,0,0,0		; used for file size calculations
+lastpos		dw	0,0,0,0		; last position that has been written
 
 blk		dw	0,0		; current cluster of filepos
 blkidx		dw	0,0		; current cluster index within file
@@ -214,6 +218,12 @@
 fdw_extend_cl	dw	0,0
 check_cont_cl	dw	0,0
 
+lasttsc		dw	0,0,0,0
+tscsel		dw	0
+tsc1		dw	0,0,0,0,0,0,0,0
+tsc2		dw	0,0,0,0,0,0,0,0
+tsc3		dw	0,0,0,0,0,0,0,0
+
 ;	static request header for DOS device driver I/O
 
 	Public	req_hdr
@@ -271,6 +281,7 @@
 	extrn	update_dat:near
 	extrn	update_fat:near
 	extrn	share_delay:near
+	extrn	fatptr_tag:near
 
 	public	block_device_driver
 	public	clus2sec
@@ -282,6 +293,8 @@
 	public 	write_block
 	public	div32
 	public	mul32
+	public	div64
+	public	mul64
 
 eject
 
@@ -340,17 +353,35 @@
 	test	fdrwflg,1		; writing zero bytes?
 	 jnz	fdrw_error		; (reading has no meaning)
 	call	fdw_trunc		; writing truncates the file
-	jmps	fdrw_nobigger
+	jmp	fdrw_nobigger
 fdrw_error:
 	ret
 
 fdrw_loop:				; loop here for long reads/writes
 	call	fdrw_seek		; seek to position for xfer
-	 jc	fdrw_exit		;  should get error's now...
+;	 jc	fdrw_exit		;  should get error's now...
+	 jnc	fdrw_noerror
+	jmp	fdrw_exit
+fdrw_noerror:
 	 jnz	fdrw_buffered		; deblocking required if not aligned
 	mov	cx,fdrwcnt		; CX = requested transfer size
 	cmp	cx,psecsiz		; at least one sector transferred?
-	 jb	fdrw_buffered		; if less, need deblocked transfer
+;	 jb	fdrw_buffered		; if less, need deblocked transfer
+	 jae	fdrw_direct
+	test	fdrwflg,1
+	 jnz	fdrw_buffered
+	mov	ax,byteoff
+	sub	ax,lastpos
+	mov	ax,byteoff+2
+	sbb	ax,lastpos+2
+	mov	ax,byteoff+4
+	sbb	ax,lastpos+4
+	mov	ax,byteoff+6
+	sbb	ax,lastpos+6
+	 jc	fdrw_buffered
+	call	deblock_rw_npr
+	jmps	fdrw_more
+fdrw_direct:
 	mov	fdrwreq,cx		; requested count for direct r/w
 	call	direct_rw		; transfer straight to/from TPA
 	jmps	fdrw_more
@@ -362,23 +393,72 @@
 
 	add	byteoff,ax		; adjust file offset
 	adc	byteoff+2,0
+	adc	byteoff+4,0
+	adc	byteoff+6,0
 
+	push	ax
+	mov	ax,psecsiz
+	dec	ax
+	or	ax,lastpos
+	sub	ax,byteoff
+	mov	ax,lastpos+2
+	sbb	ax,byteoff+2
+	mov	ax,lastpos+4
+	sbb	ax,byteoff+4
+	mov	ax,lastpos+6
+	sbb	ax,byteoff+6
+	 jnc	fdrw_nohigher
+	mov	ax,byteoff
+	mov	lastpos,ax
+	mov	ax,byteoff+2
+	mov	lastpos+2,ax
+	mov	ax,byteoff+4
+	mov	lastpos+4,ax
+	mov	ax,byteoff+6
+	mov	lastpos+6,ax
+
+fdrw_nohigher:
+	pop	ax
 	sub	fdrwcnt,ax		; adjust remaining count
-	 ja	fdrw_loop		; still more to do
+;	 ja	fdrw_loop		; still more to do
+	 jna	fdrw_exit
+	jmp	fdrw_loop
 fdrw_exit:
 	les	bx,current_dhndl
 	mov	ax,fdos_ret		; get total xfered and update position
 	add	es:DHNDL_POSLO[bx],ax
 	adc	es:DHNDL_POSHI[bx],0
+	adc	es:DHNDL_POSXLO[bx],0
+	adc	es:DHNDL_POSXHI[bx],0
 	test	fdrwflg,1
 	 jnz	fdrw_return		; skip if reading
-	mov	ax,byteoff		; has the file grown ?
-	mov	dx,byteoff+WORD
+;	mov	ax,byteoff		; has the file grown ?
+;	mov	dx,byteoff+WORD
+;	sub	ax,es:DHNDL_SIZELO[bx]
+;	sbb	dx,es:DHNDL_SIZEHI[bx]
+	mov	ax,byteoff
 	sub	ax,es:DHNDL_SIZELO[bx]
-	sbb	dx,es:DHNDL_SIZEHI[bx]
+	mov	fsize,ax
+	mov	ax,byteoff+2
+	sbb	ax,es:DHNDL_SIZEHI[bx]
+	mov	fsize+2,ax
+	mov	ax,byteoff+4
+	sbb	ax,es:DHNDL_SIZEXLO[bx]
+	mov	fsize+4,ax
+	mov	ax,byteoff+6
+	sbb	ax,es:DHNDL_SIZEXHI[bx]
+	mov	fsize+6,ax
 	 jb	fdrw_nobigger		; yes, update the file size
+;	add	es:DHNDL_SIZELO[bx],ax
+;	adc	es:DHNDL_SIZEHI[bx],dx
+	mov	ax,fsize
 	add	es:DHNDL_SIZELO[bx],ax
-	adc	es:DHNDL_SIZEHI[bx],dx
+	mov	ax,fsize+2
+	adc	es:DHNDL_SIZEHI[bx],ax
+	mov	ax,fsize+4
+	adc	es:DHNDL_SIZEXLO[bx],ax
+	mov	ax,fsize+6
+	adc	es:DHNDL_SIZEXHI[bx],ax
 fdrw_nobigger:
 	call	timestamp_dhndl		; record the current time
 	test	es:DHNDL_MODE[bx],DHM_COMMIT
@@ -469,6 +549,10 @@
 	mov	es:DHNDL_SIZELO[bx],ax
 	mov	ax,byteoff+2
 	mov	es:DHNDL_SIZEHI[bx],ax
+	mov	ax,byteoff+4
+	mov	es:DHNDL_SIZEXLO[bx],ax
+	mov	ax,byteoff+6
+	mov	es:DHNDL_SIZEXHI[bx],ax
 	xor	ax,ax			; cause reads/writes to scan
 	mov	es:DHNDL_BLK[bx],ax	;   block chain from start
 	mov	es:DHNDL_BLKH[bx],ax
@@ -520,10 +604,31 @@
 fdrw_p20:
 	mov	fdrwseg,ax		; save normalized segment for read/write
 	les	bx,current_dhndl
-	mov	ax,es:DHNDL_POSLO[bx]
-	mov	byteoff,ax		; copy position to local variables
+	mov	ax,es:DHNDL_POSLO[bx]	; copy position to local variables
+	mov	byteoff,ax
 	mov	ax,es:DHNDL_POSHI[bx]
-	mov	byteoff+WORD,ax
+	mov	byteoff+2,ax
+	mov	ax,es:DHNDL_POSXLO[bx]
+	cmp	ax,63			; greater than 256 GB-1
+	 jbe	fdrw_p25
+	jmp	fdrw_p40		; then it is too big even for FAT+
+fdrw_p25:
+	mov	byteoff+4,ax
+	mov	ax,es:DHNDL_POSXHI[bx]
+	cmp	ax,0
+;	 ja	fdrw_p40
+	 jna	fdrw_p27
+	jmp	fdrw_p40
+fdrw_p27:
+	mov	byteoff+6,ax
+	mov	ax,es:DHNDL_SIZELO[bx]	; copy file size
+	mov	lastpos,ax
+	mov	ax,es:DHNDL_SIZEHI[bx]
+	mov	lastpos+2,ax
+	mov	ax,es:DHNDL_SIZEXLO[bx]
+	mov	lastpos+4,ax
+	mov	ax,es:DHNDL_SIZEXHI[bx]
+	mov	lastpos+6,ax
 ;	mov	cx,clsize
 ;	mov	ax,lastcl
 ;	mul	cx			; DX:AX = maximum size of disk
@@ -533,37 +638,55 @@
 	push	blastcl
 	sub	sp,8			; reserve space on stack
 	call	mul32			; compute maximum size of disk
-	pop	ax
-	pop	dx
-	pop	cx
-	add	sp,10			; clean up the stack again
+;	pop	ax
+;	pop	dx
+;	pop	cx
+	pop	fsize
+	pop	fsize+2
+	pop	fsize+4
+	pop	fsize+6
+;	add	sp,10			; clean up the stack again
+	add	sp,8			; clean up the stack again
+;	sub	ax,byteoff
+;	sbb	dx,byteoff+WORD		; beyond this we can't go
+;	sbb	cx,0
+	mov	ax,fsize
 	sub	ax,byteoff
-	sbb	dx,byteoff+WORD		; beyond this we can't go
-	sbb	cx,0
+	mov	ax,fsize+2
+	sbb	ax,byteoff+2
+	mov	ax,fsize+4
+	sbb	ax,byteoff+4
+	mov	ax,fsize+6
+	sbb	ax,byteoff+6
 	 jc	fdrw_p30
 ;	mov	ax,byteoff		; DX:AX = current file size
 ;	mov	dx,byteoff+WORD
 ;	div	clsize
 ;	mov	blkidx,ax		; save it for later
 ;	mov	blkoffset,dx		; DX = offset within cluster
-	push	word ptr byteoff+2	; current file size
+	push	word ptr byteoff+6	; current file size
+	push	word ptr byteoff+4
+	push	word ptr byteoff+2
 	push	word ptr byteoff
 	push	word ptr clsize+2
 	push	word ptr clsize
 	sub	sp,8			; reserve space on stack
-	call	div32
+;	call	div32
+	call	div64
 	pop	word ptr blkoffset	; offset within cluster
 	pop	word ptr blkoffset+2
 ;	add	sp,2			; skip high word
 	pop	word ptr blkidx		; save it for later
 	pop	word ptr blkidx+2
-	add	sp,8			; clean up stack
+;	add	sp,8			; clean up stack
+	add	sp,12			; clean up stack
 	clc				; theoretically possible
 fdrw_p30:
 	ret
 
-
-
+fdrw_p40:
+	stc
+	ret
 
 fdrw_size:
 ;---------
@@ -579,16 +702,34 @@
 ;	CY set if problem extending file
 ;
 	les	bx,current_dhndl
-	mov	ax,es:DHNDL_SIZELO[bx]	; are we past the end of file
-	mov	dx,es:DHNDL_SIZEHI[bx]	;  if so we may wish to extend on write
-	sub	ax,byteoff		; AX,DX = current offset
-	sbb	dx,byteoff+WORD		; are we already beyond EOF ?
+;	mov	ax,es:DHNDL_SIZELO[bx]	; are we past the end of file
+;	mov	dx,es:DHNDL_SIZEHI[bx]	;  if so we may wish to extend on write
+;	sub	ax,byteoff		; AX,DX = current offset
+;	sbb	dx,byteoff+WORD		; are we already beyond EOF ?
+	mov	ax,es:DHNDL_SIZELO[bx]
+	sub	ax,byteoff
+	mov	fsize,ax
+	mov	ax,es:DHNDL_SIZEHI[bx]
+	sbb	ax,byteoff+2
+	mov	fsize+2,ax
+	mov	ax,es:DHNDL_SIZEXLO[bx]
+	sbb	ax,byteoff+4
+	mov	fsize+4,ax
+	mov	ax,es:DHNDL_SIZEXHI[bx]
+	sbb	ax,byteoff+6
+	mov	fsize+6,ax
 	 jb	fdrw_s40
-	sub	ax,fdrwcnt		; will we be going beyond EOF ?
-	sbb	dx,0
+;	sub	ax,fdrwcnt		; will we be going beyond EOF ?
+;	sbb	dx,0
+	mov	ax,fdrwcnt
+	sub	fsize,ax
+	sbb	fsize+2,0
+	sbb	fsize+4,0
+	sbb	fsize+6,0
 	 jnb	fdrw_s10		; no, whole xfer is OK
 	test	fdrwflg,1		; check if we're reading
 	 jz	fdrw_s50		;  if we are just adjust the
+	mov	ax,fsize
 	add	fdrwcnt,ax		;  amount we can xfer
 fdrw_s10:
 ; We call share concerning the XFER to check if any of the proposed
@@ -635,22 +776,40 @@
 ;	CY clear if cluster chain now big enough for desired file size
 ;
 
-	mov	ax,byteoff		; AX,DX = current offset
-	mov	dx,byteoff+2
-	add	ax,fdrwcnt		; AX,DX = offset after r/w if success
-	adc	dx,0			; add offset from lower 16 bits
+;	mov	ax,byteoff		; AX,DX = current offset
+;	mov	dx,byteoff+2
+;	add	ax,fdrwcnt		; AX,DX = offset after r/w if success
+;	adc	dx,0			; add offset from lower 16 bits
+	mov	ax,byteoff
+	add	ax,fdrwcnt
+	mov	fsize,ax
+	mov	ax,byteoff+2
+	adc	ax,0
+	mov	fsize+2,ax
+	mov	ax,byteoff+4
+	adc	ax,0
+	mov	fsize+4,ax
+	mov	ax,byteoff+6
+	adc	ax,0
+	mov	fsize+6,ax
 ;	div	clsize			; AX whole blocks required
-	push	dx
-	push	ax
+;	push	dx
+;	push	ax
+	push	fsize+6
+	push	fsize+4
+	push	fsize+2
+	push	fsize
 	push	word ptr clsize+2
 	push	word ptr clsize
 	sub	sp,8
-	call	div32
+;	call	div32
+	call	div64
 	pop	ax
 	pop	dx
 	pop	fdw_extend_cl
 	pop	fdw_extend_cl+2
-	add	sp,8
+;	add	sp,8
+	add	sp,12
 	test	dx,dx			; any remainder ?
 	 jnz	fdw_e04
 	test	ax,ax
@@ -773,18 +932,22 @@
 ;	div	clsize
 ;	mov	blkidx,ax		; save cluster
 ;	mov	blkoffset,dx		;  and offset within it
-	push	word ptr byteoff+2	; where are we now ?
+	push	word ptr byteoff+6	; where are we now ?
+	push	word ptr byteoff+4
+	push	word ptr byteoff+2
 	push	word ptr byteoff
 	push	word ptr clsize+2
 	push	word ptr clsize
 	sub	sp,8			; reserve space on stack for result
-	call	div32
+;	call	div32
+	call	div64
 	pop	word ptr blkoffset	; save cluster and offset within it
 	pop	word ptr blkoffset+2
 ;	add	sp,2
 	pop	word ptr blkidx
 	pop	word ptr blkidx+2
-	add	sp,8			; clean up stack
+;	add	sp,8			; clean up stack
+	add	sp,12			; clean up stack
 	les	bx,current_dhndl
 	mov	ax,blkidx
 	mov	dx,blkidx+2
@@ -857,6 +1020,7 @@
 	mov	es:DHNDL_BLKH[bx],dx
 	mov	blk,ax			; save the block for coniguous checks
 	mov	blk+2,dx
+	call	fatptr_tag
 	mov	bx,blkoffset
 	mov	cx,blkoffset+2
 	call	clus2sec		; convert to sector/offset
@@ -879,9 +1043,14 @@
 ; On Exit:
 ;	AX = # of bytes transferred
 
+deblock_rw_npr:
+	mov	cx,BF_ISDAT		; CH = no preread, buffer is data
+	jmps	deblkrw05
+
 deblock_rw:
 ;----------
 	mov	cx,0FF00h+BF_ISDAT	; CH = preread, buffer is data
+deblkrw05:
 	mov	dx,word ptr fdrwsec	; set sector to xfer from
 ;	mov	ah,byte ptr fdrwsec+WORD
 	mov	ax,word ptr fdrwsec+WORD
@@ -935,10 +1104,18 @@
 	mov	bx,clsize+2
 	sub	cx,blkoffset		; BX:CX = bytes remaining in this block
 	sbb	bx,blkoffset+2
+	cmp	dx,bx
+	 jne	direct_rw03
+	cmp	ax,cx
+	 je	direct_rw10
+direct_rw03:
 	sub	ax,cx			; if wholly containined within block
 	sbb	dx,bx
 ;	 jbe	direct_rw10		; then leave it alone
-	 jnc	direct_rw10		; then leave it alone
+	jnc	direct_rw05
+	xor	dx,dx
+	jmps	direct_rw10		; then leave it alone
+direct_rw05:
 ;	div	clsize			; else get # of extra clusters
 ;	push	cx
 	push	dx
@@ -1301,10 +1478,14 @@
 	mov	word ptr current_ldt,bx
 	mov	word ptr current_ldt+WORD,es
 	mov	al,es:byte ptr LDT_FLAGS+1[bx]	; is the drive valid ?
-	test	al,(LFLG_NETWRKD+LFLG_JOINED)/100h
-	 jnz	select_drv_bad		; reject networked/joined drives
+;	test	al,(LFLG_NETWRKD+LFLG_JOINED)/100h
+;	 jnz	select_drv_bad		; reject networked/joined drives
+	test	al,LFLG_JOINED/100h
+	 jnz	select_drv_bad		; reject joined drives
 	test	al,LFLG_PHYSICAL/100h
 	 jz	select_drv_bad		; reject non-physical drives
+	test	al,LFLG_NETWRKD/100h	; skip if networked drive
+	 jnz	select_logical_drv30
 	mov	al,es:LDT_NAME[bx]	; get the drive from the ascii name
 	and	al,1fh			;  as the drive may require rebuilding
 	dec	ax			; make it zero based
@@ -1797,6 +1978,51 @@
 	adc	dx,0
 	ret
 
+div64:					; 64-bit division
+;--------
+; On Entry:
+;	64-bit dividend & 32-bit divisor on stack
+;	space for 32-bit quotient & remainder reserved on stack
+;	SP-20
+; On Exit:
+;	32-bit quotient & remainder on stack
+;	SP-20
+; Modified registers:
+;	AX,CX,DX,BP,SI
+	mov	bp,sp			; base address of temporary variables
+	add	bp,2
+	xor	ax,ax			; clear work registers
+	xor	dx,dx
+	xor	si,si
+	mov	cx,64			; 64 bits
+div64_loop:
+	shl	word ptr 4[bp],1	; multiply quotient with two
+	rcl	word ptr 6[bp],1
+	shl	word ptr 12[bp],1	; shift one bit from dividend
+	rcl	word ptr 14[bp],1
+	rcl	word ptr 16[bp],1
+	rcl	word ptr 18[bp],1
+	rcl	ax,1			; to work registers
+	rcl	dx,1
+	rcl	si,1
+	cmp	si,0			; larger than divisor?
+	 jne	div64_1
+	cmp	dx,10[bp]		; compare second word with divisor
+	 jb	div64_2
+	 ja	div64_1
+	cmp	ax,8[bp]		; compare first word
+	 jb	div64_2
+div64_1:
+	or	word ptr 4[bp],1	; divisor fits one time
+	sub	ax,8[bp]		; subtract divisor
+	sbb	dx,10[bp]
+	sbb	si,0
+div64_2:
+	loop	div64_loop		; loop back if more bits to shift
+	mov	[bp],ax			; save remainder onto stack
+	mov	2[bp],dx
+	ret
+
 div32:					; 32-bit division
 ;--------
 ; On Entry:
@@ -1810,6 +2036,8 @@
 ;	AX,CX,DX,BP
 	mov	bp,sp			; base address of temporary variables
 	add	bp,2
+	cmp	word ptr 10[bp],0
+	 je	div16
 	xor	ax,ax			; clear work registers
 	xor	dx,dx
 	mov	cx,32			; 32 bits
@@ -1835,6 +2063,92 @@
 	mov	2[bp],dx
 	ret
 
+div16:
+	mov	ax,12[bp]
+	mov	dx,14[bp]
+	div	word ptr 8[bp]
+	xor	cx,cx
+	mov	[bp],dx
+	mov	2[bp],cx
+	mov	4[bp],ax
+	mov	6[bp],cx
+	ret
+
+mul64:					; 64-bit multiplication
+;--------
+; On Entry:
+;	64-bit factors on stack
+;	space for 128-bit product reserved on stack
+;	SP-32
+; On Exit:
+;	64-bit product on stack
+;	SP-32
+;	Carry flag set if result does not fit in quad word
+; Modified registers:
+;	AX,BX,CX,DX
+	push	es			; save ES
+	push	bp			; save BP
+	push	si			; save SI
+	push	di			; save DI
+	push	ss
+	pop	es
+	mov	bp,sp			; base address of temporary variables
+	add	bp,10
+	mov	di,bp			; clear result
+	xor	ax,ax
+	mov	cx,4
+	cld
+	rep	stosw
+	xor	si,si			; start with lowest words of factors
+mul64_10:
+	xor	di,di
+mul64_20:
+	mov	bx,si			; compute offset in result
+	add	bx,di
+	add	bx,4
+	mov	cx,16			; number of carry additions left
+	sub	cx,bx
+	shr	cx,1			; / 2 = number of word additions
+	mov	ax,16[bp+si]		; multiply two words
+	mul	word ptr 24[bp+di]
+	xchg	bx,di
+	add	-4[bp+di],ax		; and add the product to the result
+	adc	-2[bp+di],dx
+	jcxz	mul64_40		; skip if highest words
+mul64_30:
+	jnc	mul64_40		; no carry, so no further adds needed
+	adc	word ptr [bp+di],0	; otherwise add zero
+	inc	di
+	inc	di
+	loop	mul64_30		; until no carry left over
+mul64_40:
+	xchg	bx,di
+	inc	di			; next word in first factor
+	inc	di
+	cmp	di,6			; already highest word?
+	 jbe	mul64_20		; next multiplication
+	inc	si			; next word in second factor
+	inc	si
+	cmp	si,6			; already highest word?
+	 jbe	mul64_10		; next multiplication
+	mov	cx,4			; check if results fits in 64 bits
+	xor	si,si
+mul64_45:
+	cmp	word ptr 8[bp+si],0	; zero?
+	 jnz	mul64_50		; if not, then skip and set carry
+	inc	si			; next word to compare
+	inc	si
+	loop	mul64_45		; until highest dword has been checked
+	jmps	mul64_60		; 64-bit result
+mul64_50:
+	stc
+mul64_60:
+	pop	di			; restore DI again
+	pop	si			; restore SI
+	pop	bp			; restore BP
+	pop	es			; restore ES
+	ret
+
 mul32:					; 32-bit multiplication
 ;--------
 ; On Entry:
@@ -1846,9 +2160,10 @@
 ;	SP-16
 ;	Carry flag set if result does not fit in double word
 ; Modified registers:
-;	AX,DX,BP,SP
+;	AX,DX
+	push	bp			; save BP
 	mov	bp,sp			; base address of temporary variables
-	add	bp,2
+	add	bp,4
 	mov	ax,10[bp]		; multiply high word of factors
 	mul	word ptr 14[bp]
 	mov	4[bp],ax		; store result
@@ -1876,6 +2191,83 @@
 mul32_1:
 	stc				; yes, set carry flag to indicate this
 mul32_2:
+	pop	bp			; restore BP again
+	ret
+
+	public	read_tsc
+read_tsc:
+	push	dx
+	push	ax
+	db	0fh,31h			; RDTSC
+	db	66h			; MOV lasttsc+4,EDX
+	mov	lasttsc+4,dx
+	db	66h			; MOV lasttsc,EAX
+	mov	lasttsc,ax
+	pop	ax
+	pop	dx
+	ret
+
+	public	diff_tsc
+diff_tsc:
+	push	dx
+	push	cx
+	push	bx
+	push	ax
+	db	0fh,31h			; RDTSC
+	db	66h			; MOV ECX,lasttsc+4
+	mov	cx,lasttsc+4
+	db	66h			; MOV EBX,lasttsc
+	mov	bx,lasttsc
+	db	66h			; SUB EAX,EBX
+	sub	ax,bx
+	db	66h			; SBB EDX,ECX
+	sbb	dx,cx
+	cmp	tscsel,0
+	 je	diff_tsc10
+	db	66h
+	push	dx
+	db	66h
+	push	ax
+	mov	dx,tscsel
+	call	output_hex
+	db	66h
+	pop	ax
+	db	66h
+	pop	dx
+	db	66h
+	xor	bx,bx
+	mov	bx,tscsel
+	dec	bx
+	shl	bx,1
+	shl	bx,1
+	shl	bx,1
+	db	66h
+	add	tsc1[bx],ax
+	db	66h
+	adc	tsc1+4[bx],dx
+	db	66h
+	mov	ax,tsc1[bx]
+	db	66h
+	mov	dx,tsc1+4[bx]
+diff_tsc10:
+	db	66h			; PUSH EAX
+	push	ax
+	db	66h			; PUSH EDX
+	push	dx
+	pop	ax
+	pop	dx
+	call	output_hex
+	xchg	ax,dx
+	call	output_hex
+	pop	ax
+	pop	dx
+	call	output_hex
+	xchg	ax,dx
+	call	output_hex
+	pop	ax
+	pop	bx
+	pop	cx
+	pop	dx
 	ret
 
 	public	output_msg
diff -u -P -r dr70107/drdos/buffers.a86 d110721/drdos/buffers.a86
--- dr70107/drdos/buffers.a86	2004-09-12 02:00:52.000000000 +0000
+++ d110721/drdos/buffers.a86	2008-01-06 23:42:40.000000000 +0000
@@ -70,6 +70,7 @@
 fatbytl		rb	1		; low byte of split FAT entry
 fatbyth		rb	1		; high byte of split FAT entry
 split_fat	rb	1		; 0/FFh to indicate split entry
+tag_flg		rb	1		; do not read FAT sector, just tag it
 
 alloc_clus_cl	dw	0,0
 alloc_chain_cl	dw	0,0
@@ -176,6 +177,13 @@
 ; rebuild our free space count
 	cmp	dosfat,FAT32		; FAT32 drive?
 	 jne	update_ddsc_free33	; no, then skip
+	cmp	es:word ptr DDSC_BFREE+2[bx],0	; out of free space?
+	 jne	update_ddsc_free31	; no, just unknown
+	cmp	es:word ptr DDSC_BFREE[bx],0
+	 je	update_ddsc_free33	; yes, then recount
+update_ddsc_free31:			; else try FS info sector value
+	cmp	es:DDSC_FSINFO[bx],0ffffh;FS info sector present?
+	 je	update_ddsc_free33	; no, then do not try to read from it
 	call	read_fsinfo05		; read the info block first, if one exists
 	cmp	es:word ptr DDSC_BFREE+2[bx],0	; is free block count on disk zero?
 	 jne	update_ddsc_free32	; no
@@ -194,6 +202,7 @@
 	lea	di,DDSC_BBLOCK[bx]	; ES:DI -> DDSC_BBLOCK
 	stosw				; DDSC_BBLOCK = 0
 	stosw
+	lea	di,DDSC_BFREE[bx]	; ES:DI -> DDSC_BFREE
 	stosw				; DDSC_BFREE = 0
 	stosw
 update_ddsc_free35:
@@ -228,7 +237,10 @@
 	adc	es:word ptr DDSC_BFREE+2[bx],0
 	jmps	update_ddsc_free40	; try next block
 update_ddsc_free50:
+	cmp	es:DDSC_FSINFO[bx],0ffffh;FS info sector present?
+	 je	update_ddsc_free55	; no, then do not write to it, either
 	call	write_fsinfo		; write a new FS info block first if applicable
+update_ddsc_free55:
 	jmp	update_ddsc_free10
 
 
@@ -489,7 +501,7 @@
 	mov	es:word ptr DDSC_BFREE[bx],cx	; SSTOR says there's none, lets agree
 	mov	es:word ptr DDSC_BFREE+2[bx],cx
 alloc_chain16:
-	call	update_fat		; flush FAT to bring SSTOR up to date
+;	call	update_fat		; flush FAT to bring SSTOR up to date
 	jmps	alloc_chain10		; go round again and ask DELWATCH to
 					;  free up some more space
 					; we loop until either SSTOR says OK
@@ -891,9 +903,16 @@
 ;	CX = entries left in sector (if FAT16 - performance optimisation)
 ;
 
+	Public	fatptr_tag
+fatptr_tag:
+	mov	tag_flg,1		; do not actually read FAT, just tag it
+	jmps	fatptr05
+
 	Public	fatptr
 fatptr:
 ;------
+	mov	tag_flg,0		; normal operation
+fatptr05:
 	push	dx			; save block number
 	push	ax
 ;	mov	bx,ax
@@ -940,7 +959,13 @@
 	mov	fatrec,ax		; save FAT sector for FIXFAT
 	mov	fatrec+2,dx
 	xchg	ax,dx			; AX:DX = FAT sector
+	test	tag_flg,1		; tag mode requested?
+	 jz	fatptr15		; no, locate the sector normally
+	call	tag_fat			; else tag the buffer if it exists
+	jmps	fatptr16
+fatptr15:
 	call	locate_fat		; locate the sector
+fatptr16:
 	pop	cx			; CX = sector size - 1
 	pop	bx			; restore offset within FAT sector
 	pop	ax			; restore cluster #
@@ -972,7 +997,13 @@
 ;	inc	dx			; get 2nd sector
 	add	dx,1			; get 2nd sector
 	adc	ax,0
+	test	tag_flg,1		; tag mode requested?
+	 jz	fatptr35		; no, locate the sector normally
+	call	tag_fat			; else tag the buffer if it exists
+	jmps	fatptr36
+fatptr35:
 	call	locate_fat		; read the 2nd sector
+fatptr36:
 	sub	bx,bx
 	lea	bx,BCB_DATA[si+bx]	; ES:BX -> buffer data
 	mov	al,es:[bx]		; get 1st byte from next sector
@@ -991,6 +1022,10 @@
 ;	entry:	AX:DX = sector number to read
 ;	exit:	ES:SI = BCB
 
+tag_fat:
+	xor	cx,cx			; do not read the buffer, just tag it
+	jmps	locate_buffer
+
 locate_fat:
 ;----------
 ;	mov	ah,0			; set sector address overflow = 0
@@ -1002,7 +1037,7 @@
 ;	AX:DX = sector to locate
 ;	adrive = driver
 ;	CH = 0FFh if preread required
-;	CL = buffer type
+;	CL = buffer type, 0 means tag only
 ; On Exit:
 ;	ES:SI -> BCB_
 ;
@@ -1024,6 +1059,8 @@
 	cmp	si,word ptr bcb_root	; while there are more buffers
 	 jne	locate10
 
+	cmp	cl,0			; shall we only tag an existing buffer?
+	 je	locate50		; yes, then do not sacrifice this one
 	push	ax ! push cx ! push dx	; save all registers
 	mov	si,es:BCB_PREV[si]	; recycle least recently used buffer
 	call	flush_buffer		; write buffer to disk
@@ -1054,6 +1091,7 @@
 	xchg	di,es:BCB_PREV[bx]	; back link to our buffer, DI = LRU buffer
 	mov	es:BCB_PREV[si],di	; link ourselves to LRU buffer
 	mov	es:BCB_NEXT[di],si	; forward link to our buffer
+locate50:
 	ret
 
 
@@ -1092,7 +1130,10 @@
 	push	es
 	push	bx
 	les	bx,current_ddsc
+	cmp	es:DDSC_FSINFO[bx],0ffffh;FS info sector present?
+	 je	update_fat10		; no, then do not to write it, either
 	call	write_fsinfo		; update fs info block if applicable
+update_fat10:
 	pop	bx
 	pop	es
 	mov	ah,BF_ISFAT		; flush all dirty FAT buffers
@@ -1518,8 +1559,9 @@
 	test	es:BCB_FLAGS[si],BF_ISFAT
 					; are we reading a FAT sector?
 	 jz	fill_buf1		; skip if directory/data
-	mov	al,es:BCB_DRV[si]	; get the drive
-	call	flush_fat		; write out all dirty buffers
+;	mov	al,es:BCB_DRV[si]	; get the drive
+;	call	flush_fat		; write out all dirty buffers
+	call	flush_buffer		; write out buffer if dirty
 	mov	al,0000$0010b		; reading from FAT area
 	jmps	fill_buf3		; go ahead
 fill_buf1:
diff -u -P -r dr70107/drdos/cio.a86 d110721/drdos/cio.a86
--- dr70107/drdos/cio.a86	1997-04-16 16:06:04.000000000 +0000
+++ d110721/drdos/cio.a86	2008-12-29 12:53:36.000000000 +0000
@@ -255,6 +255,16 @@
 ;	mov	bx,STDIN			; is there a character ready
 	call	char_check			;  to be input
 	 jz	func07
+
+	call	is_device			; reading from file?
+	 jnc	func06_10			; no, exit
+	push	es
+	mov	es,current_psp			; get current PSP
+	les	bx,PSP_XFTPTR			; file handle table
+	mov	es:byte ptr STDIN[bx],1		; cancel input redirection
+	pop	es
+func06_10:
+
 	mov	ax,RHS_IC			; set AL=0 and also set ZF on
 	jmps	funcICexit			;  exit as incomplete char
 
@@ -470,7 +480,7 @@
 	call	get_dseg		; Get our data segment
 	mov	exit_type,TERM_BREAK	; Force EXIT_TYPE to TERM_BREAK
 	mov	ax,4C00h		; "Good-Bye Cruel World" 
-    jmps    do23_20
+;    jmps    do23_20
     do23_10:
 	push	ds			; Otherwise restart the aborted func
 	call	get_dseg
@@ -563,7 +573,17 @@
 cmdline_read:
 	call	break_check		; check for a ^C on console
 	call	char_check		; is there a character ready
-	 jnz	cmdline_read_wait	;  no so keep scanning
+;	 jnz	cmdline_read_wait	;  no so keep scanning
+	 jz	cmdline_read10		; yes, proceed
+	call	is_device		; reading from file?
+	 jnc	cmdline_read_wait	; no, keep scanning
+	push	es
+	mov	es,current_psp		; get current PSP
+	les	bx,PSP_XFTPTR		; file handle table
+	mov	es:byte ptr STDIN[bx],1	; cancel input redirection
+	pop	es
+	jmps	cmdline_read_wait
+cmdline_read10:
 	cmp	al,CTLS			; if the user has typed ^S
 	 jne	cooked_read		;  we have to do a raw read
 ;	jmps	raw_read		;  else we do a cooked read
@@ -573,8 +593,17 @@
 					; put the processor to sleep.
 raw_read:
 	call	char_check		; Is there a character Ready
-	 jnz	raw_read_wait		; loop until character available
-	jmps	char_get
+;	 jnz	raw_read_wait		; loop until character available
+	 jz	char_get		; yes, proceed
+	call	is_device		; reading from file?
+	 jnc	raw_read_wait		; no, keep scanning
+	push	es
+	mov	es,current_psp		; get current PSP
+	les	bx,PSP_XFTPTR		; file handle table
+	mov	es:byte ptr STDIN[bx],1	; cancel input redirection
+	pop	es
+	jmps	raw_read_wait
+;	jmps	char_get
 
 cooked_read_wait:			; Waiting for a device to become
 	call	idle_dev		; ready. So call IDLE routines to
@@ -582,7 +611,16 @@
 cooked_read:
 	call	break_check		; check for a ^C on console
 	call	cooked_status		; check for a ^S,^P,^C on handle BX
-	 jnz	cooked_read_wait	; wait until char is available
+;	 jnz	cooked_read_wait	; wait until char is available
+	 jz	char_get		; yes, proceed
+	call	is_device		; reading from file?
+	 jnc	cooked_read_wait	; no, keep scanning
+	push	es
+	mov	es,current_psp		; get current PSP
+	les	bx,PSP_XFTPTR		; file handle table
+	mov	es:byte ptr STDIN[bx],1	; cancel input redirection
+	pop	es
+	jmps	cooked_read_wait
 ;	jmps	char_get		;  else get the character
 
 char_get:
@@ -598,6 +636,9 @@
 
 char_get30:
 ; We are redirected, so call to the FDOS to get a character
+	pop	ax			; get previous status
+	xor	ah,ah			; clear AH so that it is not mistaken
+	push	ax			; for a device request header
 	push ss ! pop es		; EX:DX -> character to read
 	mov	ah,MS_X_READ		; call the FDOS to do all
 	call	dos_entry		;  the hard work
diff -u -P -r dr70107/drdos/dirs.a86 d110721/drdos/dirs.a86
--- dr70107/drdos/dirs.a86	2004-08-15 12:27:48.000000000 +0000
+++ d110721/drdos/dirs.a86	2005-12-10 17:11:00.000000000 +0000
@@ -100,6 +100,8 @@
 chdblk		dw	0,0		; current cluster # of directory
 
 rd_pcdir_cl	dw	0,0		; current cluster in rd_pcdir
+rd_pcdir_rel	dw	0		; relative cluster in chain
+rd_pcdir_last	dw	0		; last relative position
 find_hcb_cl	dw	0,0		; current cluster in find_hcb
 
 
@@ -131,6 +133,7 @@
 	public	hshdscrd
 	public	mkhsh
 	public	setenddir
+	public	rd_pcdir
 eject
 
 fill_dirbuf:	;get 32 byte directory entry
@@ -301,6 +304,7 @@
 	pop	cx
 	xchg	ax,dx		; DX = # to skip, AX = offset in cluster
 	mov	di,dx
+	mov	rd_pcdir_rel,di	; remember cluster offset
 	xchg	ax,cx		; AX = start of chain, CX = offset in cluster
 	mov	ax,rd_pcdir_cl
 	mov	dx,rd_pcdir_cl+2
@@ -313,11 +317,15 @@
 	cmp	chdblk+2,0
 	 jz	rd_pcdir10	;  if not trace from start of chain
 rd_pcdir09:
+	cmp	di,rd_pcdir_last; trying to read cluster before last one?
+	 jb	rd_pcdir10	; yes, begin at start of chain
 ;	xchg	ax,cx		; AX = cluster of last dir entry
 	mov	ax,chdblk
 	mov	dx,chdblk+2
 	test	bx,bx		; have we moved onto next cluster?
 	 jnz	rd_pcdir20	; no, trust me..
+	cmp	di,rd_pcdir_last; have we moved onto next cluster?
+	 je	rd_pcdir20	; no, trust me..
 ;	mov	dx,1		; move on to next entry in the chain
 	mov	di,1		; move on to next entry in the chain
 rd_pcdir10:
@@ -343,6 +351,8 @@
 rd_pcdir20:
 	mov	chdblk,ax	; remember this cluster for next time
 	mov	chdblk+2,dx
+	mov	cx,rd_pcdir_rel	; save relative position in chain
+	mov	rd_pcdir_last,cx
 	mov	cl,FCBSHF	; to divide by fcb size
 	shr	bx,cl		; BX = dir offset in cluster
 	jmps	rd_pcdir50	;  now go and find the entry
diff -u -P -r dr70107/drdos/disk.a86 d110721/drdos/disk.a86
--- dr70107/drdos/disk.a86	2004-03-20 18:34:34.000000000 +0000
+++ d110721/drdos/disk.a86	2010-02-17 19:08:08.000000000 +0000
@@ -417,11 +417,11 @@
 	call	set_retry_RF		; Valid to RETRY or FAIL
 	mov	dh,80h			; set top bit - free space not needed
 	call	fdos_DISKINFO		; and make the function call
-;	 jnc	f1B1C1F32_common	; exit using common code
-	 jc	fdos_DI_error		; check if error
-	cmp	dosfat,FAT32		; attempt to use on FAT32 drive?
-	 jne	f1B1C1F32_common	; exit using common code
-	mov	ax,0ffh
+	 jnc	f1B1C1F32_common	; exit using common code
+;	 jc	fdos_DI_error		; check if error
+;	cmp	dosfat,FAT32		; attempt to use on FAT32 drive?
+;	 jne	f1B1C1F32_common	; exit using common code
+;	mov	ax,0ffh
 fdos_DI_error:
 	jmp	fcberror_exit		; exit thru FCB error
 
@@ -595,6 +595,7 @@
 	mov	FD_NAMEOFF,dx		; Initialise Pointer
 	mov	FD_NAMESEG,es
 	mov	FD_ATTRIB,cx		; and attributes
+	mov	FD_LFNSEARCH,0		; do not use FAT+/LFN extensions
 	jmp	fdos_ax_crit
 
 eject
@@ -833,6 +834,8 @@
 	mov	FD_BPBOFF,si		; Segment and Offset of BPB
 	mov	FD_BPBSEG,es
 	mov	FD_DDSCOFF,bp		; Segment and Offset of DDSC
+	mov	FD_SIG1,cx		; signatures for extended function
+	mov	FD_SIG2,dx
 	call	reload_ES
 	mov	FD_DDSCSEG,es
 	jmp	fdos_nocrit
diff -u -P -r dr70107/drdos/dos7.asm d110721/drdos/dos7.asm
--- dr70107/drdos/dos7.asm	2004-07-19 21:17:18.000000000 +0000
+++ d110721/drdos/dos7.asm	2009-02-16 16:10:08.000000000 +0000
@@ -2,7 +2,7 @@
 ;
 ; This file is part of
 ; The DR-DOS/OpenDOS Enhancement Project - http://www.drdosprojects.de
-; Copyright (c) 2002-2004 Udo Kuhnt
+; Copyright (c) 2002-2009 Udo Kuhnt
 
 	include	pcmode.equ
 	include	fdos.equ
@@ -31,8 +31,7 @@
 	 jne	func73_error
 	jmp	func7305		; yes
 func73_error:
-	mov	ax,7300h		; function not supported
-	clc
+	xor	ax,ax			; function not supported
 	ret
 
 ;	*************************************
@@ -51,14 +50,14 @@
 func7302:
 	cmp	cx,EDPB_LEN+2		; enough buffer space for data?
 	 jae	f7302_10
-	mov	ax,18h			; return 18h (bad request structure length)
+	mov	ax,-18h			; return 18h (bad request structure length)
 	stc
 	jmp	error_exit		; no, then exit with error
 f7302_10:
 	xor	dh,dh
 	call	fdos_DISKINFO		; get drive info, ES:BX -> DDSC
 	 jnc	f7302_20
-	mov	ax,0fh			; return 0fh (invalid drive)
+	mov	ax,-0fh			; return 0fh (invalid drive)
 	stc
 	jmp	error_exit		; error if invalid drive
 f7302_20:
@@ -144,7 +143,7 @@
 	mov	es,es:reg_DS[bp]
 	call	get_path_drive
 	 jnc	f7303_10
-	mov	ax,0fh			; return 0fh (invalid drive)
+	mov	ax,-0fh			; return 0fh (invalid drive)
 	stc
 	jmp	error_exit		; error if invalid drive
 f7303_10:
@@ -153,13 +152,13 @@
 	xor	dh,dh
 	call	fdos_DISKINFO		; get drive info, ES:BX -> DDSC
 	 jnc	f7303_20
-	mov	ax,0fh			; return 0fh (invalid drive)
+	mov	ax,-0fh			; return 0fh (invalid drive)
 	stc
 	jmp	error_exit		; error if invalid drive
 f7303_20:
 	cmp	cx,FREED_LEN		; enough buffer space for data?
 	 jbe	f7303_30
-	mov	ax,18h			; return 18h (bad request structure length)
+	mov	ax,-18h			; return 18h (bad request structure length)
 	stc
 	jmp	error_exit		; no, then exit with error
 f7303_30:
diff -u -P -r dr70107/drdos/doshndl.def d110721/drdos/doshndl.def
--- dr70107/drdos/doshndl.def	2003-08-02 22:40:00.000000000 +0000
+++ d110721/drdos/doshndl.def	2005-12-25 13:28:02.000000000 +0000
@@ -81,16 +81,21 @@
 DHNDL_DEVOFF	equ	word ptr 07h		; 07 - offset of device
 DHNDL_DEVSEG	equ	word ptr 09h		; 09 - segment of device
 DHNDL_BLK1	equ	word ptr 0Bh		; 0B - first cluster in file
+						;      (lower 32 bits)
 DHNDL_TIME	equ	word ptr 0Dh		; 0D - file time stamp
 DHNDL_DATE	equ	word ptr 0Fh		; 0F - file date stamp
 DHNDL_SIZE	equ	dword ptr 11h		; 11 - file length
+						;      (lower 32 bits)
 DHNDL_SIZELO	equ	word ptr 11h
 DHNDL_SIZEHI	equ	word ptr 13h
 DHNDL_POS	equ	dword ptr 15h		; 15 - current file position
+						;      (lower 32 bits)
 DHNDL_POSLO	equ	word ptr 15h
 DHNDL_POSHI	equ	word ptr 17h
 DHNDL_IDX	equ	word ptr 19h		; 19 - relative cluster within file of last read
+						;      (lower 32 bits)
 DHNDL_DBLK	equ	word ptr 1Bh		; 1B - cluster # of dir entry
+						;      (lower 32 bits)
 DHNDL_DCNTHI	equ	byte ptr 1Eh		; 1E - dir offset # within cluster
 DHNDL_DCNTLO	equ	byte ptr 1Fh		; 1F - dir offset # within cluster
 DHNDL_NAME	equ	byte ptr 20h		; 20 - File/Device Name
@@ -100,12 +105,25 @@
 DHNDL_PSP	equ	word ptr 31h		; 31 - Owning PSP
 DHNDL_SHARE	equ	word ptr 33h		; 33 - Offset of sharing record
 DHNDL_BLK	equ	word ptr 35h		; 35 - absolute cluster of last read
+						;      (lower 32 bits)
 						; 37 - dword reserved for IFS
-DHNDL_BLK1H	equ	word ptr 3Bh
-DHNDL_IDXH	equ	word ptr 3Dh
-DHNDL_DBLKH	equ	word ptr 3Fh
-DHNDL_BLKH	equ	word ptr 41h
-DHNDL_LEN	equ	43h
+DHNDL_BLK1H	equ	word ptr 3Bh		; 3B - first cluster in file
+						;      (higher 32 bits)
+DHNDL_IDXH	equ	word ptr 3Dh		; 3D - relative cluster within file of last read
+						;      (higher 32 bits)
+DHNDL_DBLKH	equ	word ptr 3Fh		; 3F - cluster # of dir entry
+						;      (higher 32 bits)
+DHNDL_BLKH	equ	word ptr 41h		; 41 - absolute cluster of last read
+						;      (higher 32 bits)
+DHNDL_SIZEX	equ	dword ptr 43h		; 43 - file length
+						;      (higher 32 bits)
+DHNDL_SIZEXLO	equ	word ptr 43h
+DHNDL_SIZEXHI	equ	word ptr 45h
+DHNDL_POSX	equ	dword ptr 47h		; 47 - current file position
+						;      (higher 32 bits)
+DHNDL_POSXLO	equ	word ptr 47h
+DHNDL_POSXHI	equ	word ptr 49h
+DHNDL_LEN	equ	4Bh
 
 ; With DOS 3 structures _DBLK is a 16 bit
 
diff -u -P -r dr70107/drdos/drdos.inp d110721/drdos/drdos.inp
--- dr70107/drdos/drdos.inp	2005-01-15 18:26:10.000000000 +0000
+++ d110721/drdos/drdos.inp	2005-06-07 02:24:12.000000000 +0000
@@ -1,4 +1,5 @@
 drdos.tmp=header.obj,pcmif.obj,cio.obj,disk.obj,ioctl.obj,misc.obj,support.obj,
 dosmem.obj,error.obj,process.obj,network.obj,int2f.obj,fdos.obj,cdevio.obj,fioctl.obj,
-fcbs.obj,redir.obj,dirs.obj,buffers.obj,bdevio.obj,cmdline.obj,history.obj,dos7.obj
+fcbs.obj,redir.obj,dirs.obj,buffers.obj,bdevio.obj,cmdline.obj,history.obj,
+dos7.obj,lfn.obj
 [map, data[origin[0000]]]
diff -u -P -r dr70107/drdos/fdos.a86 d110721/drdos/fdos.a86
--- dr70107/drdos/fdos.a86	2004-01-25 20:31:30.000000000 +0000
+++ d110721/drdos/fdos.a86	2009-03-25 20:52:30.000000000 +0000
@@ -367,7 +367,8 @@
 	extrn	update_fat:NEAR
 	extrn	write_dev:near		; write to character device
 	extrn	zeroblk:near		; fill cluster with 0's
-	
+	extrn	is_lfn:near		; check if long filename entry
+	extrn	del_lfn:near		; delete long filenames
 
 eject
 	public	bpb2ddsc		; build DDSC from a BPB
@@ -384,6 +385,8 @@
 	Public	unparse
 	public	update_dir_fat		; flush DIR then FAT to disk
 	public	get_path_drive		; get drive number for given path
+	public	path_prep
+	public	check_no_wild
 
 	public	fdos_getdpb	; 0-disk information
 	public	fdos_mkdir	; 1-make directory
diff -u -P -r dr70107/drdos/fdos.def d110721/drdos/fdos.def
--- dr70107/drdos/fdos.def	1997-04-16 17:15:14.000000000 +0000
+++ d110721/drdos/fdos.def	2009-02-28 19:22:28.000000000 +0000
@@ -111,6 +111,8 @@
 FD_BPBSEG	equ	fdos_data + 4
 FD_DDSCOFF	equ	fdos_data + 6
 FD_DDSCSEG	equ	fdos_data + 8
+FD_SIG1		equ	fdos_data + 10
+FD_SIG2		equ	fdos_data + 12
 
 FD_IOCTLFUNC	equ	fdos_data + 4
 FD_IOCTLSTAT	equ	fdos_data + 6
@@ -124,3 +126,4 @@
 FD_DDIO_DMAOFF	equ	fdos_data + 10
 FD_DDIO_DMASEG	equ	fdos_data + 12
 
+FD_LFNSEARCH	equ	fdos_data + 10
diff -u -P -r dr70107/drdos/fdos.equ d110721/drdos/fdos.equ
--- dr70107/drdos/fdos.equ	2004-02-27 14:10:22.000000000 +0000
+++ d110721/drdos/fdos.equ	2005-12-27 15:55:16.000000000 +0000
@@ -194,6 +194,7 @@
   DA_DELWATCH	equ	80h		; 0x88 - return pending delete files
   DA_FIXED	equ	11011000b	; can't CHMOD label, dir, unused bits
   DA_CHANGE	equ	not DA_FIXED	; all others are changeable
+  DA_LFN	equ	DA_RO+DA_HIDDEN+DA_SYSTEM+DA_VOLUME
 
 ;DATTS2		equ	12		;CP/M attributes
 ;					; 0x80 - f1' modify default open rules
@@ -204,6 +205,7 @@
 ;					; 0x04 - DELETE password
 ;					; 0x02 - WRITE password
 ;					; 0x01 - READ password
+DSIZEX		equ	12		;file size extension for FAT+ (bit 0-2 and 5-7)
 DUNDEL		equ	13		;1st letter of deleted file
 DPWD		equ	word ptr 14	;16-bit password hash code
 DMODTIME    	equ	word ptr 16	;delwatch time (hhhhhmmmmmmsssss)
diff -u -P -r dr70107/drdos/fioctl.a86 d110721/drdos/fioctl.a86
--- dr70107/drdos/fioctl.a86	1997-04-16 15:46:16.000000000 +0000
+++ d110721/drdos/fioctl.a86	2005-12-26 14:06:14.000000000 +0000
@@ -351,6 +351,8 @@
 ioctl6_10:				; disk files/network devices
 	push	es:DHNDL_POSLO[bx]	; save current position in file
 	push	es:DHNDL_POSHI[bx]	;  so we can read ahead
+	push	es:DHNDL_POSXLO[bx]
+	push	es:DHNDL_POSXHI[bx]
 	push	es
 	push	bx			; save DHNDL_ too..
 	push	bp			; save stack frame
@@ -382,7 +384,9 @@
 	pop	bp			; recover stack frame
 	pop	bx			; rewind DHNDL_POS to where
 	pop	es
-	pop	es:DHNDL_POSHI[bx]	;  it was before we started
+	pop	es:DHNDL_POSXHI[bx]	;  it was before we started
+	pop	es:DHNDL_POSXLO[bx]
+	pop	es:DHNDL_POSHI[bx]
 	pop	es:DHNDL_POSLO[bx]
 	mov	ax,1a00h		; assume not ready
 	 jcxz	ioctl6_40
diff -u -P -r dr70107/drdos/funcs.fdo d110721/drdos/funcs.fdo
--- dr70107/drdos/funcs.fdo	2004-08-13 14:19:50.000000000 +0000
+++ d110721/drdos/funcs.fdo	2009-07-06 00:19:52.000000000 +0000
@@ -657,8 +657,12 @@
 	 jz	open8			; bail out if not found
 	mov	al,byte ptr fdos_pb+8	; check requested attributes
 if PASSWORD
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	open1			; yes, then ignore passwords
 	cmp	word ptr DPWD[bx],0
 	 je	open1
+	test	DPWM[bx],0fffh		; no access rights set?
+	 jz	open1			; then assume it is unprotected
 	or	al,DA_HIDDEN
 open1:
 endif
@@ -768,16 +772,27 @@
 	call	local_disk		; get MXdisk, switch stack
 	call	verify_handle		; check if legal file handle
 	mov	cx,fdos_pb+8		; get requested transfer length
-	mov	ax,es:DHNDL_POSLO[bx]	; If we get an error we want to have
-	mov	dx,es:DHNDL_POSHI[bx]	; xfer len adjusted for EOF (CopyIIpc)
-	sub	ax,es:DHNDL_SIZELO[bx]	; are we beyond EOF ?
-	sbb	dx,es:DHNDL_SIZEHI[bx]
+;	mov	ax,es:DHNDL_POSLO[bx]	; If we get an error we want to have
+;	mov	dx,es:DHNDL_POSHI[bx]	; xfer len adjusted for EOF (CopyIIpc)
+;	sub	ax,es:DHNDL_SIZELO[bx]	; are we beyond EOF ?
+;	sbb	dx,es:DHNDL_SIZEHI[bx]
+	mov	ax,es:DHNDL_POSLO[bx]
+	sub	ax,es:DHNDL_SIZELO[bx]
+	mov	dx,ax
+	mov	ax,es:DHNDL_POSHI[bx]
+	sbb	ax,es:DHNDL_SIZEHI[bx]
+	mov	ax,es:DHNDL_POSXLO[bx]
+	sbb	ax,es:DHNDL_SIZEXLO[bx]
+	mov	ax,es:DHNDL_POSXHI[bx]
+	sbb	ax,es:DHNDL_SIZEXHI[bx]
 ;	 jb	read2			; beyond EOF already, no action required
 ;	 ja	read2			; more the 64K to go, no problems
 	 jnz	read2
-	cmp	ax,cx			; do we want more than there is?
+;	cmp	ax,cx			; do we want more than there is?
+	cmp	dx,cx			; do we want more than there is?
 	 jae	read2			; yes, shorten the fdos_pb count
-	sub	fdos_pb+8,ax		;  in case of a critical error
+;	sub	fdos_pb+8,ax		;  in case of a critical error
+	sub	fdos_pb+8,dx		;  in case of a critical error
 read2:
 	mov	fdrwflg,1		; we're reading
 	les	di,dword ptr fdos_pb+4	; get disk transfer address
@@ -916,8 +931,12 @@
 ;
 	mov	al,byte ptr fdos_pb+8	; check attributes
 if PASSWORD
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	unlink_attribs10	; yes, then ignore passwords
 	cmp	word ptr DPWD[bx],0
 	 je	unlink_attribs10
+	test	DPWM[bx],0fffh		; no access rights set?
+	 jz	unlink_attribs10	; then assume it is unprotected
 	or	al,DA_HIDDEN
 unlink_attribs10:
 endif
@@ -951,7 +970,10 @@
 	call	vfy_dhndl_ptr		; check file handle #
 	call	redir_dhndl_offer
 	test	es:DHNDL_ATTR[bx],DHAT_DEV
-	 jnz	lseek_dev		; skip if character device
+;	 jnz	lseek_dev		; skip if character device
+	 jz	lseek01
+	jmp	lseek_dev		; skip if character device
+lseek01:
 	call	local_disk		; get MXdisk, switch stack
 	call	check_handle		; check if legal file handle
 	mov	ax,fdos_pb+4		; get 32-bit file offset
@@ -968,18 +990,62 @@
 	ret				; return error code
 
 lseek2:					; seek mode 1: relative to position
-	add	ax,es:DHNDL_POSLO[bx]
-	adc	dx,es:DHNDL_POSHI[bx]
-	jmps	lseek4			; update new position
+;	add	ax,es:DHNDL_POSLO[bx]
+;	adc	dx,es:DHNDL_POSHI[bx]
+	add	es:DHNDL_POSLO[bx],ax
+	adc	es:DHNDL_POSHI[bx],dx
+	adc	es:DHNDL_POSXLO[bx],0
+	adc	es:DHNDL_POSXHI[bx],0
+	test	dx,8000h		; negative offset?
+	 jz	lseek2a
+	add	es:DHNDL_POSXLO[bx],0ffffh; yes, then extend the sign to 64-bit
+	adc	es:DHNDL_POSXHI[bx],0ffffh
+lseek2a:
+	jmps	lseek4a			; update new position
 
 lseek3:					; seek mode 2: relative to end
-	add	ax,es:DHNDL_SIZELO[bx]
-	adc	dx,es:DHNDL_SIZEHI[bx]	; add file size + offset
+;	add	ax,es:DHNDL_SIZELO[bx]
+;	adc	dx,es:DHNDL_SIZEHI[bx]	; add file size + offset
+	push	ax
+	mov	ax,es:DHNDL_SIZELO[bx]
+	mov	es:DHNDL_POSLO[bx],ax
+	mov	ax,es:DHNDL_SIZEHI[bx]
+	mov	es:DHNDL_POSHI[bx],ax
+	mov	ax,es:DHNDL_SIZEXLO[bx]
+	mov	es:DHNDL_POSXLO[bx],ax
+	mov	ax,es:DHNDL_SIZEXHI[bx]
+	mov	es:DHNDL_POSXHI[bx],ax
+	pop	ax
+	jmps	lseek2
 lseek4:					; seek mode 0: set absolute position
 	mov	es:DHNDL_POSLO[bx],ax
 	mov	es:DHNDL_POSHI[bx],dx
 	mov	fdos_pb+4,ax		; set return values
 	mov	fdos_pb+6,dx
+	mov	es:DHNDL_POSXLO[bx],cx
+	mov	es:DHNDL_POSXHI[bx],cx
+	ret
+lseek4a:
+	cmp	es:DHNDL_POSXLO[bx],0
+	 jne	lseek4b
+	cmp	es:DHNDL_POSXHI[bx],0
+	 je	lseek4d
+lseek4b:
+	cmp	es:DHNDL_POSXLO[bx],0ffffh
+	 jne	lseek4c
+	cmp	es:DHNDL_POSXHI[bx],0ffffh
+	 je	lseek4d
+lseek4c:
+	xor	ax,ax
+	dec	ax
+	mov	dx,ax
+	jmps	lseek4e
+lseek4d:
+	mov	ax,es:DHNDL_POSLO[bx]
+	mov	dx,es:DHNDL_POSHI[bx]
+lseek4e:
+	mov	fdos_pb+4,ax		; set return values
+	mov	fdos_pb+6,dx
 	ret
 
 lseek_dev:				; jump here if character device
@@ -1146,7 +1212,7 @@
 chmod13:
 	xor	DATTS[bx],dl		; set new attributes
 if PASSWORD
-	jmps	chmod90
+	jmp	chmod90
 else
 	jmp	update_dir		; update directory
 endif
@@ -1172,7 +1238,11 @@
 	pop	dx
 	pop	cx
 	pop	bx
+	xor	ax,ax
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	chmod25			; then assume no password set
 	mov	ax,DPWD[bx]		; assume get encrypted password
+chmod25:
 	cmp	cl,4			;  was it ?
 	 jne	chmod50
 endif					; yes, return encrypted password
@@ -1201,8 +1271,11 @@
 	call	hash_pwd		;  compute password hash code
 chmod60:
 	pop	ds
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	chmod65			; then passwords do not apply
 	or	DATTS[bx],DA_HIDDEN	; file will be hidden
 	mov	DPWD[bx],ax		; set new file password
+chmod65:
 	test	ax,ax			; null password?
 	 jnz	chmod70
 	xor	dx,dx			; can't be protected....
@@ -1644,8 +1717,12 @@
 	 jz	search_next_err		; if not found
 	mov	al,attributes		; get attributes that we support
 if PASSWORD
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	search_n20		; yes, then ignore passwords
 	cmp	word ptr DPWD[bx],0	; does it have a password?
 	 jz	search_n20		; skip if not
+	test	DPWM[bx],0fffh		; no access rights set?
+	 jz	search_n20		; then assume it is unprotected
 	or	al,DA_HIDDEN		; else include hidden files
 search_n20:
 endif
@@ -1705,6 +1782,25 @@
 	inc	si
 	inc	si			; skip starting cluster
 	movsw ! movsw			; return file size
+	mov	al,DSIZEX[bx]		; compute extended file size
+	mov	ah,al
+	and	al,111b
+	and	ah,11100000b
+	shr	ah,1
+	shr	ah,1
+	test	fdos_pb+10,1		; use FAT+/LFN extensions?
+	 jz	search_n38		; no, return 32bit file size
+	or	al,ah
+	mov	es:[di]-11,al		; return extended file size
+	jmps	search_n40
+search_n38:
+	or	al,ah
+	 je	search_n40		; if below 4 GB then skip
+	sub	di,4			; else go back to file size field
+	xor	ax,ax			; AX=FFFFh
+	dec	ax
+	stosw ! stosw			; report 4 GB - 1
+search_n40:
 	jmp	unparse			; return file name
 
 eject
@@ -1760,6 +1856,17 @@
 	xchg	ax,di			; DI -> directory entry in buffer
 	or	DATTS[di],DA_ARCHIVE	; mark file as modified
 ;;;	call	timestamp_dhndl		; record the current time
+	mov	ax,es:DHNDL_SIZEXLO[bx]	; get extended 6 bits for FAT+
+	mov	ah,al			; shift the bits in place
+	and	al,00000111b
+	and	ah,00111000b
+	shl	ah,1
+	shl	ah,1
+	or	ah,al
+	mov	al,DSIZEX[di]		; get original DSIZEX byte
+	and	al,00011000b		; save bits used WinNT
+	or	al,ah			; combine them with FAT+ bits
+	mov	DSIZEX[di],al		; and store them again
 	cmp	dosfat,FAT32		; is this a FAT32 file system?
 	 jne	file_update05		; no, then skip this entry
 	mov	ax,es:DHNDL_BLK1H[bx]	; get high word of 1st block in file
@@ -1888,11 +1995,20 @@
 ;-----------
 	push	ds
 	mov	si,2[bp]		; SI -> parameter block
+	mov	cx,10[si]		; signatures for extended function
+	mov	dx,12[si]
 	les	di,6[si]		; ES:DI -> DDSC
 	lds	si,2[si]		; DS:SI -> BPB
 
-;	call	bpb2ddsc		; convert BPB to DDSC
+	cmp	cx,4558h		; does the first signature match?
+	 jne	mkddsc_noext		; no, execute normal function
+	cmp	dx,4152h		; does the second signature match?
+	 jne	mkddsc_noext		; no, proceed with normal function
+	call	bpb2ddsc		; convert BPB to DDSC
+	jmps	mkddsc_ext
+mkddsc_noext:
 	call	bpb2ddsc_noext		; convert BPB to normal DDSC (without extended drive info)
+mkddsc_ext:
 	xor	bx,bx			; no error
 	pop	ds			; restore segment register
 	ret
@@ -2022,6 +2138,13 @@
 	lodsw				; get high word
 	mov	es:word ptr DDSC_FSROOT+2[di],ax
 	lodsw				; get sector number of file system info sector
+	cmp	ax,es:DDSC_FATADDR[di]	; is the info sector below the FAT?
+	 jae	bpb2ddsc41a		; no, it must be invalid
+	cmp	ax,0			; same as boot sector?
+	 jnz	bpb2ddsc41b		; if yes, that does not make sense
+bpb2ddsc41a:
+	mov	ax,0ffffh		; so just assume there is none
+bpb2ddsc41b:
 	mov	es:DDSC_FSINFO[di],ax
 	lodsw				; get sector number of backup boot sector
 	mov	es:DDSC_BOOTBAK[di],ax
@@ -2173,7 +2296,10 @@
 	 je	fdos_expand10
 	mov	bx,ED_FILE
     test    al,al           
-	 jz	fdos_expand60
+;	 jz	fdos_expand60
+	 jnz	fdos_expand05
+	jmp	fdos_expand60
+fdos_expand05:
 	call	toupper			; work on premise we have drive
 	sub	al,'A'			; specified in relative name
 	sub	ah,':'			; did we have ?
@@ -2182,7 +2308,10 @@
 	mov	al,current_dsk		; use current drive
 fdos_expand20:
 	cmp	al,last_drv		; is it a legal drive
-	 jae	fdos_expand50
+;	 jae	fdos_expand50
+	 jb	fdos_expand21
+	jmp	fdos_expand50
+fdos_expand21:
 
 ; we should check for a media change so select_logical_drv seems to be
 ; a better solution
@@ -2194,7 +2323,10 @@
 	les	bx,current_ldt
 
 	test	es:LDT_FLAGS[bx],LFLG_PHYSICAL
-	 jz	fdos_expand50		; make sure it's a valid drive
+;	 jz	fdos_expand50		; make sure it's a valid drive
+	 jnz	fdos_expand22		; make sure it's a valid drive
+	jmp	fdos_expand50
+fdos_expand22:
 	push ss ! pop es
 	mov	di,offset pri_pathname	; build name in pathname buffer
 	lds	si,dword ptr fdos_pb+2
@@ -2209,6 +2341,31 @@
 	call	redir_build_path	; build name from LDT
 	pop	bp
 	 jc	fdos_expand60		; bail out if bad name
+
+	lds	di,ss:current_ldt
+	test	LDT_FLAGS[di],LFLG_NETWRKD+LFLG_PHYSICAL
+	 jz	fdos_expand25
+	test	LDT_FLAGS[di],LFLG_SUBST
+	 jnz	fdos_expand25
+	mov	bx,LDT_ROOTLEN[di]
+	cmp	bx,2
+	 jbe	fdos_expand25
+	mov	si,offset pri_pathname
+	mov	al,LDT_NAME+2[di]
+	mov	ss:[si],al
+	mov	ss:word ptr 1[si],'\:'
+	inc	si
+	inc	si
+	dec	bx
+	dec	bx
+fdos_expand23:
+	inc	si
+	mov	al,ss:[si+bx]
+	mov	ss:[si],al
+	cmp	al,0
+	 jne	fdos_expand23
+fdos_expand25:
+
 	lds	di,ss:current_ldt	; we need to append a '\' if
 	mov	bx,ds:LDT_ROOTLEN[di]	;  we are at the root
 	test	ds:LDT_FLAGS[di],LFLG_SUBST
@@ -2323,8 +2480,12 @@
 move30:					; same drive for source & destination
 	mov	al,byte ptr fdos_pb+8	; check attributes
 if PASSWORD
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	move31			; yes, then ignore passwords
 	cmp	save_area+DPWD,0
 	 je	move31
+	test	word ptr save_area+DPWM,0fffh	; no access rights set?
+	 jz	move31			; then assume it is unprotected
 	or	al,DA_HIDDEN
 move31:
 endif
@@ -2374,6 +2535,7 @@
 	 jnz	move_access		; so return error if new path
 	call	allocdir		; allocate a directory entry
 move70:
+	call	del_lfn			; make sure no LFN is before it
 	mov	si,offset info_fcb+1	; get pointer to new name
 	mov	di,dirp			; get pointer to directory entry
 	mov	cx,11			; copy new name into buffer
@@ -2392,6 +2554,7 @@
 	mov	cx,HDS_LEN		; so we can get old entry again
 	rep	movsb			;    (time to get rid of it)
 	call	move_seek		; seek the original entry
+	call	del_lfn			; and delete LFN if one exists
 	mov	bx,dirp
 	mov	DNAME[bx],0E5h		; and bye, bye! it goes...
 	call	update_dir		; update the old directory entry
diff -u -P -r dr70107/drdos/header.a86 d110721/drdos/header.a86
--- dr70107/drdos/header.a86	2004-12-12 21:34:46.000000000 +0000
+++ d110721/drdos/header.a86	2007-03-13 15:36:48.000000000 +0000
@@ -287,9 +287,9 @@
 
 msdos_file_tbl	dw	-1		; 00A6 1st HDB entries
 		dw	-1		; Pointer to next Entry (None)
-		dw	4		; Number of Entries
+		dw	3		; Number of Entries
 
-		rb	4*DHNDL_LEN	; Reserve 5 Internal Handles
+		rb	3*DHNDL_LEN	; Reserve 5 Internal Handles
 
 	rb	1fbh - (offset $ - offset dos_data)
 
@@ -528,7 +528,7 @@
 
     org 05ceh - FIXED_DATA_START 
 	Public	current_filepos
-current_filepos	rw	2
+current_filepos	rw	4
 
     org 05f0h - FIXED_DATA_START 
 	Public	prev_int21regs_ptr, prev_int21regs_off, prev_int21regs_seg
diff -u -P -r dr70107/drdos/lfn.asm d110721/drdos/lfn.asm
--- dr70107/drdos/lfn.asm	1970-01-01 00:00:00.000000000 +0000
+++ d110721/drdos/lfn.asm	2009-07-14 15:58:58.000000000 +0000
@@ -0,0 +1,625 @@
+; LFN.ASM - Functions for Long Filename and 64-bit file size support
+;
+; This file is part of
+; The DR-DOS/OpenDOS Enhancement Project - http://www.drdosprojects.de
+; Copyright (c) 2002-2009 Udo Kuhnt
+
+	include	bdos.equ
+	include	fdos.equ
+	include	pcmode.equ
+	include doshndl.def
+	include	lfn.equ
+	include	fdos.def
+	include	mserror.equ
+
+BDOS_CODE	cseg	word
+
+	extrn	rd_pcdir:near
+	extrn	flush_dirbuf:near
+
+;Entry:		DS:BX = pointer to dir entry
+;
+;Exit:		carry flag set if LFN entry
+	Public	is_lfn
+is_lfn:
+	cmp	DATTS[bx],DA_LFN	; attribute combination of LFN entry?
+	 jne	is_lfn10		; no, must something else
+	cmp	word ptr BLOCK1[bx],0	; no cluster chain?
+	 jne	is_lfn10		; perhaps it is a Delwatch entry
+	stc				; it is probably a Long Filename
+	jmps	is_lfn20
+is_lfn10:
+	clc				; no LFN entry
+is_lfn20:
+	ret
+
+	Public	del_lfn
+del_lfn:
+	push	dcnt			; save dir count
+del_lfn10:
+	cmp	dcnt,0			; first entry in dir?
+	 je	del_lfn20		; then no LFN can exist before it
+	dec	dcnt			; point dir count to previous entry
+	dec	dcnt
+	call	rd_pcdir		; read dir entry
+	mov	bx,ax
+	call	is_lfn			; check if it is a long filename
+	 jnc	del_lfn20		; no further LFN entries, done
+	mov	DNAME[bx],0e5h		; else mark this entry as deleted
+	call	flush_dirbuf		; and copy it to the buffer
+	jmps	del_lfn10		; repeat with next entry
+del_lfn20:
+	pop	dcnt			; restore dir count
+	dec	dcnt
+	call	rd_pcdir		; and old dir entry
+	ret
+
+PCM_CODE	cseg	byte
+	extrn	return_AX_CLC:near
+	extrn	vfy_dhndl_ptr_AX:near
+	extrn	check_handle:near
+	extrn	redir_dhndl_offer:near
+	extrn	verify_handle:near
+	extrn	mul32:near
+	extrn	mul64:near
+	extrn	dos_entry:near
+	extrn	fdos_first:near
+	extrn	fdos_next:near
+	extrn	fdos_entry:near
+	extrn	lds_si_dmaptr:near
+	extrn	local_disk:near
+	extrn	path_prep:near
+	extrn	check_no_wild:near
+	extrn	finddfcbf:near
+	extrn	update_dir:near
+
+	Public	func71
+func71:
+	cmp	al,42h			; function 7142h?
+	 je	func7142		; yes
+	cmp	al,43h			; function 7143h?
+	 jne	f71_4e
+	jmp	func7143		; yes
+f71_4e:
+	cmp	al,4eh			; function 714eh?
+	 jne	f71_4f
+	jmp	func714e		; yes
+f71_4f:
+	cmp	al,4fh			; function 714fh?
+	 jne	f71_a1
+	jmp	func714f		; yes
+f71_a1:
+	cmp	al,0a1h			; function 71a1h?
+	 jne	f71_a6
+	jmp	func71a1		; yes
+f71_a6:
+	cmp	al,0a6h			; function 71a6h?
+	 jne	func71_a7
+	jmp	func71a6
+func71_a7:
+	cmp	al,0a7h			; function 71a7h?
+	 jne	func71_error
+	jmp	func71a7		; yes
+func71_error:
+	mov	ax,7100h		; function not supported
+	push	ds
+	lds	bp,int21regs_ptr	; set carry flag
+	or	ds:reg_FLAGS[bp],CARRY_FLAG
+	pop	ds
+	stc
+	ret
+
+func7142:
+	push	ds
+	lds	bp,int21regs_ptr
+	mov	ax,ds:reg_CX[bp]	; AL = original CL
+	pop	ds
+	cmp	al,2			; valid subfunction number?
+	 jbe	f7142_02
+	jmp	f71_error_func
+f7142_02:
+	mov	ax,bx
+	call	vfy_dhndl_ptr_AX_call	; check file handle number
+	 jnc	f7142_handle_ok
+	mov	ax,bx
+	neg	ax
+	jmp	f71_error
+f7142_handle_ok:
+	call	redir_dhndl_offer
+	test	es:DHNDL_ATTR[bx],DHAT_DEV
+	 jz	f7142_05
+	jmp	f7142_dev		; skip if character device
+f7142_05:
+	call	check_handle		; check if valid file handle
+	push	ds
+	lds	bp,int21regs_ptr
+	mov	ax,ds:reg_CX[bp]	; AL = original CL
+	mov	si,ds:reg_DX[bp]	; DS:SI -> QWORD for position offset and result
+	mov	ds,ds:reg_DS[bp]
+	or	al,al
+	 je	f7142_10		; seek from beginning
+	dec	al
+	 je	f7142_20		; seek from current position
+	jmps	f7142_30		; seek from end
+
+f7142_10:				; mode 0: set absolute position
+	mov	ax,[si]			; copy 64-bit offset to position
+	mov	es:DHNDL_POSLO[bx],ax
+	mov	ax,2[si]
+	mov	es:DHNDL_POSHI[bx],ax
+	mov	ax,4[si]
+	mov	es:DHNDL_POSXLO[bx],ax
+	mov	ax,6[si]
+	mov	es:DHNDL_POSXHI[bx],ax
+	jmps	f7142_40
+
+f7142_20:				; mode 1: relative to current position
+	mov	ax,[si]			; add 64-bit offset to position
+	add	ax,es:DHNDL_POSLO[bx]
+	mov	es:DHNDL_POSLO[bx],ax
+	mov	[si],ax			; and store new position as result
+	mov	ax,2[si]
+	adc	ax,es:DHNDL_POSHI[bx]
+	mov	es:DHNDL_POSHI[bx],ax
+	mov	2[si],ax
+	mov	ax,4[si]
+	adc	ax,es:DHNDL_POSXLO[bx]
+	mov	es:DHNDL_POSXLO[bx],ax
+	mov	4[si],ax
+	mov	ax,6[si]
+	adc	ax,es:DHNDL_POSXHI[bx]
+	mov	es:DHNDL_POSXHI[bx],ax
+	mov	6[si],ax
+	jmps	f7142_40
+
+f7142_30:				; mode 2: relative to end of file
+	mov	ax,[si]			; add 64-bit offset to file size
+	add	ax,es:DHNDL_SIZELO[bx]
+	mov	es:DHNDL_POSLO[bx],ax	; and store as new position
+	mov	[si],ax			; and result
+	mov	ax,2[si]
+	adc	ax,es:DHNDL_SIZEHI[bx]
+	mov	es:DHNDL_POSHI[bx],ax
+	mov	2[si],ax
+	mov	ax,4[si]
+	adc	ax,es:DHNDL_SIZEXLO[bx]
+	mov	es:DHNDL_POSXLO[bx],ax
+	mov	4[si],ax
+	mov	ax,6[si]
+	adc	ax,es:DHNDL_SIZEXHI[bx]
+	mov	es:DHNDL_POSXHI[bx],ax
+	mov	6[si],ax
+f7142_40:
+	pop	ds
+	xor	ax,ax
+	call	return_AX_CLC
+	clc
+f7142_dev:
+	ret
+
+func7143:
+	cmp	bl,3			; check subfunction range
+	 je	f7143_10
+	cmp	bl,4
+	 je	f7143_10
+	jmp	f71_error_func
+f7143_10:
+	mov	FD_FUNC,ax		; function number
+	mov	FD_NAMEOFF,dx		; filename
+	mov	FD_NAMESEG,es
+	mov	dx,offset fdos_data	; parameter block
+	push	ds			; set up FDOS stack frame
+	push	dx
+	push	ax
+	push	ax
+	call	local_disk		; make local copy of parameters
+	call	path_prep		; parse path
+	call	check_no_wild		; wildcards not allowed
+	 jnz	f7143_20
+	mov	ax,2			; file not found
+	jmp	f71_error
+f7143_20:
+	call	finddfcbf		; locate dir entry
+	 jnz	f7143_30
+	mov	ax,2			; file not found
+	jmp	f71_error
+f7143_30:
+	les	bp,int21regs_ptr
+	mov	ax,es:reg_BX[bp]
+	cmp	al,3			; subfunction 3?
+	 je	f7143_set_writetime
+f7143_get_writetime:
+	mov	cx,DTIME[bx]		; last write time
+	mov	di,DDATE[bx]		; last write date
+	mov	es:reg_CX[bp],cx
+	mov	es:reg_DI[bp],di
+	jmps	f7143_exit
+f7143_set_writetime:
+	mov	cx,es:reg_CX[bp]	; new last write time
+	mov	di,es:reg_DI[bp]	; new last write date
+	mov	DTIME[bx],cx
+	mov	DDATE[bx],di
+	call	update_dir		; update dir entry
+f7143_exit:
+	xor	ax,ax			; no error
+	jmp	return_AX_CLC
+
+func714e:
+	mov	ax,4eh			; FindFirst
+	xor	ch,ch
+	mov	FD_ATTRIB,cx		; search attributes
+	mov	FD_NAMEOFF,dx		; search pattern
+	mov	FD_NAMESEG,es
+	jmps	f714e_entry
+
+func714f:
+	mov	ax,4fh			; FindNext
+f714e_entry:
+	mov	FD_FUNC,ax
+;	mov	FD_LFNSEARCH,1		; use FAT+/LFN extensions
+	mov	fdos_pb+10,1		; use FAT+/LFN extensions
+	push	ds
+	push	ss:dma_segment		; save old DTA
+	push	ss:dma_offset
+	mov	ss:dma_segment,ds
+	lea	di,f714e_dta
+	mov	ss:dma_offset,di
+	mov	dx,offset fdos_data
+	call	fdos_entry		; call FindNext function
+	cmp	ax,ED_LASTERROR		; has an error occurred?
+	 jb	f714f_10		; no
+	pop	ss:dma_offset		; restore old DTA
+	pop	ss:dma_segment
+	pop	ds
+	neg	ax
+	jmp	f71_error
+f714f_10:
+	les	bp,int21regs_ptr	; ES:BP -> initial parameters
+	mov	di,es:reg_DI[bp]
+	push	es:reg_ES[bp]
+	pop	es			; ES:DI -> Find Data buffer
+	call	lds_si_dmaptr		; DS:SI -> DTA
+	add	si,15h			; start at file attribute field
+	lodsb				; file attribute
+	xor	ah,ah
+	stosw
+	xor	ax,ax			; set additional file times to 0
+	stosw
+	stosw
+	stosw
+	stosw
+	stosw
+	stosw
+	stosw
+	stosw
+	stosw
+	movsw				; file time
+	movsw				; file date
+	xor	ax,ax			; zero high dword
+	stosw
+	stosw
+	mov	al,-7[si]		; extended file size
+	stosw
+	xor	ax,ax
+	stosw
+	movsw				; file size low
+	movsw
+	add	di,8			; skip over reserved bytes
+	push	di
+	mov	cx,13
+	repnz	movsb			; copy file name
+	pop	di
+	add	di,260			; start of short name field
+	mov	es:byte ptr [di],0	; no short name
+	pop	ss:dma_offset		; restore old DTA
+	pop	ss:dma_segment
+	pop	ds
+	les	bp,int21regs_ptr
+	xor	ax,ax
+	mov	es:reg_CX[bp],ax	; Unicode conversion flags
+	call	return_AX_CLC		; no error
+	ret
+
+func71a1:
+	call	return_AX_CLC
+	ret
+
+func71a6:
+	mov	ax,bx
+	call	vfy_dhndl_ptr_AX_call	; check file handle number
+	 jnc	f71a6_handle_ok
+	mov	ax,bx
+	neg	ax
+	jmp	f71_error
+f71a6_handle_ok:
+	call	redir_dhndl_offer
+	test	es:DHNDL_ATTR[bx],DHAT_DEV
+	 jnz	f71a6_dev		; skip if character device
+	call	verify_handle		; check if valid file handle
+	push	ds
+	lds	bp,int21regs_ptr	; DS:DI -> buffer for Get File Info structure
+	mov	di,ds:reg_DX[bp]
+	mov	ds,ds:reg_DS[bp]
+	push	ds			; ES:DI -> buffer, DS:BX -> DHNDL
+	push	es
+	pop	ds
+	pop	es
+	xor	ah,ah
+	mov	al,DHNDL_ATTR[bx]	; file attributes
+	stosw
+	xor	ax,ax
+	stosw
+	mov	cx,8
+	rep	stosw			; creation time (0 = unsupported)
+					; last access time (0 = unsupported)
+	push	bx
+	mov	dx,DHNDL_DATE[bx]	; last write time
+	mov	cx,DHNDL_TIME[bx]
+	xor	bx,bx			; 0 milliseconds
+	call	f71a701_entry2
+	pop	bx
+	add	di,8
+	push	ds			; save DS
+	mov	bp,sp			; restore PCM DS
+	mov	ds,2[bp]
+	sub	sp,25			; reserve space on stack
+	mov	bp,sp
+	push	es			; save registers
+	push	bx
+	push	di
+	mov	ax,ss			; ES:DX -> buffer for media info
+	mov	es,ax
+	mov	dx,bp
+	xor	bx,bx			; current drive
+	mov	ax,6900h		; Get Volume Serial Number
+	call	dos_entry
+	pop	di			; restore registers
+	pop	bx
+	pop	es
+	mov	ax,2[bp]		; volume serial number
+	stosw
+	mov	ax,4[bp]
+	stosw
+	add	sp,25			; clean up stack again
+	pop	ds			; restore DS
+	mov	ax,DHNDL_SIZEXLO[bx]	; file size high
+	stosw
+	mov	ax,DHNDL_SIZEXHI[bx]
+	stosw
+	mov	ax,DHNDL_SIZELO[bx]	; file size low
+	stosw
+	mov	ax,DHNDL_SIZEHI[bx]
+	stosw
+	xor	ax,ax
+	inc	ax			; links to file (1)
+	stosw
+	dec	ax
+	stosw
+	stosw				; file identifier
+	stosw
+	stosw
+	stosw
+	pop	ds
+	call	return_AX_CLC
+	clc
+f71a6_dev:
+	ret
+
+func71a7:
+	cmp	bl,01			; sub function 01?
+	 je	f71a701			; yes
+	jmp	f71_error_func
+f71a701:				; Convert DOS time to Windows time
+	call	f71a701_entry
+	xor	ax,ax
+	call	return_AX_CLC
+	clc
+	ret
+
+f71a701_entry:
+	les	bp,int21regs_ptr	; ES:DI -> 64-bit time
+	mov	di,es:REG_DI[bp]
+	mov	es,es:REG_ES[bp]
+f71a701_entry2:
+	mov	bp,sp
+	push	dx			; save date
+	push	cx			; save time
+	xchg	bl,bh
+	xor	bh,bh
+	push	bx
+	cmp	dx,0			; special case - date and time zero
+	 jnz	f71a701_05
+	cmp	cx,0
+	 jnz	f71a701_05
+	xor	ax,ax			; clear buffer
+	cld
+	mov	cx,4
+	rep	stosw
+	sub	di,8
+	jmp	f71a701_80
+f71a701_05:
+	mov	ax,dx
+	and	ax,0fe00h		; bits 9-15 contain the year - 1980
+	mov	cl,9
+	shr	ax,cl
+	add	ax,379			; AX = year - 1601
+	push	ax
+	mov	cx,365
+	mul	cx			; convert to days (without leap days)
+	mov	es:[di],ax		; save to ES:DI
+	mov	es:2[di],dx
+	pop	ax
+	xor	bx,bx			; compute leap days in 400 years
+	xor	dx,dx
+	mov	cx,400
+	div	cx
+	cmp	al,0			; at least 400 years?
+	 jz	f71a701_10		; no
+	mov	bl,97			; 97 leap days
+f71a701_10:
+	mov	ax,dx			; divide remainder by 100
+	mov	cl,100			; to compute leap days in 100 years
+	div	cl
+	cmp	al,3
+	 jne	f71a701_20
+	mov	ch,4
+f71a701_20:
+	push	ax
+	mov	cl,24			; 24 leap days
+	mul	cl
+	add	bl,al
+	pop	ax
+	xchg	ah,al
+	xor	ah,ah			; divide remainder by 4
+	mov	cl,4			; to compute remaining leap days
+	div	cl
+	cmp	al,24
+	 jne	f71a701_30
+	or	ch,2
+f71a701_30:
+	add	bl,al			; remaining leap days in century
+	cmp	ah,3
+	 jne	f71a701_40
+	or	ch,1
+f71a701_40:
+	xor	ax,ax			; add leap days
+	mov	al,bl
+	add	es:[di],ax
+	adc	es:word ptr 2[di],0
+	mov	ax,-2[bp]		; restore date
+	and	ax,1e0h			; bits 5-8 contain the month
+	mov	cl,5
+	shr	ax,cl
+	mov	bx,ax
+	xor	si,si
+	inc	si
+	xor	dx,dx
+	xor	ax,ax
+f71a701_50:
+	cmp	si,bx
+	 je	f71a701_60
+	mov	dl,cs:ndays[si]
+	add	ax,dx
+	inc	si
+	jmps	f71a701_50
+f71a701_60:
+	cmp	bx,2			; has February already passed?
+	 ja	f71a701_70		; no
+	test	ch,1			; is the year a leap year?
+	 jz	f71a701_70		; no
+	cmp	ch,3			; 100/400-years rule
+	 je	f71a701_70		; 100 but not 400, no leap year
+	inc	ax			; yes, add one leap day
+f71a701_70:
+	mov	dx,-2[bp]		; restore date
+	and	dx,1fh			; bits 0-4 contain the days
+	add	ax,dx			; AX = days in year
+	dec	ax			; minus one for the first day in 1601
+	add	es:[di],ax		; date converted to days
+	adc	es:word ptr 2[di],0
+
+	push	es:word ptr 2[di]	; number of days
+	push	es:word ptr [di]
+	xor	ax,ax
+	push	ax
+	mov	ax,43200		; 2-seconds per day
+	push	ax
+	sub	sp,8			; reserve space on stack
+	call	mul32			; convert to 2-seconds
+	pop	es:word ptr [di]	; save subtotal
+	pop	es:word ptr 2[di]
+	pop	es:word ptr 4[di]
+	pop	es:word ptr 6[di]
+	add	sp,8			; clean up stack again
+	mov	ax,-4[bp]		; restore time
+	and	ax,0f800h		; bits 11-15 contain the hours
+	mov	cl,11
+	shr	ax,cl
+	mov	cx,1800
+	mul	cx			; convert to 2-seconds
+	add	es:[di],ax		; and add subtotal
+	adc	es:2[di],dx
+	adc	es:word ptr 4[di],0
+	adc	es:word ptr 6[di],0
+	mov	ax,-4[bp]		; restore time
+	and	ax,7e0h			; bits 5-10 contain the minutes
+	mov	cl,5
+	shr	ax,cl
+	mov	cl,30
+	mul	cl			; convert to 2-seconds
+	add	es:[di],ax		; and add subtotal
+	adc	es:2[di],dx
+	adc	es:word ptr 4[di],0
+	adc	es:word ptr 6[di],0
+	mov	ax,-4[bp]		; restore time
+	and	ax,1fh			; bits 0-4 contain the 2-seconds
+	add	es:[di],ax		; and add subtotal
+	adc	es:2[di],dx
+	adc	es:word ptr 4[di],0
+	adc	es:word ptr 6[di],0
+f71a701_80:
+	push	es:word ptr 6[di]	; number of 2-seconds
+	push	es:word ptr 4[di]
+	push	es:word ptr 2[di]
+	push	es:word ptr [di]
+	xor	ax,ax
+	push	ax
+	push	ax
+	mov	ax,131h			; 1312d00h = 20000000 100-nanoseconds
+	push	ax
+	mov	ax,2d00h
+	push	ax
+	sub	sp,16			; reserve space on stack
+	call	mul64			; convert to 100-nanoseconds
+	pop	es:word ptr [di]	; save subtotal
+	pop	es:word ptr 2[di]
+	pop	es:word ptr 4[di]
+	pop	es:word ptr 6[di]
+	add	sp,24			; clean up stack again
+	xor	ax,ax			; centiseconds
+	push	ax
+	push	word ptr -6[bp]
+	mov	ax,1			; 186A0h = 100000 100-nanoseconds
+	push	ax
+	mov	ax,86a0h
+	push	ax
+	sub	sp,8			; reserve space on stack
+	call	mul32
+	pop	ax
+	pop	dx
+	add	sp,12			; clean up stack again
+	add	es:[di],ax		; and add to result
+	adc	es:2[di],dx
+	adc	es:word ptr 4[di],0
+	adc	es:word ptr 6[di],0
+	add	sp,6
+	ret
+
+ndays		db	31,28,31,30,31,30,31,31,30,31,30,31
+
+vfy_dhndl_ptr_AX_call:
+	call	vfy_dhndl_ptr_AX	; setup stack for vfy_dhndl_ptr_AX
+	ret
+
+f71_error_func:
+	mov	ax,1			; invalid function number
+
+f71_error:
+	les	bp,int21regs_ptr
+	mov	es:reg_AX[bp],ax	; return error code
+	or	es:reg_FLAGS[bp],CARRY_FLAG ; set carry flag
+	stc
+	ret
+
+BDOS_DATA	dseg	word
+
+	extrn	dcnt:word
+	extrn	fdos_pb:word
+
+f714e_dta	rb	43
+
+PCMODE_DATA	dseg	word
+
+	extrn	int21regs_ptr:dword
+	extrn	dma_segment:word
+	extrn	dma_offset:word
diff -u -P -r dr70107/drdos/lfn.equ d110721/drdos/lfn.equ
--- dr70107/drdos/lfn.equ	1970-01-01 00:00:00.000000000 +0000
+++ d110721/drdos/lfn.equ	2006-03-18 11:33:08.000000000 +0000
@@ -0,0 +1,17 @@
+; LFN.EQU - Definitions for Long Filename and 64-bit file size support
+;
+; This file is part of
+; The DR-DOS/OpenDOS Enhancement Project - http://www.drdosprojects.de
+; Copyright (c) 2002-2006 Udo Kuhnt
+
+FINFO_ATTR	equ	dword ptr 00h	; file attributes
+FINFO_CREAT_T	equ	dword ptr 04h	; creation time (64-bit)
+FINFO_ACCESS_T	equ	dword ptr 0ch	; last access time (64-bit)
+FINFO_WRITE_T	equ	dword ptr 14h	; last write time (64-bit)
+FINFO_SERNUM	equ	dword ptr 1ch	; volume serial number
+FINFO_SIZEH	equ	dword ptr 20h	; file size (higher 32 bits)
+FINFO_SIZE	equ	dword ptr 24h	; file size (lower 32 bits)
+FINFO_LINKS	equ	dword ptr 28h	; number of links to file
+FINFO_IDH	equ	dword ptr 2ch	; file identifier (higher 32 bits)
+FINFO_ID	equ	dword ptr 30h	; file identifier (lower 32 bits)
+FINFO_LEN	equ	34h		; length of Get File Info structure
diff -u -P -r dr70107/drdos/make.bat d110721/drdos/make.bat
--- dr70107/drdos/make.bat	2005-01-15 18:25:38.000000000 +0000
+++ d110721/drdos/make.bat	2005-06-07 02:18:20.000000000 +0000
@@ -84,6 +84,9 @@
 %LOCTOOLS%\rasm_sh %LOCTOOLS%\rasm86.exe . .\dos7.asm .\bin\dos7.obj
 IF ERRORLEVEL 1 GOTO FAILED
 
+%LOCTOOLS%\rasm_sh %LOCTOOLS%\rasm86.exe . .\lfn.asm .\bin\lfn.obj
+IF ERRORLEVEL 1 GOTO FAILED
+
 copy drdos.inp .\BIN
 CD .\BIN
 ..\%LOCTOOLS%\linkcmd.exe drdos[i]
diff -u -P -r dr70107/drdos/pcmif.a86 d110721/drdos/pcmif.a86
--- dr70107/drdos/pcmif.a86	2004-07-14 20:36:46.000000000 +0000
+++ d110721/drdos/pcmif.a86	2006-01-05 16:24:08.000000000 +0000
@@ -907,7 +907,7 @@
 	extrn	func5C:near, func5D:near, func5E:near, func5F:near
 	extrn	func60:near, func62:near, func63:near, func65:near
 	extrn	func66:near, func67:near, func68:near, func69:near
-	extrn	func6C:near, func73:near
+	extrn	func6C:near, func71:near, func73:near
 
 PCM_RODATA	CSEG	WORD		
 	Public	pcmode_ft, pcmode_ftl
@@ -1025,7 +1025,7 @@
 	dw	ms_zero_AL		; (6E) Unused DOS function (AL = 0)
 	dw	ms_zero_AL		; (6F) Unused DOS function (AL = 0)
 	dw	ms_zero_AL		; (70) Unused DOS function (AL = 0)
-	dw	ms_zero_AL		; (71) Unused DOS function (AL = 0)
+	dw	func71			; (71) LFN and 64-bit file functions
 	dw	ms_zero_AL		; (72) Unused DOS function (AL = 0)
 	dw	func73			; (73) DOS 7 FAT32 functions
 pcmode_ftl	equ	(offset $ - offset pcmode_ft)/2
diff -u -P -r dr70107/drdos/redir.a86 d110721/drdos/redir.a86
--- dr70107/drdos/redir.a86	2003-08-02 23:02:08.000000000 +0000
+++ d110721/drdos/redir.a86	2009-07-15 00:34:22.000000000 +0000
@@ -141,6 +141,10 @@
 	mov	word ptr current_filepos,ax
 	mov	ax,es:word ptr DHNDL_POS+2[bx]
 	mov	word ptr current_filepos+2,ax
+	mov	ax,es:word ptr DHNDL_POSX[bx]
+	mov	word ptr current_filepos+4,ax
+	mov	ax,es:word ptr DHNDL_POSX+2[bx]
+	mov	word ptr current_filepos+6,ax
 	pop	ds
 	jmps	redir_accept		; now we can process the call
 
@@ -466,10 +470,12 @@
 	 ja	build_remote_path30	; return "invalid drive" if error
 	xchg	ax,dx			; DL = ASCIIZ supplied drive
 	lodsw				; get possible '\\'
+	jmps	build_remote_path15
 build_remote_path10:
 	mov	ss:word ptr current_ldt,0ffffh
 	call	check_dslash		; is it "\\"
 	 je	build_remote_path20		; if so forget about the drive #
+build_remote_path15:
 	call	isremote		; test if drive DL is remote
 if JOIN
 	 jb	build_remote_path30	; return "invalid drive" if JOINed
@@ -936,13 +942,41 @@
 	ret
 
 redir_lseek10:				; seek mode 1: relative to position
-	add	dx,es:DHNDL_POSLO[di]	; add position + offset
-	adc	cx,es:DHNDL_POSHI[di]
-;	jmps	redir_lseek20
+;	add	dx,es:DHNDL_POSLO[di]	; add position + offset
+;	adc	cx,es:DHNDL_POSHI[di]
+	add	es:DHNDL_POSLO[di],dx
+	adc	es:DHNDL_POSHI[di],cx
+	adc	es:DHNDL_POSXLO[di],0
+	adc	es:DHNDL_POSXHI[di],0
+	test	cx,8000h		; negative offset?
+	 jz	redir_lseek12
+	add	es:DHNDL_POSXLO[di],0ffffh; yes, then extend the sign to 64-bit
+	adc	es:DHNDL_POSXHI[di],0ffffh
+redir_lseek12:
+	cmp	es:DHNDL_POSXLO[di],0
+	 jne	redir_lseek15
+	cmp	es:DHNDL_POSXHI[di],0
+	 je	redir_lseek17
+redir_lseek15:
+	cmp	es:DHNDL_POSXLO[di],0ffffh
+	 jne	redir_lseek16
+	cmp	es:DHNDL_POSXHI[di],0ffffh
+	 je	redir_lseek17
+redir_lseek16:
+	xor	dx,dx
+	dec	dx
+	mov	cx,dx
+	jmps	redir_lseek90
+redir_lseek17:
+	mov	dx,es:DHNDL_POSLO[di]
+	mov	cx,es:DHNDL_POSHI[di]
+	jmps	redir_lseek90
 
 redir_lseek20:				; seek mode 0: set absolute position
 	mov	es:DHNDL_POSLO[di],dx	; set new file offset
 	mov	es:DHNDL_POSHI[di],cx	; SI = error code/0 at this point
+	mov	es:DHNDL_POSXLO[di],ax
+	mov	es:DHNDL_POSXHI[di],ax
 ;	jmps	redir_lseek90
 
 redir_lseek90:
@@ -970,6 +1004,7 @@
 redir_lseek40:
 	add	dx,es:DHNDL_SIZELO[di]	; add file size + offset
 	adc	cx,es:DHNDL_SIZEHI[di]
+	xor	ax,ax
 	jmps	redir_lseek20
 
 
diff -u -P -r dr70107/drdos/utils.fdo d110721/drdos/utils.fdo
--- dr70107/drdos/utils.fdo	2005-01-24 17:30:26.000000000 +0000
+++ d110721/drdos/utils.fdo	2011-07-21 18:31:52.000000000 +0000
@@ -368,6 +368,7 @@
 	push	es
 	call	path_prep_root		; fake a '.' entry for the root
 	pop	es
+path_prep_cont05:
 	lods	es:al			; get next char
 	dec	si			; forget we looked
 	test	al,al			; if just a '\' stop now
@@ -375,11 +376,13 @@
 	 jnz	path_prep_cont10
 	 jmp	path_prep_done
 path_prep_cont10:
-    call    check_slash     
+	call	check_slash     
 	 jne	path_prep_next		;  otherwise start processing from root
-	mov	ax,ED_ACCESS		; get correct error code
-	stc				;  and return if \\
-	ret
+	lods	es:al
+	jmps	path_prep_cont05
+;	mov	ax,ED_ACCESS		; get correct error code
+;	stc				;  and return if \\
+;	ret
 
 path_prep_curdir:
 ; We need to select the current directory as a start for our operations
@@ -499,7 +502,11 @@
 	pop	fdos_hds_root
 	pop	fdos_hds_root+2
 	 jz	path_prep_error		; (shouldn't happen)
+	xor	ax,ax
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	path_prep_done15	; then assume no password set
 	mov	ax,DPWD[bx]		; get password hash code from entry
+path_prep_done15:
 	mov	local_password,ax	; ensure we can get back down
 	lea	si,DNAME[bx]		; point to it's name
 	mov	cx,11
@@ -835,6 +842,9 @@
 	 je	rmdir_ok3		;    yes, no problems yet...
 	cmp	DNAME[di],'.'		; is it "." or ".."?
 	 je	rmdir_ok3
+	mov	bx,di
+	call	is_lfn			; check if it is a long filename
+	 jc	rmdir_ok3		; we do not care for orphaned LFNs
 if DELWATCH
 ; We have found a dir entry - better check if it is a pending delete
 ; and that delwatch is installed. Then we can ignore it.
@@ -1445,6 +1455,7 @@
 eject
 kill_file:	; release clusters for file/dir and delete entry
 ;---------
+	call	del_lfn			; delete any preceding LFN entries
 	mov	bx,dirp			; get pointer to directory entry
 if DELWATCH
 	call	hdsblk			; AX = directory root cluster
@@ -1530,8 +1541,13 @@
 find_label30:
 	call	finddfcb		; find matching file name
 	 jz	find_label40		; skip if not found
-	test	DATTS[bx],DA_VOLUME
-	 jz	find_label30		; try again if not a volume label
+;	test	DATTS[bx],DA_VOLUME
+;	 jz	find_label30		; try again if not a volume label
+	mov	al,DATTS[bx]		; get attributes
+	and	al,256-DA_RO-DA_ARCHIVE	; ignore read only and archive bits
+	cmp	al,DA_VOLUME		; is it a volume label?
+	 jnz	find_label30		; try again if not a volume label
+	or	al,01			; clear ZF
 find_label40:
 	mov	finddfcb_mask,DA_VOLUME*256
 	ret				; back to no VOL labels or pending dels
@@ -1716,6 +1732,19 @@
 creat_handle25:
 	lea	di,DHNDL_BLK1H[bx]
 	stosw
+	lea	di,DHNDL_SIZEX[bx]	; FAT+ extended file size bits
+	mov	al,DSIZEX[si]
+	mov	ah,al
+	and	al,00000111b
+	and	ah,11100000b
+	shr	ah,1
+	shr	ah,1
+	or	al,ah
+	xor	ah,ah
+	stosw
+	xor	ax,ax
+	stosw				; zero higher file size bits
+	stosw ! stosw			; also the high dword of the position
 	lea	si,DTIME[si]
 	lea	di,DHNDL_TIME[bx]
 	movsw				; copy the time
@@ -1821,6 +1850,7 @@
 ;		CY set if device/network handle
 ;	Note:	doesn't return on error
 
+	Public	check_handle
 check_handle:
 ;------------
 	les	bx,current_dhndl
@@ -1845,6 +1875,7 @@
 	jmp	fdos_error		; return an error
 
 	public	vfy_dhndl_ptr
+	public	vfy_dhndl_ptr_AX
 
 vfy_dhndl_ptr:
 ;=============
@@ -1858,6 +1889,7 @@
 
 	mov	si,2[bp]		; SI -> parameter block
 	mov	ax,2[si]		; get file handle from parameter block
+vfy_dhndl_ptr_AX:			; alternative entry point - AX=handle
 	test	ss:byte ptr remote_call+1,DHM_FCB/100h; if we are doing an FCB operation
 	 jnz	vfy_dhndl10		;  deal only with IFN, forget PSP
 	mov	es,ss:current_psp
@@ -1892,10 +1924,12 @@
 	mov	ss:word ptr current_dhndl+WORD,es
 	test	es:DHNDL_MODE[bx],DHM_NOCRIT
 	 jnz	vfy_dhndl40		; are critical errors allowed ?
+	clc
 	ret
 
 vfy_dhndl40:
 	or	valid_flg,NO_CRIT_ERRORS
+	clc
 	ret				; remember no critical errors possible
 
 vfy_dhndl50:
@@ -1906,6 +1940,7 @@
 vfy_dhndl_err:
 	add	sp,WORD			; pop return addr - return to caller
 	mov	bx,ED_H_MATCH		;  with "invalid handle" error
+	stc
 	ret
 
 
@@ -2363,8 +2398,9 @@
 
 join_name	db	'd:\filename.ext',0
 
+		db	'Enhanced DR-DOS 7.01.08 WIP (21.7.2011) '
 		db	'Patches to original OpenDOS source code '
-		db	'Copyright (c) 2002-2005 Udo Kuhnt'
+		db	'Copyright (c) 2002-2011 Udo Kuhnt'
 
 BDOS_CODE	cseg
 
@@ -2431,9 +2467,8 @@
 	 jcxz	stamp_dir_entry10	;  if so apply it
 	mov	bx,dirp
 	cmp	dosfat,FAT32		; FAT32 file system?
-	 je	stamp_dir_entry05	; then do not overwrite this entry
+	 je	stamp_dir_entry10	; then do not overwrite this entry
 	mov	DPWM[bx],PWM_ANY	; deny all for compatibility
-stamp_dir_entry05:
 	or	DATTS[bx],DA_HIDDEN	;  make dir entry hidden
 	mov	DPWD[bx],cx		;  with this password
 stamp_dir_entry10:
@@ -2563,7 +2598,11 @@
 	callf	ss:fdos_stub
 	 jnc	check_pwd20
 
+	xor	ax,ax
+	cmp	dosfat,FAT32		; FAT32 filesystem?
+	 je	check_pwd05		; then assume no password set
 	mov	ax,DPWD[bx]		; get password hash code from entry
+check_pwd05:
 	 jcxz	check_pwd10		; exit if no password
 	cmp	ax,global_password	; compare with default password
 	 je	check_pwd10		; yes, go ahead
